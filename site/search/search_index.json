{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"community/","text":"TigerGraph Community \u00b6 Community Fourm \u00b6 TG Discord Chat \u00b6 Use the #general channel for casual conversations around TigerGraph Use the #support channel for general questions or discussion about TigerGraph Use the #tools channel for questions about TigerGraph community tools Use the #app-showcase channel for showing the things you build Use the #articles-blogs-news channel for posting interesting things you find on the web There are many other channels available, check the channel list Plotly + Dash Community \u00b6 Community Fourm \u00b6","title":"Get Connected"},{"location":"community/#tigergraph-community","text":"","title":"TigerGraph Community"},{"location":"community/#community-fourm","text":"","title":" Community Fourm"},{"location":"community/#tg-discord-chat","text":"Use the #general channel for casual conversations around TigerGraph Use the #support channel for general questions or discussion about TigerGraph Use the #tools channel for questions about TigerGraph community tools Use the #app-showcase channel for showing the things you build Use the #articles-blogs-news channel for posting interesting things you find on the web There are many other channels available, check the channel list","title":"  TG Discord Chat"},{"location":"community/#plotly-dash-community","text":"","title":"Plotly + Dash Community"},{"location":"community/#community-fourm_1","text":"","title":" Community Fourm"},{"location":"examples/","text":"Exquisite Examples \ud83e\udd73 \u00b6 We've established the power of dashboards and TigerGraph. To further solidify these claims, we can take a look at the following dashboards put together using TigerGraph and Plotly Dash \ud83d\ude0a. New feature, coming soon! If you wish to feature your dashboards here, make sure to be on the lookout for a submission form under the Community tab. Currently in the works! Healthcare Referrals \u00b6 This interactive dashboard visualizes TigerGraph's Healthcare Starter Kit. Simply by following the twelve chapters outlined in Quick Start or Adventure , you can learn how to create your own! TigerGraph's Healthcare Starter Kit COVID-19 in South Korea \u00b6 This interactive dashboard visualizes TigerGraph's COVID-19 Starter Kit. It comes alongside a Google Colab Notebook as well as a Medium Blog Post for users to follow along closely. Check out this YouTube video of the dashboard in action! TigerGraph's COVID-19 Starter Kit Movie Reviews Starter Kit \u00b6 This interactive dashboard visualizes TigerGraph's Movie Starter Kit. It comes alongside a Google Colab Notebook as well as a Medium Blog Post for users to follow along closely. Check out this YouTube video of the dashboard in action! TigerGraph's Movie Starter Kit New York's Energy and Weather \u00b6 This interactive dashboard visualizes New York's Energy and Weather data. It comes alongside a Google Colab Notebook for users to follow along closely and was presented at a webinar. Energy + Weather Dataset Want to learn how to create your own? Make sure to check out either the Quick Start or the Adventure tabs. While both cover the same content, the Dashboarding Adventure is wrapped around a story to help make the learning journey more immersive! Either way, happy dashboarding! \ud83e\udd73\ud83e\udd73\ud83e\udd73","title":"Exquisite Examples"},{"location":"examples/#exquisite-examples","text":"We've established the power of dashboards and TigerGraph. To further solidify these claims, we can take a look at the following dashboards put together using TigerGraph and Plotly Dash \ud83d\ude0a. New feature, coming soon! If you wish to feature your dashboards here, make sure to be on the lookout for a submission form under the Community tab. Currently in the works!","title":"Exquisite Examples \ud83e\udd73"},{"location":"examples/#healthcare-referrals","text":"This interactive dashboard visualizes TigerGraph's Healthcare Starter Kit. Simply by following the twelve chapters outlined in Quick Start or Adventure , you can learn how to create your own! TigerGraph's Healthcare Starter Kit","title":"Healthcare Referrals"},{"location":"examples/#covid-19-in-south-korea","text":"This interactive dashboard visualizes TigerGraph's COVID-19 Starter Kit. It comes alongside a Google Colab Notebook as well as a Medium Blog Post for users to follow along closely. Check out this YouTube video of the dashboard in action! TigerGraph's COVID-19 Starter Kit","title":"COVID-19 in South Korea"},{"location":"examples/#movie-reviews-starter-kit","text":"This interactive dashboard visualizes TigerGraph's Movie Starter Kit. It comes alongside a Google Colab Notebook as well as a Medium Blog Post for users to follow along closely. Check out this YouTube video of the dashboard in action! TigerGraph's Movie Starter Kit","title":"Movie Reviews Starter Kit"},{"location":"examples/#new-yorks-energy-and-weather","text":"This interactive dashboard visualizes New York's Energy and Weather data. It comes alongside a Google Colab Notebook for users to follow along closely and was presented at a webinar. Energy + Weather Dataset Want to learn how to create your own? Make sure to check out either the Quick Start or the Adventure tabs. While both cover the same content, the Dashboarding Adventure is wrapped around a story to help make the learning journey more immersive! Either way, happy dashboarding! \ud83e\udd73\ud83e\udd73\ud83e\udd73","title":"New York's Energy and Weather"},{"location":"resources/","text":"All the external resources from Quick Start/Adventure , all in one place. \ud83e\uddd0 Some of the chapter titles may be abbreviated to account for the extra emojis! Ch 01 - Installation Island \ud83c\udfdd\ufe0f \u00b6 TigerGraph\u2019s Cloud Portal TigerGraph Docs GSQL 101 Module (Video) Ch 02 - Sailing thru' Setup Sea \ud83c\udf0a \u00b6 html.Div() Dash Headers Dash HTML html.B() html.I() Ch 03 - Presenting Port Plotly \ud83e\uddf1 \u00b6 Plotly Bar Charts px.Bar() Plotly Line Charts px.line() Plotly Pie Charts px.Pie() Plotly Trendlines Plotly Scatter px.Scatter() Ch 04 - Dash's Delta \ud83c\udf3f \u00b6 Dash Core Dash Boostrap dbc.Card() dbc.Layout() Ch 05 - Sheriff Styles \u2b50\ufe0f \u00b6 dbc.Badge() dcc.Markdown() dbc.ListGroup() Ch 06 - TigerGraph Tundra \ud83d\udc2f \u00b6 pyTG functions Dash Cytoscape Ch 07 - Multi-Page Monsters \ud83e\udd96 \u00b6 None at the moment! Ch 08 - Confronting Callbacks \ud83e\udd95 \u00b6 dbc.Button() dcc.Input dcc.Dropdown() Ch 09 - Northern Navbars \u26c4\ufe0f \u00b6 dbc.Navbar() Ch 10 - Southern Sidebars \ud83c\udf35 \u00b6 Dash Sidebar (Video) Ch 11 - Elysium of Elements \ud83c\udf08 \u00b6 Plotly Radar 3D Scatter 3D Charts Choropleth dbc.Progress() dbc.Spinner() dbc.Alert() Ch 12 - Dest. Deployment \u2728 \u00b6 Dash Deployment Heroku Guide 1 Heroku Guide 2 Misc - Additional Resources \u00b6 TigerGraph + Plotly (Video) COVID-19 in South Korea (Video) Movie Reviews Starter Kit (Video) New York's Energy/Weather (Video) Fraud Detection Dashboard Blog Post","title":"Resources"},{"location":"resources/#ch-01-installation-island","text":"TigerGraph\u2019s Cloud Portal TigerGraph Docs GSQL 101 Module (Video)","title":"Ch 01 - Installation Island \ud83c\udfdd\ufe0f"},{"location":"resources/#ch-02-sailing-thru-setup-sea","text":"html.Div() Dash Headers Dash HTML html.B() html.I()","title":"Ch 02 - Sailing thru' Setup Sea \ud83c\udf0a"},{"location":"resources/#ch-03-presenting-port-plotly","text":"Plotly Bar Charts px.Bar() Plotly Line Charts px.line() Plotly Pie Charts px.Pie() Plotly Trendlines Plotly Scatter px.Scatter()","title":"Ch 03 - Presenting Port Plotly \ud83e\uddf1"},{"location":"resources/#ch-04-dashs-delta","text":"Dash Core Dash Boostrap dbc.Card() dbc.Layout()","title":"Ch 04 - Dash's Delta \ud83c\udf3f"},{"location":"resources/#ch-05-sheriff-styles","text":"dbc.Badge() dcc.Markdown() dbc.ListGroup()","title":"Ch 05 - Sheriff Styles \u2b50\ufe0f"},{"location":"resources/#ch-06-tigergraph-tundra","text":"pyTG functions Dash Cytoscape","title":"Ch 06 - TigerGraph Tundra \ud83d\udc2f"},{"location":"resources/#ch-07-multi-page-monsters","text":"None at the moment!","title":"Ch 07 - Multi-Page Monsters \ud83e\udd96"},{"location":"resources/#ch-08-confronting-callbacks","text":"dbc.Button() dcc.Input dcc.Dropdown()","title":"Ch 08 - Confronting Callbacks \ud83e\udd95"},{"location":"resources/#ch-09-northern-navbars","text":"dbc.Navbar()","title":"Ch 09 - Northern Navbars \u26c4\ufe0f"},{"location":"resources/#ch-10-southern-sidebars","text":"Dash Sidebar (Video)","title":"Ch 10 - Southern Sidebars \ud83c\udf35"},{"location":"resources/#ch-11-elysium-of-elements","text":"Plotly Radar 3D Scatter 3D Charts Choropleth dbc.Progress() dbc.Spinner() dbc.Alert()","title":"Ch 11 - Elysium of Elements \ud83c\udf08"},{"location":"resources/#ch-12-dest-deployment","text":"Dash Deployment Heroku Guide 1 Heroku Guide 2","title":"Ch 12 - Dest. Deployment \u2728"},{"location":"resources/#misc-additional-resources","text":"TigerGraph + Plotly (Video) COVID-19 in South Korea (Video) Movie Reviews Starter Kit (Video) New York's Energy/Weather (Video) Fraud Detection Dashboard Blog Post","title":"Misc - Additional Resources"},{"location":"intro/A_01_devoid-of-dash/","text":"Devoid of Dash \ud83d\udcbb \u00b6 Imagine a world... without dashboards . On a superficial glance, it would seem that nothing's changed. People continue to interact in the same ways they've done day-after-day. Businesses continue to operate in the same manners like clockwork. Information is shared and used as it always has been. Life goes on... Such a conjecture couldn't be further from the truth. The 21 st century is built on data. With the proliferation of data aggregation, structuring, and analysis, Big Data has transformed our interconnected society. Information is invaluable. Millions, billions, and trillions of data values can be quickly analyzed via powerful algorithms to uncover new patterns, interesting correlations, and unexpected conclusions. Yet messy code segments, lines of JSON output, and unconnected queries simply cannot capture all of the golden needles hidden within these massive haystacks of information. With dashboards, our data can be transformed into powerful visualizations. But don't just take my word for it, Al Shalloway, Founder of Net Objectives Visualizations act as a campfire around which we gather to tell stories. Carly Fiorina, Former CEO of Hewlett-Packard The goal is to turn data into information, and information into insight. Dashboards go hand-in-hand with any endeavor involving the collection of information. Knowing of their profound importance begs the question, how do we create our own? Well for that, dear reader, we turn to our Trusty Toolbox!","title":"Devoid of Dash"},{"location":"intro/A_01_devoid-of-dash/#devoid-of-dash","text":"Imagine a world... without dashboards . On a superficial glance, it would seem that nothing's changed. People continue to interact in the same ways they've done day-after-day. Businesses continue to operate in the same manners like clockwork. Information is shared and used as it always has been. Life goes on... Such a conjecture couldn't be further from the truth. The 21 st century is built on data. With the proliferation of data aggregation, structuring, and analysis, Big Data has transformed our interconnected society. Information is invaluable. Millions, billions, and trillions of data values can be quickly analyzed via powerful algorithms to uncover new patterns, interesting correlations, and unexpected conclusions. Yet messy code segments, lines of JSON output, and unconnected queries simply cannot capture all of the golden needles hidden within these massive haystacks of information. With dashboards, our data can be transformed into powerful visualizations. But don't just take my word for it, Al Shalloway, Founder of Net Objectives Visualizations act as a campfire around which we gather to tell stories. Carly Fiorina, Former CEO of Hewlett-Packard The goal is to turn data into information, and information into insight. Dashboards go hand-in-hand with any endeavor involving the collection of information. Knowing of their profound importance begs the question, how do we create our own? Well for that, dear reader, we turn to our Trusty Toolbox!","title":"Devoid of Dash \ud83d\udcbb"},{"location":"intro/A_02_getting-started/","text":"Trusty Toolbox \ud83d\udd28 \u00b6 A dashboard consists of two fundamental components: Framework for loading, storing, and running algorithms to analyze datasets Framework for extracting and displaying valuable information from the data Our toolbox contains the two perfect tools needed for these tasks... Introducing TigerGraph \u00b6 TigerGraph is a native parallel graph database that can load and analyze large amounts of data in real-time. In comparison to traditional relational databases, TigerGraph's architecture and accompanying graph query language (GSQL) allow for quick, efficient, and powerful analytics . Goin' Graphs \u00b6 The following blog post summarizes the importance of Graph Databses. For a more comprehensive overview, feel free to check out the following four modules: Module 1 - Introduction to Graph Database and Analytics Module 2 - Managing Relationships - Relational, NoSQL, and Graph Database Module 3 - Evolution of Graph Databases Module 4 - Seven Key Data Science Capabilities of a Native Parallel Database As summarized neatly by Oracle, Oracle's 17 Use Cases for Graph Databases and Graph Analytics Graph technologies have become a groundbreaking way for organizations everywhere to address uses that other methods simply can\u2019t address in an efficient manner . Now, how do we go about creating our own? The Cloud Portal \u00b6 TigerGraph graciously provides a free-tier cloud portal open to all. Creating an account is as simple as navigating to its website and clicking on the orange Login/Register button. We'll cover setting up one's first solution in the ensuing \"Dashboarding 101\" section. For a brief introduction, feel free to check out the following video: Getting Started with TigerGraph Cloud (2021) NOTE: For a detailed overview of TigerGraph Cloud, make sure to check out: TG Cloud Docs For now, we can move onto the second half of our toolbox... Introducing Plotly \u00b6 Plotly is an interactive graphing library used to visualize data. It is quite powerful in terms of its features and is rather easy to learn and begin working with. Two Plotly modules we'll be using in our dashboard can be summarized below: Plotly Express: a high-level wrapper for creating visualizations Plotly Dash: a Python framework for easily building applications Both of these modules will be covered in the \"Dashboarding 101\" section. All Aboard the Plotly Express \u00b6 For more information regarding Plotly Express, feel free to check out the following blog: Introducing Plotly Express - By Plotly on Medium Designing with Plotly Dash \u00b6 For more information regarding Plotly Dash, feel free to check out the following video: Getting Started with TigerGraph Cloud (2021) Pretty exciting! TigerGraph + Plotly are both powerful, easy-to-use tools. Let's learn how to harness their power to create dashboards... While \"Quick Start\" contains a condensed, no-fluff guide to creating dashboards, \"Adventure\" weaves the same content around an immersive story. Feel free to explore either!","title":"Trusty Toolbox"},{"location":"intro/A_02_getting-started/#trusty-toolbox","text":"A dashboard consists of two fundamental components: Framework for loading, storing, and running algorithms to analyze datasets Framework for extracting and displaying valuable information from the data Our toolbox contains the two perfect tools needed for these tasks...","title":"Trusty Toolbox \ud83d\udd28"},{"location":"intro/A_02_getting-started/#introducing-tigergraph","text":"TigerGraph is a native parallel graph database that can load and analyze large amounts of data in real-time. In comparison to traditional relational databases, TigerGraph's architecture and accompanying graph query language (GSQL) allow for quick, efficient, and powerful analytics .","title":"Introducing TigerGraph"},{"location":"intro/A_02_getting-started/#goin-graphs","text":"The following blog post summarizes the importance of Graph Databses. For a more comprehensive overview, feel free to check out the following four modules: Module 1 - Introduction to Graph Database and Analytics Module 2 - Managing Relationships - Relational, NoSQL, and Graph Database Module 3 - Evolution of Graph Databases Module 4 - Seven Key Data Science Capabilities of a Native Parallel Database As summarized neatly by Oracle, Oracle's 17 Use Cases for Graph Databases and Graph Analytics Graph technologies have become a groundbreaking way for organizations everywhere to address uses that other methods simply can\u2019t address in an efficient manner . Now, how do we go about creating our own?","title":"Goin' Graphs"},{"location":"intro/A_02_getting-started/#the-cloud-portal","text":"TigerGraph graciously provides a free-tier cloud portal open to all. Creating an account is as simple as navigating to its website and clicking on the orange Login/Register button. We'll cover setting up one's first solution in the ensuing \"Dashboarding 101\" section. For a brief introduction, feel free to check out the following video: Getting Started with TigerGraph Cloud (2021) NOTE: For a detailed overview of TigerGraph Cloud, make sure to check out: TG Cloud Docs For now, we can move onto the second half of our toolbox...","title":"The Cloud Portal"},{"location":"intro/A_02_getting-started/#introducing-plotly","text":"Plotly is an interactive graphing library used to visualize data. It is quite powerful in terms of its features and is rather easy to learn and begin working with. Two Plotly modules we'll be using in our dashboard can be summarized below: Plotly Express: a high-level wrapper for creating visualizations Plotly Dash: a Python framework for easily building applications Both of these modules will be covered in the \"Dashboarding 101\" section.","title":"Introducing Plotly"},{"location":"intro/A_02_getting-started/#all-aboard-the-plotly-express","text":"For more information regarding Plotly Express, feel free to check out the following blog: Introducing Plotly Express - By Plotly on Medium","title":"All Aboard the Plotly Express"},{"location":"intro/A_02_getting-started/#designing-with-plotly-dash","text":"For more information regarding Plotly Dash, feel free to check out the following video: Getting Started with TigerGraph Cloud (2021) Pretty exciting! TigerGraph + Plotly are both powerful, easy-to-use tools. Let's learn how to harness their power to create dashboards... While \"Quick Start\" contains a condensed, no-fluff guide to creating dashboards, \"Adventure\" weaves the same content around an immersive story. Feel free to explore either!","title":"Designing with Plotly Dash"},{"location":"learn/01_installation-island/","text":"Installation Island \ud83c\udfdd\ufe0f \u00b6 As the moon melts on the horizon, we wake up to find ourselves in a strange place. There are a few lonely palm trees, coconuts littered across the sand, and miles of ocean stretching out as far as the eye can see. Turning around, we find an ancient scroll next to us: On a quest, you must embark with speed. Learning how to create dashboards with ease. On this island, find the tools you'll need. With TigerGraph and Plotly, you shall succeed. Sitting next to the scroll, there\u2019s an orange box with a strange laptop resting upon it... The TigerGraph Toolbox \u00b6 \u201cEvery dashboard starts with the data!\u201d reads the white engraving on the laptop. Opening the box fully reveals three strange manuscripts, each detailing the steps needed to begin harnessing the Power of TigerGraph . Eagerly, we open up the laptop and begin to examine each. Mysterious Manuscript 01 Creating our Solution \u00b6 Welcome to Step 1 of the Beginner\u2019s Guide to Dashboarding! In order to load and store the data for our dashboard, we must create a new TigerGraph solution. To do this, we can: Navigate to TigerGraph\u2019s Cloud Portal Login/Register for free using our email address Click on the blue \u201cCreate Solution\u201d button Nagvigate to the Healthcare tab Select \u201cHealthcare Engine\u201d Starter Kit NOTE: For the purposes of learning dashboarding, we will be using TigerGraph\u2019s Healthcare Engine Starter Kit. This Starter Kit comes with over # vertices, # edges, and [still need to finish researching this] data attributes. Next, we must enter the details for our solution. Name - This we can simply keep as \"Healthcare Engine\" Tags - We can add \"Dashboard\", \"Healthcare\" Password - By default, it's \"tigergraph\" Subdomain - This can be \"healthcare-dash\" NOTE: Make sure that your subdomain name is unique! (two solutions cannot have the same subdomain at the same time. This subdomain name is used to access your solution (via GraphStudio, for example) Once this has been completed, click \u201cNext\u201d and then \u201cSubmit\u201d . And voila, in a few seconds, our solution should go from \u201cUninitialized\u201d to \u201cReady\u201d! After reading through the first manuscript, we reach for the second one... Mysterious Manuscript 02 Loading our Data \u00b6 Ahh, you've reached Step 2 of the Beginner\u2019s Guide to Dashboarding! Next up, it\u2019s time to load in our data. To do this, we need to: Open GraphStudio by selecting it from the Applications tab Click on MyGraph . This is the graph we\u2019ll be using NOTE: Additional graphs can be added, deleted, and modified as desired by the user. For the purposes of this dashboard, we will be using the default graph the Healthcare Engine Starter Kit comes with. Time to take a look at our schema! Navigate over to the \u201cDesign Schema\u201d tab on the right. This is our schema, the blueprint of our graph. It consists of vertices connected to one another via edges. Each vertex can be of a different type and contain different attributes. Similarly, edges can be directional, undirected, and even reversed. Each edge can contain different attributes as well, each with multiple datatypes. Hovering over each component, we see that our schema in this Starter Kit consists of: NOTE: This schema can be modified by switching to \u201cGlobal View\u201d and editing the properties of each vertex and edge. Additionally, vertices and edges may be added and deleted. For a comprehensive guide on creating your own schemas, make sure to check out these resources: TigerGraph Docs , YouTube GSQL 101 Next, we can navigate to the \u201cMap Data to Graph\u201d tab. This section ensures that the raw CSV data files are imported correctly into our graph. Each column is mapped to the appropriate attribute in the appropriate vertex/edge. In order to modify this mapping, we can simply click the \u201cEdit Data Mapping\u201d icon at the top and select the file and component(s) we wish to map. Next, we click on the source column in the CSV file and match it to the corresponding attribute. When we\u2019re all finished, we can click the \u201cPublish Data Mapping\u201d icon at the top left corner. Everything here looks good! Next up, we can navigate to the \u201cLoad Data\u201d tab. Simply press on the white play icon at the top left corner and the loading job should begin automatically. The graph on the right-side displays the progress with respect to time. When the loading has finished, all CSV files should say \u201cfinished\u201d . Only one manuscript left in the box... Mysterious Manuscript 03 Connecting with pyTG \u00b6 Surprised you made this far, eh? Step 3 of the Beginner\u2019s Guide to Dashboarding! In order to interface with our Graph, we will utilize pyTigerGraph . To begin, we can simply install this package by running the following command. ! pip install - q pyTigerGraph import pyTigerGraph as tg Next, we need to use our solution information from before. TG_SUBDOMAIN = \"healthcare-dash\" TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph NOTE: As mentioned in the previous document, subdomain names should be unique! Now, we can run the following lines to establish a connection with our solution. conn = tg . TigerGraphConnection ( host = TG_HOST , username = TG_USERNAME , password = TG_PASSWORD , graphname = TG_GRAPHNAME ) conn . apiToken = conn . getToken ( conn . createSecret ()) print ( \"Connected!\" ) Voila, we\u2019re in! As we put down the three manuscripts , we hear a rumbling from the beach! After quickly bookmarking TigerGraph Cloud and our solution\u2019s subdomain , we close the laptop, grab the box and the manuscripts, and make our way to the source of the commotion... The Plotly Pirates \u00b6 \u201cRRRR\u201d comes a gruff voice. Standing on the shore, we're surprised to see two strange pirates standing next to their rather shabby brown canoe. As we walk towards them, they turn and look at us with a wry grin. \"Ahh, that orange box ya got there, you've begun your quest?\" questions the first. \"Well then, better come with us back to Port Plotly. \u201d finishes the second. Well, not many other options for leaving the island... Clutching the laptop and orange box, we cautiously climb into the canoe as the two pirates sit in front of us. While one of them paddles, the other gestures to our strange new laptop. \u201cMight wanna open that up lad\u2019. It\u2019s time y'all learned a few things bout\u2019 our namesake\u2026\u201d As the island shrunk in the distance, the pirates began to explain the Power of Plotly\u2026 All code segments from this chapter can be found in this Colab Notebook . Feel free to follow along! \u21a9 Everything we've installed so far (prerequistes for next section): ! pip install - q pyTigerGraph import pyTigerGraph as tg TG_SUBDOMAIN = 'healthcare-dash' TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio Link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph conn = tg . TigerGraphConnection ( host = TG_HOST , graphname = TG_GRAPHNAME , username = TG_USERNAME , password = TG_PASSWORD , beta = True ) conn . apiToken = conn . getToken ( conn . createSecret ()) \u21a9","title":"Ch 01 - Installation Island"},{"location":"learn/01_installation-island/#installation-island","text":"As the moon melts on the horizon, we wake up to find ourselves in a strange place. There are a few lonely palm trees, coconuts littered across the sand, and miles of ocean stretching out as far as the eye can see. Turning around, we find an ancient scroll next to us: On a quest, you must embark with speed. Learning how to create dashboards with ease. On this island, find the tools you'll need. With TigerGraph and Plotly, you shall succeed. Sitting next to the scroll, there\u2019s an orange box with a strange laptop resting upon it...","title":"Installation Island \ud83c\udfdd\ufe0f"},{"location":"learn/01_installation-island/#the-tigergraph-toolbox","text":"\u201cEvery dashboard starts with the data!\u201d reads the white engraving on the laptop. Opening the box fully reveals three strange manuscripts, each detailing the steps needed to begin harnessing the Power of TigerGraph . Eagerly, we open up the laptop and begin to examine each. Mysterious Manuscript 01","title":"The TigerGraph Toolbox"},{"location":"learn/01_installation-island/#creating-our-solution","text":"Welcome to Step 1 of the Beginner\u2019s Guide to Dashboarding! In order to load and store the data for our dashboard, we must create a new TigerGraph solution. To do this, we can: Navigate to TigerGraph\u2019s Cloud Portal Login/Register for free using our email address Click on the blue \u201cCreate Solution\u201d button Nagvigate to the Healthcare tab Select \u201cHealthcare Engine\u201d Starter Kit NOTE: For the purposes of learning dashboarding, we will be using TigerGraph\u2019s Healthcare Engine Starter Kit. This Starter Kit comes with over # vertices, # edges, and [still need to finish researching this] data attributes. Next, we must enter the details for our solution. Name - This we can simply keep as \"Healthcare Engine\" Tags - We can add \"Dashboard\", \"Healthcare\" Password - By default, it's \"tigergraph\" Subdomain - This can be \"healthcare-dash\" NOTE: Make sure that your subdomain name is unique! (two solutions cannot have the same subdomain at the same time. This subdomain name is used to access your solution (via GraphStudio, for example) Once this has been completed, click \u201cNext\u201d and then \u201cSubmit\u201d . And voila, in a few seconds, our solution should go from \u201cUninitialized\u201d to \u201cReady\u201d! After reading through the first manuscript, we reach for the second one... Mysterious Manuscript 02","title":"Creating our Solution"},{"location":"learn/01_installation-island/#loading-our-data","text":"Ahh, you've reached Step 2 of the Beginner\u2019s Guide to Dashboarding! Next up, it\u2019s time to load in our data. To do this, we need to: Open GraphStudio by selecting it from the Applications tab Click on MyGraph . This is the graph we\u2019ll be using NOTE: Additional graphs can be added, deleted, and modified as desired by the user. For the purposes of this dashboard, we will be using the default graph the Healthcare Engine Starter Kit comes with. Time to take a look at our schema! Navigate over to the \u201cDesign Schema\u201d tab on the right. This is our schema, the blueprint of our graph. It consists of vertices connected to one another via edges. Each vertex can be of a different type and contain different attributes. Similarly, edges can be directional, undirected, and even reversed. Each edge can contain different attributes as well, each with multiple datatypes. Hovering over each component, we see that our schema in this Starter Kit consists of: NOTE: This schema can be modified by switching to \u201cGlobal View\u201d and editing the properties of each vertex and edge. Additionally, vertices and edges may be added and deleted. For a comprehensive guide on creating your own schemas, make sure to check out these resources: TigerGraph Docs , YouTube GSQL 101 Next, we can navigate to the \u201cMap Data to Graph\u201d tab. This section ensures that the raw CSV data files are imported correctly into our graph. Each column is mapped to the appropriate attribute in the appropriate vertex/edge. In order to modify this mapping, we can simply click the \u201cEdit Data Mapping\u201d icon at the top and select the file and component(s) we wish to map. Next, we click on the source column in the CSV file and match it to the corresponding attribute. When we\u2019re all finished, we can click the \u201cPublish Data Mapping\u201d icon at the top left corner. Everything here looks good! Next up, we can navigate to the \u201cLoad Data\u201d tab. Simply press on the white play icon at the top left corner and the loading job should begin automatically. The graph on the right-side displays the progress with respect to time. When the loading has finished, all CSV files should say \u201cfinished\u201d . Only one manuscript left in the box... Mysterious Manuscript 03","title":"Loading our Data"},{"location":"learn/01_installation-island/#connecting-with-pytg","text":"Surprised you made this far, eh? Step 3 of the Beginner\u2019s Guide to Dashboarding! In order to interface with our Graph, we will utilize pyTigerGraph . To begin, we can simply install this package by running the following command. ! pip install - q pyTigerGraph import pyTigerGraph as tg Next, we need to use our solution information from before. TG_SUBDOMAIN = \"healthcare-dash\" TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph NOTE: As mentioned in the previous document, subdomain names should be unique! Now, we can run the following lines to establish a connection with our solution. conn = tg . TigerGraphConnection ( host = TG_HOST , username = TG_USERNAME , password = TG_PASSWORD , graphname = TG_GRAPHNAME ) conn . apiToken = conn . getToken ( conn . createSecret ()) print ( \"Connected!\" ) Voila, we\u2019re in! As we put down the three manuscripts , we hear a rumbling from the beach! After quickly bookmarking TigerGraph Cloud and our solution\u2019s subdomain , we close the laptop, grab the box and the manuscripts, and make our way to the source of the commotion...","title":"Connecting with pyTG"},{"location":"learn/01_installation-island/#the-plotly-pirates","text":"\u201cRRRR\u201d comes a gruff voice. Standing on the shore, we're surprised to see two strange pirates standing next to their rather shabby brown canoe. As we walk towards them, they turn and look at us with a wry grin. \"Ahh, that orange box ya got there, you've begun your quest?\" questions the first. \"Well then, better come with us back to Port Plotly. \u201d finishes the second. Well, not many other options for leaving the island... Clutching the laptop and orange box, we cautiously climb into the canoe as the two pirates sit in front of us. While one of them paddles, the other gestures to our strange new laptop. \u201cMight wanna open that up lad\u2019. It\u2019s time y'all learned a few things bout\u2019 our namesake\u2026\u201d As the island shrunk in the distance, the pirates began to explain the Power of Plotly\u2026 All code segments from this chapter can be found in this Colab Notebook . Feel free to follow along! \u21a9 Everything we've installed so far (prerequistes for next section): ! pip install - q pyTigerGraph import pyTigerGraph as tg TG_SUBDOMAIN = 'healthcare-dash' TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio Link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph conn = tg . TigerGraphConnection ( host = TG_HOST , graphname = TG_GRAPHNAME , username = TG_USERNAME , password = TG_PASSWORD , beta = True ) conn . apiToken = conn . getToken ( conn . createSecret ()) \u21a9","title":"The Plotly Pirates"},{"location":"learn/02_setup-sea/","text":"Sailing through Setup Sea \ud83c\udf0a \u00b6 \u201cLong ago, avid data scientists and developers sought for a way to visualize their vast collections of information. Various complicated systems were all used throughout the land. But then, in 2012, a group of four Canadian explorers discovered the power of a tool called Plotly. Plotly transformed life for every creator. Dashboards and visualizations could be put together in mere minutes, all in Python. Gone were the days of laboring for weeks learning out how to create intricate, multi-layered applications. With Plotly, anyone could create a dashboard. \u201d The pirates turn and point to our laptop. \u201cEvery dashboarder needs to learn how to harness the power of Plotly. Creating your first dashboard isn\u2019t as hard as you may think. Follow along lads, and we\u2019ll tell you what we know.\u201d Eager to learn more, we begin to jot down their words\u2026 Plotly Pirates' Notes 01 Proper Prerequisites \u00b6 While TigerGraph\u2019s Cloud Portal provides the solution, data, and queries needed to analyze our graph, we need the help of another tool to create our dashboard. With Plotly , the task of doing so is made simple, intuitive, and easy. To begin, we must first install the proper packages. When running Plotly via a Google Colab , we will first need to use the following command: ! pip install - q jupyter - dash Jupyter-dash allows the dashboard to be configured for modification via a Python Notebook . This way, the dashboard is updated in real-time with the modification of any cells. Without using the jupyter-dash package, every change made to the dashboard would have to be followed by a recompilation of the app (quite tedious) . Now, we can import our Python libraries with the following line: import dash from jupyter_dash import JupyterDash import dash_html_components as html The library dash_html_components allows for access to Plotly Dash\u2019s HTML components, allowing us to display HTML elements such as text and linebreaks. We'll cover more of these in the ensuing sections! At this point, the pirates pause. \u201cWe only know these packages for now. Pilaging doesn\u2019t leave much time to learn further. At Port Plotly, ya\u2019ll find what you need from the locals. Theys\u2019 a lot more knowledgeable.\u201d explains the first. \u201cBut that\u2019s okay\u201d , finishes the second, \u201cthese two packages are quite powerful...\u201d Plotly Pirates' Notes 02 Functioning First App \u00b6 In order to create our first app, we can simply run the following lines: app = JupyterDash ( __name__ ) app . layout = html . Div ( children = [ html . P ( children = 'Hello Dash' ), ]) app . run_server ( mode = 'external' ) Running the following produces the following output: Dash App running on : http : // 127.0.0.1 : 8050 / Clicking on the link takes us to our first dashboard! Great! Albeit, quite simple \ud83d\ude05. Breaking it down, we can see that our first line initialized the dash app. Since we are running from the Google Colab Notebook, we will use the JupyterDash() constructor instead of the standard app=dash.Dash() constructor. Next, we define the app\u2019s layout. Using an HTML .Div() element, we can divide our content into different sections. It is simply a container used to hold other components and establish a structure in our dashboard. For example, our Div element currently contains one element, represented by the attribute children = [...] . Any components contained in the attribute \u201cchildren\u201d will belong to this html.Div() element. Each children component must be separated by a comma. We can try adding another html.P (a simple paragraph) to our app: app . layout = html . Div ( children = [ html . P ( children = 'Hello Dash' ), html . P ( \u2018 Guess who \u2019 s back ?\u2019 ), ]) Running this will produce the following output to the right: Ahh, you might have noticed that we\u2019ve omitted the children attribute in the second html.P() statement. This is because \u2018children\u2019 is optional and does not to be specified. For example, app . layout = html . Div ([ html . P ( 'Hello Dash' ), html . P ( \u2018 Guess who \u2019 s back ?\u2019 ), ]) Running this will produce the following output to the right: See, same result as above! NOTE: For more information on .Div(), make sure to check out the following resources: html.Div() The pirates grin upon seeing our wide-eyed surprise. \u201cNow, let\u2019s tie it together with those TigerGraph texts\u201d , they exclaim, pointing at our three manuscripts from the island. Plotly Pirates' Notes 03 Using Layout Functions \u00b6 We can create a function to return information to be displayed in our app. This will help make our layout cleaner, more readable, and easier to scale . All content can simply be wrapped in an html.Div() element. To begin, we can add the following functions and change our layout: def setup_TG (): row = html . Div ([ html . P ( \"Connected to TigerGraph Solution Subdomain:\" , TG_SUBDOMAIN ) html . P ( \"Currently working on Graph title:\" , TG_GRAPHNAME ) ]) return row app . layout = html . Div ([ html . P ( \u201c Welcome to Dash \u201d ) setup_TG () ]) And voila, as seen, our app now looks like the following: These functions can come in quite handy when creating complicated layouts. The pirates turn and point. In the distance, the faint outline of a port can be seen. \u201cLand ho! Well lads, time to finish up with the last section for today\u2026 adding a little bit of flavor .\u201d Plotly Pirates' Notes 04 Transforming Text \u00b6 Dash\u2019s text elements are quite powerful . Here are a few simple ways to spice it up! We can modify our simple app as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 TITLE_STYLE = { \"background-color\" : \"#abc7ed\" , \"margin-bottom\" : \"20px\" , \"padding\" : \"5px\" } def setup_TG (): row = html . Div ([ html . P ( html . B ( \"Connected to Solution: \" + TG_SUBDOMAIN ), style = { 'color' : 'green' }), html . P ( html . I ( \"Currently working on Graph title: \" + TG_GRAPHNAME ), style = { 'color' : 'blue' }) ]) return row app = JupyterDash ( __name__ ) app . layout = html . Div ([ html . Div ( html . H1 ( \"Welcome to Dash\" ), style = TITLE_STYLE ), # Adding style, header setup_TG () # Adding style, bold, italics ]) app . run_server ( mode = 'external' ) Here's the resulting output: Let's break it down, component by component! HTML Headers \u00b6 One of the easiest ways to spice up one's dashboard is to vary the text styles . This can be done using simple HTML header elements (H1, H2, H3, H4, H5, H6) . A table showing each one's output can be found below. Header 1 Headers 4 - 6 Header 3 Header 4 Header 5 Header 6 What's Up? Good Day. Bless You! Well done. Happy Birthday! Goodbye? The specific style of each will change based on the font. However, the relative sizes can be seen above. NOTE: For more information on HTML, feel free to check out the following resources: Dash Headers , Dash HTML In line 18 of our code snippet, we see that our html.P() element is now html.H1() . 18 html . Div ( html . H1 ( \"Welcome to Dash\" ), style = TITLE_STYLE ), # Adding style, header Pretty simple and effective! Ahh, you may have noticed the html.Div() element that the header is wrapped in . Let's take a closer look at the reason for this... Style Dictionary \u00b6 One of the best ways to style a dashboard is to use a style dictionary . In these dictionaries, one can specify attributes such as background color, padding, margins, font style, font color, etc . In lines 1- 5, we explicitly create a style dictionary titled TITLE_STYLE . 1 2 3 4 5 TITLE_STYLE = { \"background-color\" : \"#abc7ed\" , \"margin-bottom\" : \"20px\" , \"padding\" : \"5px\" } This dictionary is then passed into the html.Div() element which contains our header. As a result, the header is given extra padding, margin, and a light-blue background . Pretty straightforward! This style dictionary doesn't have to be stored in a variable . In lines 9 and 10, we explicitly change the colors of each html.P() using the keyword style . 9 10 html . P ( html . B ( \"Connected to Solution: \" + TG_SUBDOMAIN ), style = { 'color' : 'green' }), html . P ( html . I ( \"Currently working on Graph title: \" + TG_GRAPHNAME ), style = { 'color' : 'blue' }) NOTE: Color can take both keywords (ex. common colors like red, orange) as well as hex values (ex. 'DD659F') This brings us to our next point, the html.B() and html.I() used in lines 9 and 10. Html.B(), Html.I() \u00b6 In order to bold or italicize sections of text, we can simply use html.B() and html.I() These elements can stand on their own without being wrapped in html.P() elements. However, this removes the division between two lines . For example, the following two lines produce the following output: 9 10 html . B ( \"Connected to Solution: \" + TG_SUBDOMAIN , style = { 'color' : 'green' }), html . I ( \"Currently working on Graph title: \" + TG_GRAPHNAME , style = { 'color' : 'blue' }) NOTE: For more information on these two elements, feel free to check out the following: html.B() , html.I() There are so many more ways to transform text! We'll cover other methods in Chapter 05 - Sheriff Styles ! As we pull into Port, the pirates help us get out of their canoe. \u201cHere, you lads will learn more about Plotly. Pay careful attention and make sure to note everything down in there, \" advises the first, pointing to our laptop. The second tips his hat to us, \u201cFair winds to thee good friends! Cast off!\u201d And with that, the peculiar pirates had left. Turning around, a large sign greets us, \u201cWelcome to Port Plotly! A one-stop-shop for data analytics and visualization!\u201d All code segments from this chapter can be found in this Colab Notebook . Feel free to follow along! \u21a9 Everything we've installed so far (prerequistes for next section): ! pip install - q pyTigerGraph import pyTigerGraph as tg TG_SUBDOMAIN = 'healthcare-dash' TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio Link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph conn = tg . TigerGraphConnection ( host = TG_HOST , graphname = TG_GRAPHNAME , username = TG_USERNAME , password = TG_PASSWORD , beta = True ) conn . apiToken = conn . getToken ( conn . createSecret ()) ! pip install - q jupyter - dash import dash import dash_html_components as html from jupyter_dash import JupyterDash \u21a9","title":"Ch 02 - Sailing through Setup Sea"},{"location":"learn/02_setup-sea/#sailing-through-setup-sea","text":"\u201cLong ago, avid data scientists and developers sought for a way to visualize their vast collections of information. Various complicated systems were all used throughout the land. But then, in 2012, a group of four Canadian explorers discovered the power of a tool called Plotly. Plotly transformed life for every creator. Dashboards and visualizations could be put together in mere minutes, all in Python. Gone were the days of laboring for weeks learning out how to create intricate, multi-layered applications. With Plotly, anyone could create a dashboard. \u201d The pirates turn and point to our laptop. \u201cEvery dashboarder needs to learn how to harness the power of Plotly. Creating your first dashboard isn\u2019t as hard as you may think. Follow along lads, and we\u2019ll tell you what we know.\u201d Eager to learn more, we begin to jot down their words\u2026 Plotly Pirates' Notes 01","title":"Sailing through Setup Sea \ud83c\udf0a"},{"location":"learn/02_setup-sea/#proper-prerequisites","text":"While TigerGraph\u2019s Cloud Portal provides the solution, data, and queries needed to analyze our graph, we need the help of another tool to create our dashboard. With Plotly , the task of doing so is made simple, intuitive, and easy. To begin, we must first install the proper packages. When running Plotly via a Google Colab , we will first need to use the following command: ! pip install - q jupyter - dash Jupyter-dash allows the dashboard to be configured for modification via a Python Notebook . This way, the dashboard is updated in real-time with the modification of any cells. Without using the jupyter-dash package, every change made to the dashboard would have to be followed by a recompilation of the app (quite tedious) . Now, we can import our Python libraries with the following line: import dash from jupyter_dash import JupyterDash import dash_html_components as html The library dash_html_components allows for access to Plotly Dash\u2019s HTML components, allowing us to display HTML elements such as text and linebreaks. We'll cover more of these in the ensuing sections! At this point, the pirates pause. \u201cWe only know these packages for now. Pilaging doesn\u2019t leave much time to learn further. At Port Plotly, ya\u2019ll find what you need from the locals. Theys\u2019 a lot more knowledgeable.\u201d explains the first. \u201cBut that\u2019s okay\u201d , finishes the second, \u201cthese two packages are quite powerful...\u201d Plotly Pirates' Notes 02","title":"Proper Prerequisites"},{"location":"learn/02_setup-sea/#functioning-first-app","text":"In order to create our first app, we can simply run the following lines: app = JupyterDash ( __name__ ) app . layout = html . Div ( children = [ html . P ( children = 'Hello Dash' ), ]) app . run_server ( mode = 'external' ) Running the following produces the following output: Dash App running on : http : // 127.0.0.1 : 8050 / Clicking on the link takes us to our first dashboard! Great! Albeit, quite simple \ud83d\ude05. Breaking it down, we can see that our first line initialized the dash app. Since we are running from the Google Colab Notebook, we will use the JupyterDash() constructor instead of the standard app=dash.Dash() constructor. Next, we define the app\u2019s layout. Using an HTML .Div() element, we can divide our content into different sections. It is simply a container used to hold other components and establish a structure in our dashboard. For example, our Div element currently contains one element, represented by the attribute children = [...] . Any components contained in the attribute \u201cchildren\u201d will belong to this html.Div() element. Each children component must be separated by a comma. We can try adding another html.P (a simple paragraph) to our app: app . layout = html . Div ( children = [ html . P ( children = 'Hello Dash' ), html . P ( \u2018 Guess who \u2019 s back ?\u2019 ), ]) Running this will produce the following output to the right: Ahh, you might have noticed that we\u2019ve omitted the children attribute in the second html.P() statement. This is because \u2018children\u2019 is optional and does not to be specified. For example, app . layout = html . Div ([ html . P ( 'Hello Dash' ), html . P ( \u2018 Guess who \u2019 s back ?\u2019 ), ]) Running this will produce the following output to the right: See, same result as above! NOTE: For more information on .Div(), make sure to check out the following resources: html.Div() The pirates grin upon seeing our wide-eyed surprise. \u201cNow, let\u2019s tie it together with those TigerGraph texts\u201d , they exclaim, pointing at our three manuscripts from the island. Plotly Pirates' Notes 03","title":"Functioning First App"},{"location":"learn/02_setup-sea/#using-layout-functions","text":"We can create a function to return information to be displayed in our app. This will help make our layout cleaner, more readable, and easier to scale . All content can simply be wrapped in an html.Div() element. To begin, we can add the following functions and change our layout: def setup_TG (): row = html . Div ([ html . P ( \"Connected to TigerGraph Solution Subdomain:\" , TG_SUBDOMAIN ) html . P ( \"Currently working on Graph title:\" , TG_GRAPHNAME ) ]) return row app . layout = html . Div ([ html . P ( \u201c Welcome to Dash \u201d ) setup_TG () ]) And voila, as seen, our app now looks like the following: These functions can come in quite handy when creating complicated layouts. The pirates turn and point. In the distance, the faint outline of a port can be seen. \u201cLand ho! Well lads, time to finish up with the last section for today\u2026 adding a little bit of flavor .\u201d Plotly Pirates' Notes 04","title":"Using Layout Functions"},{"location":"learn/02_setup-sea/#transforming-text","text":"Dash\u2019s text elements are quite powerful . Here are a few simple ways to spice it up! We can modify our simple app as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 TITLE_STYLE = { \"background-color\" : \"#abc7ed\" , \"margin-bottom\" : \"20px\" , \"padding\" : \"5px\" } def setup_TG (): row = html . Div ([ html . P ( html . B ( \"Connected to Solution: \" + TG_SUBDOMAIN ), style = { 'color' : 'green' }), html . P ( html . I ( \"Currently working on Graph title: \" + TG_GRAPHNAME ), style = { 'color' : 'blue' }) ]) return row app = JupyterDash ( __name__ ) app . layout = html . Div ([ html . Div ( html . H1 ( \"Welcome to Dash\" ), style = TITLE_STYLE ), # Adding style, header setup_TG () # Adding style, bold, italics ]) app . run_server ( mode = 'external' ) Here's the resulting output: Let's break it down, component by component!","title":"Transforming Text"},{"location":"learn/02_setup-sea/#html-headers","text":"One of the easiest ways to spice up one's dashboard is to vary the text styles . This can be done using simple HTML header elements (H1, H2, H3, H4, H5, H6) . A table showing each one's output can be found below. Header 1 Headers 4 - 6 Header 3 Header 4 Header 5 Header 6","title":"HTML Headers"},{"location":"learn/02_setup-sea/#style-dictionary","text":"One of the best ways to style a dashboard is to use a style dictionary . In these dictionaries, one can specify attributes such as background color, padding, margins, font style, font color, etc . In lines 1- 5, we explicitly create a style dictionary titled TITLE_STYLE . 1 2 3 4 5 TITLE_STYLE = { \"background-color\" : \"#abc7ed\" , \"margin-bottom\" : \"20px\" , \"padding\" : \"5px\" } This dictionary is then passed into the html.Div() element which contains our header. As a result, the header is given extra padding, margin, and a light-blue background . Pretty straightforward! This style dictionary doesn't have to be stored in a variable . In lines 9 and 10, we explicitly change the colors of each html.P() using the keyword style . 9 10 html . P ( html . B ( \"Connected to Solution: \" + TG_SUBDOMAIN ), style = { 'color' : 'green' }), html . P ( html . I ( \"Currently working on Graph title: \" + TG_GRAPHNAME ), style = { 'color' : 'blue' }) NOTE: Color can take both keywords (ex. common colors like red, orange) as well as hex values (ex. 'DD659F') This brings us to our next point, the html.B() and html.I() used in lines 9 and 10.","title":"Style Dictionary"},{"location":"learn/02_setup-sea/#htmlb-htmli","text":"In order to bold or italicize sections of text, we can simply use html.B() and html.I() These elements can stand on their own without being wrapped in html.P() elements. However, this removes the division between two lines . For example, the following two lines produce the following output: 9 10 html . B ( \"Connected to Solution: \" + TG_SUBDOMAIN , style = { 'color' : 'green' }), html . I ( \"Currently working on Graph title: \" + TG_GRAPHNAME , style = { 'color' : 'blue' }) NOTE: For more information on these two elements, feel free to check out the following: html.B() , html.I() There are so many more ways to transform text! We'll cover other methods in Chapter 05 - Sheriff Styles ! As we pull into Port, the pirates help us get out of their canoe. \u201cHere, you lads will learn more about Plotly. Pay careful attention and make sure to note everything down in there, \" advises the first, pointing to our laptop. The second tips his hat to us, \u201cFair winds to thee good friends! Cast off!\u201d And with that, the peculiar pirates had left. Turning around, a large sign greets us, \u201cWelcome to Port Plotly! A one-stop-shop for data analytics and visualization!\u201d All code segments from this chapter can be found in this Colab Notebook . Feel free to follow along! \u21a9 Everything we've installed so far (prerequistes for next section): ! pip install - q pyTigerGraph import pyTigerGraph as tg TG_SUBDOMAIN = 'healthcare-dash' TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio Link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph conn = tg . TigerGraphConnection ( host = TG_HOST , graphname = TG_GRAPHNAME , username = TG_USERNAME , password = TG_PASSWORD , beta = True ) conn . apiToken = conn . getToken ( conn . createSecret ()) ! pip install - q jupyter - dash import dash import dash_html_components as html from jupyter_dash import JupyterDash \u21a9","title":"Html.B(), Html.I()"},{"location":"learn/03_port-plotly/","text":"Presenting Port Plotly \ud83e\uddf1 \u00b6 Looking around, there are hundreds of stalls set up throughout the port, each with a different banner and symbol hung up next to them. A sign labelled Visitor's Guide catches our eyes. Approaching it, we find a small box of pamphlets attached onto the sign. As we begin to read, we pull out our laptop and once again begin to take note of the strange wisdom. \"Welcome! In order to fully experience Plotly , we need to go over a few things...\" Plotly Pointers 01 Plotly Express and Pandas \u00b6 Before beginning to graph with Plotly, we need to import Plotly Express! Plotly Express is a high-level wrapper that allows for the creation of simple visualizations with minimal lines of code. It has numerous features, yet is still intuitive and consistent in terms of the syntax used across multiple chart types. To import the library, we run the following line: import plotly.express as px Next, we need to import the Pandas library. Pandas allows for the creation of dataframes, structured storage systems that integrate easily with Plotly Express. These dataframes can be thought of as data tables or spreadsheets . To import the library, we run the following line: import pandas as pd And that's it! The last line of the Visitor's Guide reads, \"Learn more by visiting the stalls at our marketplace!\" With no other leads, we set off for the marketplace. First shop, \"Buster's Bar Charts\" . Plotly Pointers 02 Bar Charts \u00b6 There are a few options to create a bar chart! Loading Data \u00b6 With DataFrame When creating a bar chart, we can use a Pandas Dataframe : raw_data = { 'Animals' : [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ], 'Counts' : [ 2 , 4 , 8 , 4 , 2 ] } df = pd . DataFrame . from_dict ( raw_data ) bar = px . bar ( raw_data , x = 'Animals' , y = 'Counts' ) bar . show () As seen, we pass in the dataframe and specify the x and y column titles . Without DataFrame Here, we can simply pass in two arrays, one for each of x and y. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ] counts = [ 2 , 4 , 8 , 4 , 2 ] bar = px . bar ( x = animals , y = counts ) bar . show () Even if we don't create a dataframe, Plotly will perform this action under-the-hood when generating the bar chart. In both cases, we get the same result. And voila, here are our two bar charts! Ahh, you may have noticed a small difference: the axis labels! When we passed in two arrays, we never specified what the axes were to be titled . How do we fix this and further style our charts? To that, we turn to Plotly's myriad ways of customizing charts . Styling Figure \u00b6 There are many ways to style a bar chart. Here are some of the most important ones! Adding a Title, Axis Labels We can add a title with the following function, bar.update_layout() : animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ] counts = [ 2 , 4 , 8 , 2 , 4 ] bar = px . bar ( x = animals , y = counts ) bar . update_layout ( title = \"Animals vs. Appendages\" , # Adding a title xaxis_title = \"The Amazing Animals\" , # Changing x-axis label yaxis_title = \"How many appendages?\" , # Changing y-axis label font = dict ( family = \"Courier New, monospace\" , # The font style color = \"RebeccaPurple\" , # The font color size = 18 # The font size ) ) bar . show () Adding Color In order to individually select colors for our bar chart, we can use the following: animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ] counts = [ 2 , 4 , 8 , 2 , 4 ] # As seen, each bar segment that hasn't had a discrete color entered will be shown in black bar = px . bar ( x = animals , y = counts , color_discrete_sequence = [[ '#65ff31' , '#4a4aff' , '#aa00aa' ]]) bar . show () We can also use the following argument to make each column visually represent its value . raw_data = { 'Animals' : [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ], 'Counts' : [ 2 , 4 , 8 , 2 , 4 ] } df = pd . DataFrame . from_dict ( raw_data ) # Creates a side color chart --> each color represents count bar = px . bar ( df , x = 'Animals' , y = 'Counts' , color = 'Counts' ) bar . show () As seen, it's just a matter of adding the \"color\" argument! Changing Orientation In order to make the bar chart horizontal, we can simply add the orientation='h' argument. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ] counts = [ 2 , 4 , 8 , 2 , 4 ] # Notice that we've had to switch the axes! bar = px . bar ( x = counts , y = animals , orientation = 'h' ) bar . show () NOTE: As mentioned in the above comments, we've had to switch the axes in this horizontal layout! Width and Height These can be easily changed via the width and height keywords. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ] counts = [ 2 , 4 , 8 , 2 , 4 ] bar = px . bar ( x = animals , y = counts , width = 800 , height = 400 ) bar . show () All Put Together Using these elements, we can create the following bar chart: raw_data = { 'Animals' : [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ], 'Counts' : [ 2 , 4 , 8 , 2 , 4 ] } df = pd . DataFrame . from_dict ( raw_data ) bar = px . bar ( df , x = 'Counts' , y = 'Animals' , orientation = 'h' , color = 'Counts' , width = 800 , height = 400 ) bar . update_layout ( title = \"Animals vs. Appendages\" , # Adding a title yaxis_title = \"The Amazing Animals\" , # Changing x-axis label xaxis_title = \"How many appendages?\" , # Changing y-axis label font = dict ( family = \"Courier New, monospace\" , # The font style color = \"RebeccaPurple\" , # The font color size = 18 # The font size ) ) bar . show () NOTE: For more information, make sure to check out the following: Plotly Bar Charts , px.Bar() The shopowner exclaims, \"There's your intro to bar charts! Next, I'd recommend checking out Lenny's Line Charts . He's a cousin of mine and our work is quite similar... \" Walking over, we pull out our laptop and continue our notes... Plotly Pointers 03 Line Charts \u00b6 There are a few options to create a line chart! Loading Data \u00b6 Once again, we can either use a Pandas Dataframe or just proceed with arrays! With DataFrame raw_data = { 'Year' : [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ], 'Carbon per Capita' : [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] } df = pd . DataFrame . from_dict ( raw_data ) line = px . line ( df , x = 'Year' , y = 'Carbon per Capita' ) line . show () As seen, we pass in the dataframe and specify the x and y column titles . Without DataFrame Here, we can simply pass in two arrays, one for each of x and y. year = [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ] carbon = [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] line = px . line ( x = year , y = carbon ) line . show () Even if we don't create a dataframe, Plotly will perform this action under-the-hood when generating the line chart. In both cases, we get the same result. And voila, here are our two line charts! Styling Figure \u00b6 The methods to style a line chart are very similar to styling a bar chart! However, one neat feature we haven't covered yet is traces. These are quite effective at visualizing multiple sets of data on the same set of axes. Let's take a closer look! Multiple Traces In order to add multiple traces, we turn to the Plotly Graph Objects library. To import this library, we use the following line: import plotly.graph_objects as go Next, we can create our traces with the .add_trace() function. year = [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ] carbon_USA = [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] carbon_AUS = [ 15.0 , 15.3 , 15.5 , 15.6 , 17.2 , 18.2 , 18.2 , 17.7 , 17.5 , 17.1 , 16.1 , 15.4 , 16.9 , 16.8 ] line = go . Figure () line . add_trace ( go . Scatter ( x = year , y = carbon_USA )) line . add_trace ( go . Scatter ( x = year , y = carbon_AUS )) line . show () Each trace adds a new line (the name go.Scatter() is a bit misleading!) Styling Traces In order to style these traces and change their legend names from 't', we can add the following: year = [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ] carbon_USA = [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] carbon_AUS = [ 15.0 , 15.3 , 15.5 , 15.6 , 17.2 , 18.2 , 18.2 , 17.7 , 17.5 , 17.1 , 16.1 , 15.4 , 16.9 , 16.8 ] line = go . Figure () line . add_trace ( go . Scatter ( x = year , y = carbon_USA , marker = dict ( color = 'MediumPurple' ), name = \"USA Carbon Emissions (per capita)\" )) line . add_trace ( go . Scatter ( x = year , y = carbon_AUS , marker = dict ( color = 'LightSeaGreen' ), name = \"AUS Carbon Emissions (per capita)\" )) line . show () Adding the marker=dict(color='MediumPurple') dictionary allows us to change the color of the two traces. Additionally, the name argument lets us distinguish and label the two traces. Here's the result! We can further style these traces by exploring the marker dictionary: year = [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ] carbon_USA = [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] carbon_AUS = [ 15.0 , 15.3 , 15.5 , 15.6 , 17.2 , 18.2 , 18.2 , 17.7 , 17.5 , 17.1 , 16.1 , 15.4 , 16.9 , 16.8 ] line = go . Figure () line . add_trace ( go . Scatter ( x = year , y = carbon_USA , marker = dict ( size = 25 , color = 'MediumPurple' ), name = \"USA Carbon Emissions (per capita)\" )) line . add_trace ( go . Scatter ( x = year , y = carbon_AUS , marker = dict ( size = 25 , color = 'LightSeaGreen' , symbol = 'square' ), name = \"AUS Carbon Emissions (per capita)\" )) line . show () As seen below, the size and symbols for each trace can be customized as well! All Put Together Using these elements and our stylings from the previous section, we can create the following: year = [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ] carbon_USA = [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] carbon_AUS = [ 15.0 , 15.3 , 15.5 , 15.6 , 17.2 , 18.2 , 18.2 , 17.7 , 17.5 , 17.1 , 16.1 , 15.4 , 16.9 , 16.8 ] line = go . Figure () line . add_trace ( go . Scatter ( x = year , y = carbon_USA , marker = dict ( size = 25 , color = 'MediumPurple' ), name = \"USA Carbon Emissions (per capita)\" )) line . add_trace ( go . Scatter ( x = year , y = carbon_AUS , marker = dict ( size = 25 , color = 'LightSeaGreen' , symbol = 'square' ), name = \"AUS Carbon Emissions (per capita)\" )) line . update_layout ( title = \"Carbon Emissions since 1980 (per capita)\" , xaxis_title = \"Year\" , yaxis_title = \"Annual Emissions in Tons (per capita)\" , plot_bgcolor = 'DarkGrey' , width = 1600 ) line . show () NOTE: For more information, make sure to check out the following: Plotly Line Charts , px.line() Line charts, check \u2705. A delicious aroma catches our scent, drawing us away from the stall and towards a round-shaped bakery. The shopowner smiles and beckons, \"Welcome to Pep\u00e9's Pie Charts!\" Laptop opened, we begin to listen... Plotly Pointers 04 Pie Charts \u00b6 There are a few options to create a pie chart! Loading Data \u00b6 When creating a bar chart, we can use a Pandas Dataframe : raw_data = { 'Animals' : [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ], 'Counts' : [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] } df = pd . DataFrame . from_dict ( raw_data ) pie = px . pie ( raw_data , values = 'Counts' , names = 'Animals' ) pie . show () As seen, we pass in the dataframe and specify the x and y column titles . Without DataFrame Here, we can simply pass in two arrays, one for each of x and y. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals ) pie . show () Even if we don't create a dataframe, Plotly will perform this action under-the-hood when generating the pie chart. In both cases, we get the same result. And voila, here are our two bar charts! Unlike with bar charts and line charts, there are truly no differences between each! This is mainly because there are no axes which need labelling \ud83d\ude05. Styling Figure \u00b6 There are many ways to style a bar chart. Here are some of the most important ones! Adding Title, Labels In order to add a title, we can simply pass in the title argument. To change the percentages in each slice into labels, we can use the .update_traces() method. The width of the plot is simply changed via the .update_layouts() method, as done previously. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals , title = \"The Animals of Old McDonald's Farm\" , ) pie . update_traces ( textposition = 'inside' , textinfo = 'label' ) pie . update_layout ( width = 1000 ) pie . show () The title can be centered with the title_x argument, which ranges from 0 to 1. Therefore, setting its value to 0.5 will result in a centered title. Additionally, the .update_traces() method can be modified to include percentages. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals , title = \"The Animals of Old McDonald's Farm\" , ) pie . update_traces ( textposition = 'inside' , textinfo = 'label+percent' ) pie . update_layout ( width = 1000 ) pie . update_layout ( title_x = 0.5 ) pie . show () And here's our centered title (relative to the pie chart). Donuts, Slices \u00b6 Some neat extensions of pie charts includes donuts and slices! In order to create a donut chart, we simply need to add the hole=0.2 argument. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals , title = \"The Animals of Old McDonald's Farm\" , hole = 0.2 , ) pie . update_traces ( textposition = 'inside' , textinfo = 'label+percent' ) pie . update_layout ( width = 1000 ) pie . update_layout ( title_x = 0.5 ) pie . show () In order to highlight specific slices or data values, we can use the pull argument. Here's an example highlighting the Pig slice! animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals , title = \"The Animals of Old McDonald's Farm\" , hole = 0.2 , ) pie . update_traces ( textposition = 'inside' , textinfo = 'label+percent' , pull = [ 0 , 0 , 0 , 0 , 0 , 0 , 0.1 ], ) pie . update_layout ( width = 1000 ) pie . update_layout ( title_x = 0.5 ) pie . show () The length of pull matches the length of animals . Similarly, each value corresponds to a specific animal, in matching result. For example, the last element of pull is 0.1, meaning that the last element of animals , 'Pig', will be pulled out by a factor of 0.1. Let's try applying this knowledge to pull out 'Chicken' and 'Buffalo' as well! animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals , title = \"The Animals of Old McDonald's Farm\" , hole = 0.2 , ) pie . update_traces ( textposition = 'inside' , textinfo = 'label+percent' , opacity = 0.9 , pull = [ 0.2 , 0.3 , 0 , 0 , 0 , 0 , 0.1 ], ) pie . update_layout ( width = 1000 ) pie . update_layout ( title_x = 0.5 ) pie . show () Neat! And with that, we have a rather fancy pie chart put together in less than a dozen lines of code! NOTE: For more information, make sure to check out the following: Plotly Pie Charts , px.Pie() The shopowner looks at our laptop and points at our line charts from before, \"Ahh! I see you've visited Lenny's Lines. Make sure to check out Sylvie's Scatter Plots. It's right next door! That'll come in handy with data points that don't necessarily need to form a line!\" Walking over, we're greeted by a beaming clerk with the initials \"S.S.\". \"Howdy y'all! I presume you're here to learn about the stunning power of scatter plots...\" Plotly Pointers 05 Scatter Plots \u00b6 As with most other plots, there are a few options to create a scatter plot! Loading Data \u00b6 Here, we'll explore a less-common method with several Star Wars Lego Sets. Each Lego Set is stored as an array of three values: price, piece count, and VIP points. These arrays are added to a list of all eight sets. Using two iterators, we can create a list of prices and pieces (ordered correctly). rep_gunship = [ 349.99 , 3292 , 2275 ]; light_cruiser = [ 159.99 , 1336 , 1040 ] bad_batch_shuttle = [ 99.99 , 969 , 650 ]; meditation_chamber = [ 69.99 , 663 , 455 ] imperial_maurader = [ 39.99 , 478 , 260 ]; mandalorian_forge = [ 29.99 , 258 , 195 ] a_wing = [ 199.99 , 1672 , 1300 ]; razor_crest = [ 129.99 , 1023 , 845 ] sets = [ rep_gunship , light_cruiser , bad_batch_shuttle , meditation_chamber , imperial_maurader , mandalorian_forge , a_wing , razor_crest ] price = [ sets [ i ][ 0 ] for i in range ( len ( sets ))] pieces = [ sets [ i ][ 1 ] for i in range ( len ( sets ))] scatter = px . scatter ( x = price , y = pieces ) scatter . show () Looking good, but let's add some style! Styling Figure \u00b6 Size Attribute One neat way to flavor our scatter plots is to modify the size attribute. Here, we can set the size of each datapoint to match a third attribute. In this case, the third dimension of data will be the number of VIP points earned per set. # Lego Sets from 2021 (Price, Pieces, VIP Points) rep_gunship = [ 349.99 , 3292 , 2275 ]; light_cruiser = [ 159.99 , 1336 , 1040 ] bad_batch_shuttle = [ 99.99 , 969 , 650 ]; meditation_chamber = [ 69.99 , 663 , 455 ] imperial_maurader = [ 39.99 , 478 , 260 ]; mandalorian_forge = [ 29.99 , 258 , 195 ] a_wing = [ 199.99 , 1672 , 1300 ]; razor_crest = [ 129.99 , 1023 , 845 ] sets = [ rep_gunship , light_cruiser , bad_batch_shuttle , meditation_chamber , imperial_maurader , mandalorian_forge , a_wing , razor_crest ] price = [ sets [ i ][ 0 ] for i in range ( len ( sets ))] pieces = [ sets [ i ][ 1 ] for i in range ( len ( sets ))] points = [ sets [ i ][ 2 ] for i in range ( len ( sets ))] scatter = px . scatter ( x = price , y = pieces , size = points ) scatter . show () And ta-da, we can easily visualize that larger sets give the most points! Adding Color As well as representing VIP points by size, we can also represent this data with color. We simply need to add the color argument inside of our px.scatter() function. # Lego Sets from 2021 (Price, Pieces, VIP Points) rep_gunship = [ 349.99 , 3292 , 2275 ]; light_cruiser = [ 159.99 , 1336 , 1040 ] bad_batch_shuttle = [ 99.99 , 969 , 650 ]; meditation_chamber = [ 69.99 , 663 , 455 ] imperial_maurader = [ 39.99 , 478 , 260 ]; mandalorian_forge = [ 29.99 , 258 , 195 ] a_wing = [ 199.99 , 1672 , 1300 ]; razor_crest = [ 129.99 , 1023 , 845 ] sets = [ rep_gunship , light_cruiser , bad_batch_shuttle , meditation_chamber , imperial_maurader , mandalorian_forge , a_wing , razor_crest ] price = [ sets [ i ][ 0 ] for i in range ( len ( sets ))] pieces = [ sets [ i ][ 1 ] for i in range ( len ( sets ))] points = [ sets [ i ][ 2 ] for i in range ( len ( sets ))] scatter = px . scatter ( x = price , y = pieces , size = points , color = points ) scatter . update_coloraxes ( colorbar_title = \"VIP Points\" ) scatter . update_layout ( width = 1000 ) # For better view! scatter . show () Adding Trendline Finally, one useful feature of px.Scatter() is the ability to add trendlines! All it takes is a simple trendline=\"ols\" , where \"ols\" stands for Ordinary Least Squares regression. # Lego Sets from 2021 (Price, Pieces, VIP Points) rep_gunship = [ 349.99 , 3292 , 2275 ]; light_cruiser = [ 159.99 , 1336 , 1040 ] bad_batch_shuttle = [ 99.99 , 969 , 650 ]; meditation_chamber = [ 69.99 , 663 , 455 ] imperial_maurader = [ 39.99 , 478 , 260 ]; mandalorian_forge = [ 29.99 , 258 , 195 ] a_wing = [ 199.99 , 1672 , 1300 ]; razor_crest = [ 129.99 , 1023 , 845 ] sets = [ rep_gunship , light_cruiser , bad_batch_shuttle , meditation_chamber , imperial_maurader , mandalorian_forge , a_wing , razor_crest ] price = [ sets [ i ][ 0 ] for i in range ( len ( sets ))] pieces = [ sets [ i ][ 1 ] for i in range ( len ( sets ))] points = [ sets [ i ][ 2 ] for i in range ( len ( sets ))] scatter = px . scatter ( x = price , y = pieces , size = points , color = points , trendline = \"ols\" ) scatter . update_coloraxes ( colorbar_title = \"VIP Points\" ) scatter . update_layout ( width = 1000 ) # For better view! scatter . show () NOTE: Non-linear regression lines can be added as well! For more information, check out: Plotly Trendlines All Put Together Using these elements and our stylings from the previous section, we can create the following: # Lego Sets from 2021 (Price, Pieces, VIP Points) rep_gunship = [ 349.99 , 3292 , 2275 ]; light_cruiser = [ 159.99 , 1336 , 1040 ] bad_batch_shuttle = [ 99.99 , 969 , 650 ]; meditation_chamber = [ 69.99 , 663 , 455 ] imperial_maurader = [ 39.99 , 478 , 260 ]; mandalorian_forge = [ 29.99 , 258 , 195 ] a_wing = [ 199.99 , 1672 , 1300 ]; razor_crest = [ 129.99 , 1023 , 845 ] sets = [ rep_gunship , light_cruiser , bad_batch_shuttle , meditation_chamber , imperial_maurader , mandalorian_forge , a_wing , razor_crest ] price = [ sets [ i ][ 0 ] for i in range ( len ( sets ))] pieces = [ sets [ i ][ 1 ] for i in range ( len ( sets ))] points = [ sets [ i ][ 2 ] for i in range ( len ( sets ))] scatter = px . scatter ( x = price , y = pieces , size = points , color = points , trendline = \"ols\" ) scatter . update_coloraxes ( colorbar_title = \"VIP Points\" ) scatter . update_layout ( title = \"Lego Star Wars Sets (2021)\" , xaxis_title = \"Price (USD)\" , yaxis_title = \"Total Piece Count\" , width = 1000 ) scatter . show () NOTE: For more information, make sure to check out the following: Plotly Scatter px.Scatter() Sylvie turns to us and points at our laptop, \"Y'all have these fancy figures, but they're not part of your dashboard yet! Learning how to add them in is an ancient knowledge you won't be able to find 'round here. Travel past this Port towards Dash's Delta. There, y'all will find the next pieces of your quest.\" We smile and wave goodbye, heading out past Port Plotly and down along the coast. All code segments from this chapter can be found in this Colab Notebook . Feel free to follow along! \u21a9 Everything we've installed so far (prerequistes for next section): ! pip install - q pyTigerGraph import pyTigerGraph as tg TG_SUBDOMAIN = 'healthcare-dash' TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio Link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph conn = tg . TigerGraphConnection ( host = TG_HOST , graphname = TG_GRAPHNAME , username = TG_USERNAME , password = TG_PASSWORD , beta = True ) conn . apiToken = conn . getToken ( conn . createSecret ()) ! pip install - q jupyter - dash import dash import dash_html_components as html from jupyter_dash import JupyterDash import plotly.express as px import pandas as pd import plotly.graph_objects as go \u21a9","title":"Ch 03 - Presenting Port Plotly"},{"location":"learn/03_port-plotly/#presenting-port-plotly","text":"Looking around, there are hundreds of stalls set up throughout the port, each with a different banner and symbol hung up next to them. A sign labelled Visitor's Guide catches our eyes. Approaching it, we find a small box of pamphlets attached onto the sign. As we begin to read, we pull out our laptop and once again begin to take note of the strange wisdom. \"Welcome! In order to fully experience Plotly , we need to go over a few things...\" Plotly Pointers 01","title":"Presenting Port Plotly \ud83e\uddf1"},{"location":"learn/03_port-plotly/#plotly-express-and-pandas","text":"Before beginning to graph with Plotly, we need to import Plotly Express! Plotly Express is a high-level wrapper that allows for the creation of simple visualizations with minimal lines of code. It has numerous features, yet is still intuitive and consistent in terms of the syntax used across multiple chart types. To import the library, we run the following line: import plotly.express as px Next, we need to import the Pandas library. Pandas allows for the creation of dataframes, structured storage systems that integrate easily with Plotly Express. These dataframes can be thought of as data tables or spreadsheets . To import the library, we run the following line: import pandas as pd And that's it! The last line of the Visitor's Guide reads, \"Learn more by visiting the stalls at our marketplace!\" With no other leads, we set off for the marketplace. First shop, \"Buster's Bar Charts\" . Plotly Pointers 02","title":"Plotly Express and Pandas"},{"location":"learn/03_port-plotly/#bar-charts","text":"There are a few options to create a bar chart!","title":"Bar Charts"},{"location":"learn/03_port-plotly/#loading-data","text":"With DataFrame When creating a bar chart, we can use a Pandas Dataframe : raw_data = { 'Animals' : [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ], 'Counts' : [ 2 , 4 , 8 , 4 , 2 ] } df = pd . DataFrame . from_dict ( raw_data ) bar = px . bar ( raw_data , x = 'Animals' , y = 'Counts' ) bar . show () As seen, we pass in the dataframe and specify the x and y column titles . Without DataFrame Here, we can simply pass in two arrays, one for each of x and y. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ] counts = [ 2 , 4 , 8 , 4 , 2 ] bar = px . bar ( x = animals , y = counts ) bar . show () Even if we don't create a dataframe, Plotly will perform this action under-the-hood when generating the bar chart. In both cases, we get the same result. And voila, here are our two bar charts! Ahh, you may have noticed a small difference: the axis labels! When we passed in two arrays, we never specified what the axes were to be titled . How do we fix this and further style our charts? To that, we turn to Plotly's myriad ways of customizing charts .","title":"Loading Data"},{"location":"learn/03_port-plotly/#styling-figure","text":"There are many ways to style a bar chart. Here are some of the most important ones! Adding a Title, Axis Labels We can add a title with the following function, bar.update_layout() : animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ] counts = [ 2 , 4 , 8 , 2 , 4 ] bar = px . bar ( x = animals , y = counts ) bar . update_layout ( title = \"Animals vs. Appendages\" , # Adding a title xaxis_title = \"The Amazing Animals\" , # Changing x-axis label yaxis_title = \"How many appendages?\" , # Changing y-axis label font = dict ( family = \"Courier New, monospace\" , # The font style color = \"RebeccaPurple\" , # The font color size = 18 # The font size ) ) bar . show () Adding Color In order to individually select colors for our bar chart, we can use the following: animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ] counts = [ 2 , 4 , 8 , 2 , 4 ] # As seen, each bar segment that hasn't had a discrete color entered will be shown in black bar = px . bar ( x = animals , y = counts , color_discrete_sequence = [[ '#65ff31' , '#4a4aff' , '#aa00aa' ]]) bar . show () We can also use the following argument to make each column visually represent its value . raw_data = { 'Animals' : [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ], 'Counts' : [ 2 , 4 , 8 , 2 , 4 ] } df = pd . DataFrame . from_dict ( raw_data ) # Creates a side color chart --> each color represents count bar = px . bar ( df , x = 'Animals' , y = 'Counts' , color = 'Counts' ) bar . show () As seen, it's just a matter of adding the \"color\" argument! Changing Orientation In order to make the bar chart horizontal, we can simply add the orientation='h' argument. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ] counts = [ 2 , 4 , 8 , 2 , 4 ] # Notice that we've had to switch the axes! bar = px . bar ( x = counts , y = animals , orientation = 'h' ) bar . show () NOTE: As mentioned in the above comments, we've had to switch the axes in this horizontal layout! Width and Height These can be easily changed via the width and height keywords. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ] counts = [ 2 , 4 , 8 , 2 , 4 ] bar = px . bar ( x = animals , y = counts , width = 800 , height = 400 ) bar . show () All Put Together Using these elements, we can create the following bar chart: raw_data = { 'Animals' : [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ], 'Counts' : [ 2 , 4 , 8 , 2 , 4 ] } df = pd . DataFrame . from_dict ( raw_data ) bar = px . bar ( df , x = 'Counts' , y = 'Animals' , orientation = 'h' , color = 'Counts' , width = 800 , height = 400 ) bar . update_layout ( title = \"Animals vs. Appendages\" , # Adding a title yaxis_title = \"The Amazing Animals\" , # Changing x-axis label xaxis_title = \"How many appendages?\" , # Changing y-axis label font = dict ( family = \"Courier New, monospace\" , # The font style color = \"RebeccaPurple\" , # The font color size = 18 # The font size ) ) bar . show () NOTE: For more information, make sure to check out the following: Plotly Bar Charts , px.Bar() The shopowner exclaims, \"There's your intro to bar charts! Next, I'd recommend checking out Lenny's Line Charts . He's a cousin of mine and our work is quite similar... \" Walking over, we pull out our laptop and continue our notes... Plotly Pointers 03","title":"Styling Figure"},{"location":"learn/03_port-plotly/#line-charts","text":"There are a few options to create a line chart!","title":"Line Charts"},{"location":"learn/03_port-plotly/#loading-data_1","text":"Once again, we can either use a Pandas Dataframe or just proceed with arrays! With DataFrame raw_data = { 'Year' : [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ], 'Carbon per Capita' : [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] } df = pd . DataFrame . from_dict ( raw_data ) line = px . line ( df , x = 'Year' , y = 'Carbon per Capita' ) line . show () As seen, we pass in the dataframe and specify the x and y column titles . Without DataFrame Here, we can simply pass in two arrays, one for each of x and y. year = [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ] carbon = [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] line = px . line ( x = year , y = carbon ) line . show () Even if we don't create a dataframe, Plotly will perform this action under-the-hood when generating the line chart. In both cases, we get the same result. And voila, here are our two line charts!","title":"Loading Data"},{"location":"learn/03_port-plotly/#styling-figure_1","text":"The methods to style a line chart are very similar to styling a bar chart! However, one neat feature we haven't covered yet is traces. These are quite effective at visualizing multiple sets of data on the same set of axes. Let's take a closer look! Multiple Traces In order to add multiple traces, we turn to the Plotly Graph Objects library. To import this library, we use the following line: import plotly.graph_objects as go Next, we can create our traces with the .add_trace() function. year = [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ] carbon_USA = [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] carbon_AUS = [ 15.0 , 15.3 , 15.5 , 15.6 , 17.2 , 18.2 , 18.2 , 17.7 , 17.5 , 17.1 , 16.1 , 15.4 , 16.9 , 16.8 ] line = go . Figure () line . add_trace ( go . Scatter ( x = year , y = carbon_USA )) line . add_trace ( go . Scatter ( x = year , y = carbon_AUS )) line . show () Each trace adds a new line (the name go.Scatter() is a bit misleading!) Styling Traces In order to style these traces and change their legend names from 't', we can add the following: year = [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ] carbon_USA = [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] carbon_AUS = [ 15.0 , 15.3 , 15.5 , 15.6 , 17.2 , 18.2 , 18.2 , 17.7 , 17.5 , 17.1 , 16.1 , 15.4 , 16.9 , 16.8 ] line = go . Figure () line . add_trace ( go . Scatter ( x = year , y = carbon_USA , marker = dict ( color = 'MediumPurple' ), name = \"USA Carbon Emissions (per capita)\" )) line . add_trace ( go . Scatter ( x = year , y = carbon_AUS , marker = dict ( color = 'LightSeaGreen' ), name = \"AUS Carbon Emissions (per capita)\" )) line . show () Adding the marker=dict(color='MediumPurple') dictionary allows us to change the color of the two traces. Additionally, the name argument lets us distinguish and label the two traces. Here's the result! We can further style these traces by exploring the marker dictionary: year = [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ] carbon_USA = [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] carbon_AUS = [ 15.0 , 15.3 , 15.5 , 15.6 , 17.2 , 18.2 , 18.2 , 17.7 , 17.5 , 17.1 , 16.1 , 15.4 , 16.9 , 16.8 ] line = go . Figure () line . add_trace ( go . Scatter ( x = year , y = carbon_USA , marker = dict ( size = 25 , color = 'MediumPurple' ), name = \"USA Carbon Emissions (per capita)\" )) line . add_trace ( go . Scatter ( x = year , y = carbon_AUS , marker = dict ( size = 25 , color = 'LightSeaGreen' , symbol = 'square' ), name = \"AUS Carbon Emissions (per capita)\" )) line . show () As seen below, the size and symbols for each trace can be customized as well! All Put Together Using these elements and our stylings from the previous section, we can create the following: year = [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ] carbon_USA = [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] carbon_AUS = [ 15.0 , 15.3 , 15.5 , 15.6 , 17.2 , 18.2 , 18.2 , 17.7 , 17.5 , 17.1 , 16.1 , 15.4 , 16.9 , 16.8 ] line = go . Figure () line . add_trace ( go . Scatter ( x = year , y = carbon_USA , marker = dict ( size = 25 , color = 'MediumPurple' ), name = \"USA Carbon Emissions (per capita)\" )) line . add_trace ( go . Scatter ( x = year , y = carbon_AUS , marker = dict ( size = 25 , color = 'LightSeaGreen' , symbol = 'square' ), name = \"AUS Carbon Emissions (per capita)\" )) line . update_layout ( title = \"Carbon Emissions since 1980 (per capita)\" , xaxis_title = \"Year\" , yaxis_title = \"Annual Emissions in Tons (per capita)\" , plot_bgcolor = 'DarkGrey' , width = 1600 ) line . show () NOTE: For more information, make sure to check out the following: Plotly Line Charts , px.line() Line charts, check \u2705. A delicious aroma catches our scent, drawing us away from the stall and towards a round-shaped bakery. The shopowner smiles and beckons, \"Welcome to Pep\u00e9's Pie Charts!\" Laptop opened, we begin to listen... Plotly Pointers 04","title":"Styling Figure"},{"location":"learn/03_port-plotly/#pie-charts","text":"There are a few options to create a pie chart!","title":"Pie Charts"},{"location":"learn/03_port-plotly/#loading-data_2","text":"When creating a bar chart, we can use a Pandas Dataframe : raw_data = { 'Animals' : [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ], 'Counts' : [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] } df = pd . DataFrame . from_dict ( raw_data ) pie = px . pie ( raw_data , values = 'Counts' , names = 'Animals' ) pie . show () As seen, we pass in the dataframe and specify the x and y column titles . Without DataFrame Here, we can simply pass in two arrays, one for each of x and y. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals ) pie . show () Even if we don't create a dataframe, Plotly will perform this action under-the-hood when generating the pie chart. In both cases, we get the same result. And voila, here are our two bar charts! Unlike with bar charts and line charts, there are truly no differences between each! This is mainly because there are no axes which need labelling \ud83d\ude05.","title":"Loading Data"},{"location":"learn/03_port-plotly/#styling-figure_2","text":"There are many ways to style a bar chart. Here are some of the most important ones! Adding Title, Labels In order to add a title, we can simply pass in the title argument. To change the percentages in each slice into labels, we can use the .update_traces() method. The width of the plot is simply changed via the .update_layouts() method, as done previously. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals , title = \"The Animals of Old McDonald's Farm\" , ) pie . update_traces ( textposition = 'inside' , textinfo = 'label' ) pie . update_layout ( width = 1000 ) pie . show () The title can be centered with the title_x argument, which ranges from 0 to 1. Therefore, setting its value to 0.5 will result in a centered title. Additionally, the .update_traces() method can be modified to include percentages. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals , title = \"The Animals of Old McDonald's Farm\" , ) pie . update_traces ( textposition = 'inside' , textinfo = 'label+percent' ) pie . update_layout ( width = 1000 ) pie . update_layout ( title_x = 0.5 ) pie . show () And here's our centered title (relative to the pie chart).","title":"Styling Figure"},{"location":"learn/03_port-plotly/#donuts-slices","text":"Some neat extensions of pie charts includes donuts and slices! In order to create a donut chart, we simply need to add the hole=0.2 argument. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals , title = \"The Animals of Old McDonald's Farm\" , hole = 0.2 , ) pie . update_traces ( textposition = 'inside' , textinfo = 'label+percent' ) pie . update_layout ( width = 1000 ) pie . update_layout ( title_x = 0.5 ) pie . show () In order to highlight specific slices or data values, we can use the pull argument. Here's an example highlighting the Pig slice! animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals , title = \"The Animals of Old McDonald's Farm\" , hole = 0.2 , ) pie . update_traces ( textposition = 'inside' , textinfo = 'label+percent' , pull = [ 0 , 0 , 0 , 0 , 0 , 0 , 0.1 ], ) pie . update_layout ( width = 1000 ) pie . update_layout ( title_x = 0.5 ) pie . show () The length of pull matches the length of animals . Similarly, each value corresponds to a specific animal, in matching result. For example, the last element of pull is 0.1, meaning that the last element of animals , 'Pig', will be pulled out by a factor of 0.1. Let's try applying this knowledge to pull out 'Chicken' and 'Buffalo' as well! animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals , title = \"The Animals of Old McDonald's Farm\" , hole = 0.2 , ) pie . update_traces ( textposition = 'inside' , textinfo = 'label+percent' , opacity = 0.9 , pull = [ 0.2 , 0.3 , 0 , 0 , 0 , 0 , 0.1 ], ) pie . update_layout ( width = 1000 ) pie . update_layout ( title_x = 0.5 ) pie . show () Neat! And with that, we have a rather fancy pie chart put together in less than a dozen lines of code! NOTE: For more information, make sure to check out the following: Plotly Pie Charts , px.Pie() The shopowner looks at our laptop and points at our line charts from before, \"Ahh! I see you've visited Lenny's Lines. Make sure to check out Sylvie's Scatter Plots. It's right next door! That'll come in handy with data points that don't necessarily need to form a line!\" Walking over, we're greeted by a beaming clerk with the initials \"S.S.\". \"Howdy y'all! I presume you're here to learn about the stunning power of scatter plots...\" Plotly Pointers 05","title":"Donuts, Slices"},{"location":"learn/03_port-plotly/#scatter-plots","text":"As with most other plots, there are a few options to create a scatter plot!","title":"Scatter Plots"},{"location":"learn/03_port-plotly/#loading-data_3","text":"Here, we'll explore a less-common method with several Star Wars Lego Sets. Each Lego Set is stored as an array of three values: price, piece count, and VIP points. These arrays are added to a list of all eight sets. Using two iterators, we can create a list of prices and pieces (ordered correctly). rep_gunship = [ 349.99 , 3292 , 2275 ]; light_cruiser = [ 159.99 , 1336 , 1040 ] bad_batch_shuttle = [ 99.99 , 969 , 650 ]; meditation_chamber = [ 69.99 , 663 , 455 ] imperial_maurader = [ 39.99 , 478 , 260 ]; mandalorian_forge = [ 29.99 , 258 , 195 ] a_wing = [ 199.99 , 1672 , 1300 ]; razor_crest = [ 129.99 , 1023 , 845 ] sets = [ rep_gunship , light_cruiser , bad_batch_shuttle , meditation_chamber , imperial_maurader , mandalorian_forge , a_wing , razor_crest ] price = [ sets [ i ][ 0 ] for i in range ( len ( sets ))] pieces = [ sets [ i ][ 1 ] for i in range ( len ( sets ))] scatter = px . scatter ( x = price , y = pieces ) scatter . show () Looking good, but let's add some style!","title":"Loading Data"},{"location":"learn/03_port-plotly/#styling-figure_3","text":"Size Attribute One neat way to flavor our scatter plots is to modify the size attribute. Here, we can set the size of each datapoint to match a third attribute. In this case, the third dimension of data will be the number of VIP points earned per set. # Lego Sets from 2021 (Price, Pieces, VIP Points) rep_gunship = [ 349.99 , 3292 , 2275 ]; light_cruiser = [ 159.99 , 1336 , 1040 ] bad_batch_shuttle = [ 99.99 , 969 , 650 ]; meditation_chamber = [ 69.99 , 663 , 455 ] imperial_maurader = [ 39.99 , 478 , 260 ]; mandalorian_forge = [ 29.99 , 258 , 195 ] a_wing = [ 199.99 , 1672 , 1300 ]; razor_crest = [ 129.99 , 1023 , 845 ] sets = [ rep_gunship , light_cruiser , bad_batch_shuttle , meditation_chamber , imperial_maurader , mandalorian_forge , a_wing , razor_crest ] price = [ sets [ i ][ 0 ] for i in range ( len ( sets ))] pieces = [ sets [ i ][ 1 ] for i in range ( len ( sets ))] points = [ sets [ i ][ 2 ] for i in range ( len ( sets ))] scatter = px . scatter ( x = price , y = pieces , size = points ) scatter . show () And ta-da, we can easily visualize that larger sets give the most points! Adding Color As well as representing VIP points by size, we can also represent this data with color. We simply need to add the color argument inside of our px.scatter() function. # Lego Sets from 2021 (Price, Pieces, VIP Points) rep_gunship = [ 349.99 , 3292 , 2275 ]; light_cruiser = [ 159.99 , 1336 , 1040 ] bad_batch_shuttle = [ 99.99 , 969 , 650 ]; meditation_chamber = [ 69.99 , 663 , 455 ] imperial_maurader = [ 39.99 , 478 , 260 ]; mandalorian_forge = [ 29.99 , 258 , 195 ] a_wing = [ 199.99 , 1672 , 1300 ]; razor_crest = [ 129.99 , 1023 , 845 ] sets = [ rep_gunship , light_cruiser , bad_batch_shuttle , meditation_chamber , imperial_maurader , mandalorian_forge , a_wing , razor_crest ] price = [ sets [ i ][ 0 ] for i in range ( len ( sets ))] pieces = [ sets [ i ][ 1 ] for i in range ( len ( sets ))] points = [ sets [ i ][ 2 ] for i in range ( len ( sets ))] scatter = px . scatter ( x = price , y = pieces , size = points , color = points ) scatter . update_coloraxes ( colorbar_title = \"VIP Points\" ) scatter . update_layout ( width = 1000 ) # For better view! scatter . show () Adding Trendline Finally, one useful feature of px.Scatter() is the ability to add trendlines! All it takes is a simple trendline=\"ols\" , where \"ols\" stands for Ordinary Least Squares regression. # Lego Sets from 2021 (Price, Pieces, VIP Points) rep_gunship = [ 349.99 , 3292 , 2275 ]; light_cruiser = [ 159.99 , 1336 , 1040 ] bad_batch_shuttle = [ 99.99 , 969 , 650 ]; meditation_chamber = [ 69.99 , 663 , 455 ] imperial_maurader = [ 39.99 , 478 , 260 ]; mandalorian_forge = [ 29.99 , 258 , 195 ] a_wing = [ 199.99 , 1672 , 1300 ]; razor_crest = [ 129.99 , 1023 , 845 ] sets = [ rep_gunship , light_cruiser , bad_batch_shuttle , meditation_chamber , imperial_maurader , mandalorian_forge , a_wing , razor_crest ] price = [ sets [ i ][ 0 ] for i in range ( len ( sets ))] pieces = [ sets [ i ][ 1 ] for i in range ( len ( sets ))] points = [ sets [ i ][ 2 ] for i in range ( len ( sets ))] scatter = px . scatter ( x = price , y = pieces , size = points , color = points , trendline = \"ols\" ) scatter . update_coloraxes ( colorbar_title = \"VIP Points\" ) scatter . update_layout ( width = 1000 ) # For better view! scatter . show () NOTE: Non-linear regression lines can be added as well! For more information, check out: Plotly Trendlines All Put Together Using these elements and our stylings from the previous section, we can create the following: # Lego Sets from 2021 (Price, Pieces, VIP Points) rep_gunship = [ 349.99 , 3292 , 2275 ]; light_cruiser = [ 159.99 , 1336 , 1040 ] bad_batch_shuttle = [ 99.99 , 969 , 650 ]; meditation_chamber = [ 69.99 , 663 , 455 ] imperial_maurader = [ 39.99 , 478 , 260 ]; mandalorian_forge = [ 29.99 , 258 , 195 ] a_wing = [ 199.99 , 1672 , 1300 ]; razor_crest = [ 129.99 , 1023 , 845 ] sets = [ rep_gunship , light_cruiser , bad_batch_shuttle , meditation_chamber , imperial_maurader , mandalorian_forge , a_wing , razor_crest ] price = [ sets [ i ][ 0 ] for i in range ( len ( sets ))] pieces = [ sets [ i ][ 1 ] for i in range ( len ( sets ))] points = [ sets [ i ][ 2 ] for i in range ( len ( sets ))] scatter = px . scatter ( x = price , y = pieces , size = points , color = points , trendline = \"ols\" ) scatter . update_coloraxes ( colorbar_title = \"VIP Points\" ) scatter . update_layout ( title = \"Lego Star Wars Sets (2021)\" , xaxis_title = \"Price (USD)\" , yaxis_title = \"Total Piece Count\" , width = 1000 ) scatter . show () NOTE: For more information, make sure to check out the following: Plotly Scatter px.Scatter() Sylvie turns to us and points at our laptop, \"Y'all have these fancy figures, but they're not part of your dashboard yet! Learning how to add them in is an ancient knowledge you won't be able to find 'round here. Travel past this Port towards Dash's Delta. There, y'all will find the next pieces of your quest.\" We smile and wave goodbye, heading out past Port Plotly and down along the coast. All code segments from this chapter can be found in this Colab Notebook . Feel free to follow along! \u21a9 Everything we've installed so far (prerequistes for next section): ! pip install - q pyTigerGraph import pyTigerGraph as tg TG_SUBDOMAIN = 'healthcare-dash' TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio Link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph conn = tg . TigerGraphConnection ( host = TG_HOST , graphname = TG_GRAPHNAME , username = TG_USERNAME , password = TG_PASSWORD , beta = True ) conn . apiToken = conn . getToken ( conn . createSecret ()) ! pip install - q jupyter - dash import dash import dash_html_components as html from jupyter_dash import JupyterDash import plotly.express as px import pandas as pd import plotly.graph_objects as go \u21a9","title":"Styling Figure"},{"location":"learn/04_dash-delta/","text":"Dash\u2019s Delta \ud83c\udf3f \u00b6 As we follow the meandering coastline, we catch sight of the mouth of the rivers heading inland. A small wooden sign sits next to the wetlands: \u201cWelcome to Dash\u2019s Delta. EST 2013.\u2019 Next to it, several large, strangely-shaped rocks have been arranged in a circular fashion. Taking a closer look, there are several paragraphs etched into each stone. Curious, we begin to read\u2026 The power of Dash flows through these rivers. Engraved into these stones lie the key to unlocking their secrets... Dash's Delta Notes 01 Dash's Libraries \u00b6 To begin harnessing the power of Dash, we must import the necessary libraries Dash Core \u00b6 Dash's core components are a library of higher-level elements such as tables, graphs, dropdowns, inputs, and links . To use these components, we add the following line: import dash_core_components as dcc NOTE: For a full list of components, feel free to check out the following: Dash Core Documentation Bootstrap \u00b6 Dash allows for the inclusion of native Boostrap components via its Dash Boostrap library. These elements include cards, lists, badges, and more . To use these elements, we install and import the library via the following lines: ! pip install dash - bootstrap - components import dash_bootstrap_components as dbc NOTE: For a full list of components, feel free to check out the following: Dash Boostrap Documentation And voila, we're good to go! We turn to the next stone and continue to read... Dash's Delta Notes 02 Dash Graph \u00b6 The figures made from Plotly are dazzling, but still need to be added into the dashboard! In order to add these charts, we can utilize the dcc.Graph() element. First, we create a function: def getAnimalChart (): raw_data = { 'Animals' : [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ], 'Counts' : [ 2 , 4 , 8 , 2 , 4 ] } df = pd . DataFrame . from_dict ( raw_data ) bar = px . bar ( df , x = 'Counts' , y = 'Animals' , orientation = 'h' , color = 'Counts' , width = 800 , height = 400 ) bar . update_layout ( title = \"Animals vs. Appendages\" , # Adding a title yaxis_title = \"The Amazing Animals\" , # Changing x-axis label xaxis_title = \"How many appendages?\" , # Changing y-axis label font = dict ( family = \"Courier New, monospace\" , # The font style color = \"RebeccaPurple\" , # The font color size = 18 # The font size ) ) return bar This function simply returns our finalized bar chart from the last chapter instead of displaying it. Now, we can add a dcc.Graph() component in our app via the following lines. And here's the result! app = JupyterDash ( __name__ ) app . layout = html . Div ( children = [ html . P ( children = \"Welcome to Dash\" ), dcc . Graph ( id = 'Animal Chart' , figure = getAnimalChart ()) ]) app . run_server ( mode = 'external' ) NOTE: The id attribute is optional, but it's a good practice to include a unique ID for each component. This is especially true for updating figures, which will be covered in a later chapter, \"Confronted by Callbacks\" Pretty straightforward! Now, we can add our Plotly figures to our dashboard \ud83d\ude04 . Continuing down the circle, we find the next stone, \"Dash Cards\"... Dash's Delta Notes 03 Dash Cards \u00b6 These graphs we have created are amazing! But not the prettiest... With cards, any component (especially text, images, and figures) can neatly be displayed within a bounded area. These cards can be customized in terms of style, size, color, outline, and more! Basic Elements \u00b6 To get started, we'll create a simple card around our graph from earlier. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ html . P ( children = \"Welcome to Dash\" ), dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Animal Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Animal Chart' , figure = getAnimalChart ()) ]) ], style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" } ) ]) app . run_server ( mode = 'external' ) Alright, let's break it down! At the very top, we must add the Bootstrap external stylesheet in order to utilize the Card component. This stylesheet comes installed with the library and is accessed with external_stylesheets=[dbc.themes.BOOTSTRAP] NOTE: We can add our own custom external stylesheets! We'll dive into this in \"Sheriff Styles\" With our dbc.Card() , we have a Card Body. this dbc.CardBody() contains a header, paragraph, and our graph. You may notice the className attribute. This is a custom CSS styling that was imported from the Bootstrap stylesheet. After this, the dbc.Card() itself contains a style dictionary. In here, we find two attributes: Width - this is simply the width of the card. rem is simply the percentage dimension of the screen. As a result, 55rem means that the card will span 55% of the screen's width. Margin - in particular, the left-most margin has been set to 1% of the screen's width. margin-bottom , margin-top , and margin-right are all valid keywords that can be utilized as well to further adjust our card. And voila, here's our result: Let's try changing some of the colors! Colors, Outlines \u00b6 In order to modify the visual appearance of our cards, we can use the color and outline attributes. color allows for several pre-built options: primary , secondary , info , success , warning , danger , light , and dark . For example, here's what info looks like (a light blue): app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ html . P ( children = \"Welcome to Dash\" ), dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Animal Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Animal Chart' , figure = getAnimalChart ()) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" } ) ]) app . run_server ( mode = 'external' ) We can also create a card to hold our title (looks kind of strange by itself in the top corner \ud83d\ude05) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Welcome to Dash!\" , className = 'card-title' ), ]) ], color = 'dark' , # Options include: primary, secondary, info, success, warning, danger, light, dark inverse = True , style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-top\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ), dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Animal Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Animal Chart' , figure = getAnimalChart ()) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" } ) ]) app . run_server ( mode = 'external' ) There we go, much better now! Ahh, you may have noticed the inverse argument! Setting this to True is helpful when dealing with dark backgrounds as it inverts all text color to white. As a result, we don't have to manually change the title color. NOTE: For more information on dbc.Card(), feel free to check out the following: dbc.Card() Now, what if we want to add multiple cards, but not just continue to vertically stack them? For that, we must turn to rows and columns! The stone adjacent to this one is titled \"Dash Layout\"... Dash's Delta Notes 04 Dash Layout \u00b6 The best way to arrange components in our dashboard is via dbc.Row() and dbc.Col() . Let's take a closer look at their power! Creating Cards \u00b6 Before beginning, let's create a few cards for better readability: titleCard titleCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Welcome to Dash!\" , className = 'card-title' ), ]) ], color = 'dark' , # Options include: primary, secondary, info, success, warning, danger, light, dark inverse = True , style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-top\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) animalBarCard def getAnimalBarChart (): raw_data = { 'Animals' : [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ], 'Counts' : [ 2 , 4 , 8 , 2 , 4 ] } df = pd . DataFrame . from_dict ( raw_data ) bar = px . bar ( df , x = 'Counts' , y = 'Animals' , orientation = 'h' , color = 'Counts' , width = 800 , height = 400 ) bar . update_layout ( title = \"Animals vs. Appendages\" , # Adding a title yaxis_title = \"The Amazing Animals\" , # Changing x-axis label xaxis_title = \"How many appendages?\" , # Changing y-axis label font = dict ( family = \"Courier New, monospace\" , # The font style color = \"RebeccaPurple\" , # The font color size = 18 # The font size ) ) return bar animalBarCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Animal Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Animal Chart' , figure = getAnimalBarChart ()) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) carbonLineCard def getCarbonLineChart (): year = [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ] carbon_USA = [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] carbon_AUS = [ 15.0 , 15.3 , 15.5 , 15.6 , 17.2 , 18.2 , 18.2 , 17.7 , 17.5 , 17.1 , 16.1 , 15.4 , 16.9 , 16.8 ] line = go . Figure () line . add_trace ( go . Scatter ( x = year , y = carbon_USA , marker = dict ( size = 25 , color = 'MediumPurple' ), name = \"USA Carbon Emissions (per capita)\" )) line . add_trace ( go . Scatter ( x = year , y = carbon_AUS , marker = dict ( size = 25 , color = 'LightSeaGreen' , symbol = 'square' ), name = \"AUS Carbon Emissions (per capita)\" )) line . update_layout ( title = \"Carbon Emissions since 1980 (per capita)\" , xaxis_title = \"Year\" , yaxis_title = \"Annual Emissions in Tons (per capita)\" , plot_bgcolor = 'DarkGrey' , width = 1600 ) return line carbonLineCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Carbon Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Carbon Chart' , figure = getCarbonLineChart ()) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) animalPieCard def getAnimalPieChart (): animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals , title = \"The Animals of Old McDonald's Farm\" , hole = 0.2 , ) pie . update_traces ( textposition = 'inside' , textinfo = 'label+percent' , opacity = 0.9 , pull = [ 0.2 , 0.3 , 0 , 0 , 0 , 0 , 0.1 ], ) pie . update_layout ( width = 1000 ) pie . update_layout ( title_x = 0.5 ) return pie animalPieCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Animal Pie Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Animal Pie Chart' , figure = getAnimalPieChart ()) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) legoScatterCard def getLegoScatterChart (): rep_gunship = [ 349.99 , 3292 , 2275 ]; light_cruiser = [ 159.99 , 1336 , 1040 ] bad_batch_shuttle = [ 99.99 , 969 , 650 ]; meditation_chamber = [ 69.99 , 663 , 455 ] imperial_maurader = [ 39.99 , 478 , 260 ]; mandalorian_forge = [ 29.99 , 258 , 195 ] a_wing = [ 199.99 , 1672 , 1300 ]; razor_crest = [ 129.99 , 1023 , 845 ] sets = [ rep_gunship , light_cruiser , bad_batch_shuttle , meditation_chamber , imperial_maurader , mandalorian_forge , a_wing , razor_crest ] price = [ sets [ i ][ 0 ] for i in range ( len ( sets ))] pieces = [ sets [ i ][ 1 ] for i in range ( len ( sets ))] points = [ sets [ i ][ 2 ] for i in range ( len ( sets ))] scatter = px . scatter ( x = price , y = pieces , size = points , color = points , trendline = \"ols\" ) scatter . update_coloraxes ( colorbar_title = \"VIP Points\" ) scatter . update_layout ( title = \"Lego Star Wars Sets (2021)\" , xaxis_title = \"Price (USD)\" , yaxis_title = \"Total Piece Count\" , width = 1000 ) return scatter legoScatterCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Lego Scatter Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Lego Chart' , figure = getLegoScatterChart ()) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) There we go! Now we have five variables we can use: titleCard , animalBarCard , carbonLineCard , animalPieCard , legoScatterCard . Let's see what we can do using them! dbc.Row() \u00b6 The function dbc.Row() allows for the creation of rows, enabling horizontal arrangement of elements. For example, we can create two rows: one to hold our title, another to hold two charts. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Row ([ titleCard , ], style = { \"margin-left\" : \"0.5rem\" } ), dbc . Row ([ animalBarCard , carbonLineCard ], style = { \"margin-left\" : \"0.5rem\" } ) ]) app . run_server ( mode = 'external' ) Woah, that looks pretty good! In order to adjust the elements of rows, we can use the justify argument. Possible options include: start , center , end , between , and around . For example, here we'll use center for the title card and around for the body cards. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Row ([ titleCard , ], justify = \"center\" , style = { \"margin-left\" : \"0.5rem\" } ), dbc . Row ([ animalBarCard , carbonLineCard ], justify = \"around\" , style = { \"margin-left\" : \"0.5rem\" , \"margin-right\" : \"0.5rem\" } ) ]) app . run_server ( mode = 'external' ) Alright! That looks pretty good so far! Now, let's take a look at adding columns... dbc.Col() \u00b6 Let's say we want to add our Pie chart underneath our \"Carbon Chart\". In order to do this, we can simply use dbc.Col . To begin, we wrap our \"Carbon Chart\" in a column and include our Pie chart as part of that column: app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Row ([ titleCard , ], justify = \"center\" , style = { \"margin-left\" : \"0.5rem\" } ), dbc . Row ([ animalBarCard , dbc . Col ([ carbonLineCard , animalPieCard ]) ], justify = \"around\" , style = { \"margin-left\" : \"0.5rem\" , \"margin-right\" : \"0.5rem\" } ) ]) app . run_server ( mode = 'external' ) As seen, the row automatically expands in length in order to accommodate for the column's vertical height. In order to adjust the column's width, we can use the width argument. This is a value that ranges between 0 and 12 . As a result, width=4 would lead to a column approximately \u2153 of the width of its parent element. However, we will deal with this keyword and implement it into our dashboard in future chapters! For now, we can create another column to store our Lego Scatter Plot. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Row ([ titleCard , ], justify = \"center\" , style = { \"margin-left\" : \"0.5rem\" } ), dbc . Row ([ dbc . Col ([ animalBarCard , legoScatterCard , ]), dbc . Col ([ carbonLineCard , animalPieCard ]) ], justify = \"around\" , style = { \"margin-left\" : \"0.5rem\" , \"margin-right\" : \"0.5rem\" } ) ]) app . run_server ( mode = 'external' ) Our dashboard already looks quite stunning. All this, in just four quick chapters \ud83e\udd29\ud83d\ude04. Next up, a little more tidying... NOTE: For more information on rows and columns, feel free to check out: dbc.Layout() As if on cue, we hear a voice, \"Howdy' there, you fellas lost?\u201d Quickly turning around, we see the strangest individual: a horse in a star-studded hat... All code segments from this chapter can be found in this Colab Notebook . Feel free to follow along! \u21a9 Everything we've installed so far (prerequistes for next section): ! pip install - q pyTigerGraph import pyTigerGraph as tg TG_SUBDOMAIN = 'healthcare-dash' TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio Link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph conn = tg . TigerGraphConnection ( host = TG_HOST , graphname = TG_GRAPHNAME , username = TG_USERNAME , password = TG_PASSWORD , beta = True ) conn . apiToken = conn . getToken ( conn . createSecret ()) ! pip install - q jupyter - dash import dash import dash_html_components as html from jupyter_dash import JupyterDash import plotly.express as px import pandas as pd import plotly.graph_objects as go import dash_core_components as dcc ! pip install dash - bootstrap - components import dash_bootstrap_components as dbc \u21a9","title":"Ch 04 - Dash's Delta"},{"location":"learn/04_dash-delta/#dashs-delta","text":"As we follow the meandering coastline, we catch sight of the mouth of the rivers heading inland. A small wooden sign sits next to the wetlands: \u201cWelcome to Dash\u2019s Delta. EST 2013.\u2019 Next to it, several large, strangely-shaped rocks have been arranged in a circular fashion. Taking a closer look, there are several paragraphs etched into each stone. Curious, we begin to read\u2026 The power of Dash flows through these rivers. Engraved into these stones lie the key to unlocking their secrets... Dash's Delta Notes 01","title":"Dash\u2019s Delta \ud83c\udf3f"},{"location":"learn/04_dash-delta/#dashs-libraries","text":"To begin harnessing the power of Dash, we must import the necessary libraries","title":"Dash's Libraries"},{"location":"learn/04_dash-delta/#dash-core","text":"Dash's core components are a library of higher-level elements such as tables, graphs, dropdowns, inputs, and links . To use these components, we add the following line: import dash_core_components as dcc NOTE: For a full list of components, feel free to check out the following: Dash Core Documentation","title":"Dash Core"},{"location":"learn/04_dash-delta/#bootstrap","text":"Dash allows for the inclusion of native Boostrap components via its Dash Boostrap library. These elements include cards, lists, badges, and more . To use these elements, we install and import the library via the following lines: ! pip install dash - bootstrap - components import dash_bootstrap_components as dbc NOTE: For a full list of components, feel free to check out the following: Dash Boostrap Documentation And voila, we're good to go! We turn to the next stone and continue to read... Dash's Delta Notes 02","title":"Bootstrap"},{"location":"learn/04_dash-delta/#dash-graph","text":"The figures made from Plotly are dazzling, but still need to be added into the dashboard! In order to add these charts, we can utilize the dcc.Graph() element. First, we create a function: def getAnimalChart (): raw_data = { 'Animals' : [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ], 'Counts' : [ 2 , 4 , 8 , 2 , 4 ] } df = pd . DataFrame . from_dict ( raw_data ) bar = px . bar ( df , x = 'Counts' , y = 'Animals' , orientation = 'h' , color = 'Counts' , width = 800 , height = 400 ) bar . update_layout ( title = \"Animals vs. Appendages\" , # Adding a title yaxis_title = \"The Amazing Animals\" , # Changing x-axis label xaxis_title = \"How many appendages?\" , # Changing y-axis label font = dict ( family = \"Courier New, monospace\" , # The font style color = \"RebeccaPurple\" , # The font color size = 18 # The font size ) ) return bar This function simply returns our finalized bar chart from the last chapter instead of displaying it. Now, we can add a dcc.Graph() component in our app via the following lines. And here's the result! app = JupyterDash ( __name__ ) app . layout = html . Div ( children = [ html . P ( children = \"Welcome to Dash\" ), dcc . Graph ( id = 'Animal Chart' , figure = getAnimalChart ()) ]) app . run_server ( mode = 'external' ) NOTE: The id attribute is optional, but it's a good practice to include a unique ID for each component. This is especially true for updating figures, which will be covered in a later chapter, \"Confronted by Callbacks\" Pretty straightforward! Now, we can add our Plotly figures to our dashboard \ud83d\ude04 . Continuing down the circle, we find the next stone, \"Dash Cards\"... Dash's Delta Notes 03","title":"Dash Graph"},{"location":"learn/04_dash-delta/#dash-cards","text":"These graphs we have created are amazing! But not the prettiest... With cards, any component (especially text, images, and figures) can neatly be displayed within a bounded area. These cards can be customized in terms of style, size, color, outline, and more!","title":"Dash Cards"},{"location":"learn/04_dash-delta/#basic-elements","text":"To get started, we'll create a simple card around our graph from earlier. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ html . P ( children = \"Welcome to Dash\" ), dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Animal Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Animal Chart' , figure = getAnimalChart ()) ]) ], style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" } ) ]) app . run_server ( mode = 'external' ) Alright, let's break it down! At the very top, we must add the Bootstrap external stylesheet in order to utilize the Card component. This stylesheet comes installed with the library and is accessed with external_stylesheets=[dbc.themes.BOOTSTRAP] NOTE: We can add our own custom external stylesheets! We'll dive into this in \"Sheriff Styles\" With our dbc.Card() , we have a Card Body. this dbc.CardBody() contains a header, paragraph, and our graph. You may notice the className attribute. This is a custom CSS styling that was imported from the Bootstrap stylesheet. After this, the dbc.Card() itself contains a style dictionary. In here, we find two attributes: Width - this is simply the width of the card. rem is simply the percentage dimension of the screen. As a result, 55rem means that the card will span 55% of the screen's width. Margin - in particular, the left-most margin has been set to 1% of the screen's width. margin-bottom , margin-top , and margin-right are all valid keywords that can be utilized as well to further adjust our card. And voila, here's our result: Let's try changing some of the colors!","title":"Basic Elements"},{"location":"learn/04_dash-delta/#colors-outlines","text":"In order to modify the visual appearance of our cards, we can use the color and outline attributes. color allows for several pre-built options: primary , secondary , info , success , warning , danger , light , and dark . For example, here's what info looks like (a light blue): app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ html . P ( children = \"Welcome to Dash\" ), dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Animal Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Animal Chart' , figure = getAnimalChart ()) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" } ) ]) app . run_server ( mode = 'external' ) We can also create a card to hold our title (looks kind of strange by itself in the top corner \ud83d\ude05) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Welcome to Dash!\" , className = 'card-title' ), ]) ], color = 'dark' , # Options include: primary, secondary, info, success, warning, danger, light, dark inverse = True , style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-top\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ), dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Animal Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Animal Chart' , figure = getAnimalChart ()) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" } ) ]) app . run_server ( mode = 'external' ) There we go, much better now! Ahh, you may have noticed the inverse argument! Setting this to True is helpful when dealing with dark backgrounds as it inverts all text color to white. As a result, we don't have to manually change the title color. NOTE: For more information on dbc.Card(), feel free to check out the following: dbc.Card() Now, what if we want to add multiple cards, but not just continue to vertically stack them? For that, we must turn to rows and columns! The stone adjacent to this one is titled \"Dash Layout\"... Dash's Delta Notes 04","title":"Colors, Outlines"},{"location":"learn/04_dash-delta/#dash-layout","text":"The best way to arrange components in our dashboard is via dbc.Row() and dbc.Col() . Let's take a closer look at their power!","title":"Dash Layout"},{"location":"learn/04_dash-delta/#creating-cards","text":"Before beginning, let's create a few cards for better readability: titleCard titleCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Welcome to Dash!\" , className = 'card-title' ), ]) ], color = 'dark' , # Options include: primary, secondary, info, success, warning, danger, light, dark inverse = True , style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-top\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) animalBarCard def getAnimalBarChart (): raw_data = { 'Animals' : [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ], 'Counts' : [ 2 , 4 , 8 , 2 , 4 ] } df = pd . DataFrame . from_dict ( raw_data ) bar = px . bar ( df , x = 'Counts' , y = 'Animals' , orientation = 'h' , color = 'Counts' , width = 800 , height = 400 ) bar . update_layout ( title = \"Animals vs. Appendages\" , # Adding a title yaxis_title = \"The Amazing Animals\" , # Changing x-axis label xaxis_title = \"How many appendages?\" , # Changing y-axis label font = dict ( family = \"Courier New, monospace\" , # The font style color = \"RebeccaPurple\" , # The font color size = 18 # The font size ) ) return bar animalBarCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Animal Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Animal Chart' , figure = getAnimalBarChart ()) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) carbonLineCard def getCarbonLineChart (): year = [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ] carbon_USA = [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] carbon_AUS = [ 15.0 , 15.3 , 15.5 , 15.6 , 17.2 , 18.2 , 18.2 , 17.7 , 17.5 , 17.1 , 16.1 , 15.4 , 16.9 , 16.8 ] line = go . Figure () line . add_trace ( go . Scatter ( x = year , y = carbon_USA , marker = dict ( size = 25 , color = 'MediumPurple' ), name = \"USA Carbon Emissions (per capita)\" )) line . add_trace ( go . Scatter ( x = year , y = carbon_AUS , marker = dict ( size = 25 , color = 'LightSeaGreen' , symbol = 'square' ), name = \"AUS Carbon Emissions (per capita)\" )) line . update_layout ( title = \"Carbon Emissions since 1980 (per capita)\" , xaxis_title = \"Year\" , yaxis_title = \"Annual Emissions in Tons (per capita)\" , plot_bgcolor = 'DarkGrey' , width = 1600 ) return line carbonLineCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Carbon Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Carbon Chart' , figure = getCarbonLineChart ()) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) animalPieCard def getAnimalPieChart (): animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals , title = \"The Animals of Old McDonald's Farm\" , hole = 0.2 , ) pie . update_traces ( textposition = 'inside' , textinfo = 'label+percent' , opacity = 0.9 , pull = [ 0.2 , 0.3 , 0 , 0 , 0 , 0 , 0.1 ], ) pie . update_layout ( width = 1000 ) pie . update_layout ( title_x = 0.5 ) return pie animalPieCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Animal Pie Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Animal Pie Chart' , figure = getAnimalPieChart ()) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) legoScatterCard def getLegoScatterChart (): rep_gunship = [ 349.99 , 3292 , 2275 ]; light_cruiser = [ 159.99 , 1336 , 1040 ] bad_batch_shuttle = [ 99.99 , 969 , 650 ]; meditation_chamber = [ 69.99 , 663 , 455 ] imperial_maurader = [ 39.99 , 478 , 260 ]; mandalorian_forge = [ 29.99 , 258 , 195 ] a_wing = [ 199.99 , 1672 , 1300 ]; razor_crest = [ 129.99 , 1023 , 845 ] sets = [ rep_gunship , light_cruiser , bad_batch_shuttle , meditation_chamber , imperial_maurader , mandalorian_forge , a_wing , razor_crest ] price = [ sets [ i ][ 0 ] for i in range ( len ( sets ))] pieces = [ sets [ i ][ 1 ] for i in range ( len ( sets ))] points = [ sets [ i ][ 2 ] for i in range ( len ( sets ))] scatter = px . scatter ( x = price , y = pieces , size = points , color = points , trendline = \"ols\" ) scatter . update_coloraxes ( colorbar_title = \"VIP Points\" ) scatter . update_layout ( title = \"Lego Star Wars Sets (2021)\" , xaxis_title = \"Price (USD)\" , yaxis_title = \"Total Piece Count\" , width = 1000 ) return scatter legoScatterCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Lego Scatter Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Lego Chart' , figure = getLegoScatterChart ()) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) There we go! Now we have five variables we can use: titleCard , animalBarCard , carbonLineCard , animalPieCard , legoScatterCard . Let's see what we can do using them!","title":"Creating Cards"},{"location":"learn/04_dash-delta/#dbcrow","text":"The function dbc.Row() allows for the creation of rows, enabling horizontal arrangement of elements. For example, we can create two rows: one to hold our title, another to hold two charts. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Row ([ titleCard , ], style = { \"margin-left\" : \"0.5rem\" } ), dbc . Row ([ animalBarCard , carbonLineCard ], style = { \"margin-left\" : \"0.5rem\" } ) ]) app . run_server ( mode = 'external' ) Woah, that looks pretty good! In order to adjust the elements of rows, we can use the justify argument. Possible options include: start , center , end , between , and around . For example, here we'll use center for the title card and around for the body cards. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Row ([ titleCard , ], justify = \"center\" , style = { \"margin-left\" : \"0.5rem\" } ), dbc . Row ([ animalBarCard , carbonLineCard ], justify = \"around\" , style = { \"margin-left\" : \"0.5rem\" , \"margin-right\" : \"0.5rem\" } ) ]) app . run_server ( mode = 'external' ) Alright! That looks pretty good so far! Now, let's take a look at adding columns...","title":"dbc.Row()"},{"location":"learn/04_dash-delta/#dbccol","text":"Let's say we want to add our Pie chart underneath our \"Carbon Chart\". In order to do this, we can simply use dbc.Col . To begin, we wrap our \"Carbon Chart\" in a column and include our Pie chart as part of that column: app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Row ([ titleCard , ], justify = \"center\" , style = { \"margin-left\" : \"0.5rem\" } ), dbc . Row ([ animalBarCard , dbc . Col ([ carbonLineCard , animalPieCard ]) ], justify = \"around\" , style = { \"margin-left\" : \"0.5rem\" , \"margin-right\" : \"0.5rem\" } ) ]) app . run_server ( mode = 'external' ) As seen, the row automatically expands in length in order to accommodate for the column's vertical height. In order to adjust the column's width, we can use the width argument. This is a value that ranges between 0 and 12 . As a result, width=4 would lead to a column approximately \u2153 of the width of its parent element. However, we will deal with this keyword and implement it into our dashboard in future chapters! For now, we can create another column to store our Lego Scatter Plot. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Row ([ titleCard , ], justify = \"center\" , style = { \"margin-left\" : \"0.5rem\" } ), dbc . Row ([ dbc . Col ([ animalBarCard , legoScatterCard , ]), dbc . Col ([ carbonLineCard , animalPieCard ]) ], justify = \"around\" , style = { \"margin-left\" : \"0.5rem\" , \"margin-right\" : \"0.5rem\" } ) ]) app . run_server ( mode = 'external' ) Our dashboard already looks quite stunning. All this, in just four quick chapters \ud83e\udd29\ud83d\ude04. Next up, a little more tidying... NOTE: For more information on rows and columns, feel free to check out: dbc.Layout() As if on cue, we hear a voice, \"Howdy' there, you fellas lost?\u201d Quickly turning around, we see the strangest individual: a horse in a star-studded hat... All code segments from this chapter can be found in this Colab Notebook . Feel free to follow along! \u21a9 Everything we've installed so far (prerequistes for next section): ! pip install - q pyTigerGraph import pyTigerGraph as tg TG_SUBDOMAIN = 'healthcare-dash' TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio Link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph conn = tg . TigerGraphConnection ( host = TG_HOST , graphname = TG_GRAPHNAME , username = TG_USERNAME , password = TG_PASSWORD , beta = True ) conn . apiToken = conn . getToken ( conn . createSecret ()) ! pip install - q jupyter - dash import dash import dash_html_components as html from jupyter_dash import JupyterDash import plotly.express as px import pandas as pd import plotly.graph_objects as go import dash_core_components as dcc ! pip install dash - bootstrap - components import dash_bootstrap_components as dbc \u21a9","title":"dbc.Col()"},{"location":"learn/05_sheriff-styles/","text":"Sheriff Styles \u2b50\ufe0f \u00b6 \"I\u2019m Sheriff Styles , in charge of all things related to design. Now see here, you fellers wouldn't happen to be on a quest to create the ultimate dashboard , now would yalls\u2019?\u201d We nod quietly as she beams at us and points to our laptop. \u201cWell then, show me whatcha got!\u201d As we show her our progress, from Installation Island to Dash\u2019s Delta, she smiles. \u201cNow, that\u2019s great y\u2019all. But where\u2019s the flavor? Where\u2019s the heart? Where\u2019s the style? \u201d She beckoned to a nearby treestump. \u201cNow take a seat and pay close attention to this advice...\u201d Sheriff Style's Notes 01 Badges \u00b6 Badges are an excellent way to better display important information, especially numbers . These elements can be accessed via the Dash Bootstrap components library and can easily be integrated into our dashboard. Basic Badge \u00b6 They can be used in conjunction with text, as shown below. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ html . H1 ([ \"Number of Animals: \" , dbc . Badge ( \"4\" , className = \"ml-1\" )]), html . H3 ([ \"Number of Countries: \" , dbc . Badge ( \"19\" , className = \"ml-1\" )]), html . H5 ([ \"Number of Lego Sets: \" , dbc . Badge ( \"None Yet!\" , className = \"ml-1\" )]) ]) app . run_server ( mode = 'external' ) As seen, they match the size of the preceding text automatically. Additionally, they can include both numbers and words. When used by themselves, they default to the normal text size of html.P() , as shown below: app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . Badge ( \"Number of Animals: 4\" , className = \"ml-1\" ) ]) app . run_server ( mode = 'external' ) Coloring \u00b6 These badges can be colored as well. They come in a total of eight different pre-built color options, outlined here: primary , secondary , success , warning , danger , info , light . In this example, they've all been wrapped into a row (placed side-by-side) so that the differences in colors can easily be visualized. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) colors = [ 'primary' , 'secondary' , 'success' , 'warning' , 'danger' , 'info' , 'light' ] app . layout = html . Div ( dbc . Row ( [ html . H1 ([ \"\" , dbc . Badge ( value , color = value , className = \"ml-1\" )]) for value in colors ] , style = { \"margin-left\" : \"1rem\" } ) ) app . run_server ( mode = 'external' ) By wrapping each in an empty html.H1() , the size of each badge can be easily increased (a nice little trick \ud83d\ude04). Pills, Links \u00b6 Badges can also be reshaped into pills (with ovalish corners) and have embedded links. The pills can be set simply via pill=True and the embedded link can be changed via the href argument. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( dbc . Row ([ html . H1 ([ \"\" , dbc . Badge ( \"Click Me!\" , color = 'info' , pill = True , href = \"https://google.com\" , className = \"ml-1\" )]) ], style = { \"margin-left\" : \"1rem\" } ) ) app . run_server ( mode = 'external' ) And those are the core functionalities of badges! As we'll see in the ensuing chapter (TigerGraph Tundra), they can come in quite handy when calling attention to text-based information... NOTE: For more information, feel free to check out the following resources: dbc.Badge() The Sheriff continues onwards... Sheriff Style's Notes 02 HTML Elements \u00b6 We can further modify the layout of our dashboard, especially text, by using Dash\u2019s HTML elements. Centering \u00b6 Going back to our title card from Dash's Delta , we can easily center text using html.Center() . titleCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Welcome to Dash!\" , className = 'card-title' ), ]) ], color = 'dark' , # Options include: primary, secondary, info, success, warning, danger, light, dark inverse = True , style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-top\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . Row ([ html . Center ( titleCard ), ], justify = \"center\" , style = { \"margin-left\" : \"0.5rem\" } ), ]) app . run_server ( mode = 'external' ) This can be used to center any component, beyond just text and cards! Horizontal Rule (Hr) \u00b6 The html.Hr() function creates a thin horizontal line that stretches across the page. This can be used to separate distinct sections from one another or for easy aesthetic design. For example, app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ html . Center ( titleCard ), html . Hr (), html . Center ( html . P ( \"Now, we can dive further into this topic...\" , style = { 'fontSize' : 20 })) ]) app . run_server ( mode = 'external' ) Line Break (Br) \u00b6 The html.Br() function creates a small line break that can be used to separate text, paragraphs, or components. The size of the line break can be seen below: app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ html . Center ( titleCard ), html . Hr (), html . Center ( html . P ( \"Now, we can dive further into this topic...\" , style = { 'fontSize' : 20 })), html . Br (), html . Center ( html . P ( \"Before we begin, we need to put on our thinking caps!\" , style = { 'fontSize' : 20 })) ]) app . run_server ( mode = 'external' ) And those are the core HTML components to help with style! \"Next up, an easier way to format text!\" exclaims the Sheriff. Sheriff Style's Notes 03 dcc.Markdown() \u00b6 Markdown allows for the insert of Markdown into Dash (pretty intuitive naming \ud83d\ude05). It's quite straightforward! app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . Col ( dcc . Markdown ( \"\"\" # This is a title! Hello There! This is in **bold** while this is in *italics* * Neat, it's a list :) * Woah, possible foreshadowing? Check out [Google](https://google.com) \"\"\" ) ) ]) app . run_server ( mode = 'external' ) In order to create a title, we can simply use the # . Bolded text is performed using the ** symbols, while italics are added via the * symbol. In order to create lists, we can use the * symbol (asterisk with a space). Links are as simple as adding the visible text in square brackets and placing the link itself in parenthesis. NOTE: For more information, feel free to check out the following resources: dcc.Markdown() \"The last thing we need to cover are lists!\" Sheriff Style's Notes 04 List Group \u00b6 Dash Bootstrap's List Groups allow for the creation of stylish lists with ease. These lists can be used to store information, serve as embedded links, and help users better navigate and understand the layout of one's dashboard. To create a basic list, we use the following: app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . ListGroup ([ dbc . ListGroupItem ( \"First is the worst!\" ), dbc . ListGroupItem ( \"Second is the best!\" ), dbc . ListGroupItem ( \"Third is the one with the Treasure Chest!\" ) ]), ]) app . run_server ( mode = 'external' ) The dbc.ListGroup() element simply holds different list group items. However, this list spans the entire width of the page (or its parent component) by default. In order to adjust its width, we can wrap the List Group within a dbc.Col() element from earlier. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . Col ( dbc . ListGroup ([ dbc . ListGroupItem ( \"First is the worst!\" ), dbc . ListGroupItem ( \"Second is the best!\" ), dbc . ListGroupItem ( \"Third is the one with the Treasure Chest!\" ) ]), width = 4 ) ]) app . run_server ( mode = 'external' ) There we go, much better! Now let's add some style... Coloring Cells \u00b6 In order to add color to each list item, we can simply use the color argument: app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . Col ( dbc . ListGroup ([ dbc . ListGroupItem ( \"First is the worst!\" , color = 'danger' ), dbc . ListGroupItem ( \"Second is the best!\" , color = \"success\" ), dbc . ListGroupItem ( \"Third is the one with the Treasure Chest!\" , color = \"info\" ) ]), width = 4 ) ]) app . run_server ( mode = 'external' ) As with other bootstrap components, the pre-built color options carry over in name and hue. Horizontal List \u00b6 Instead of keeping each list item stacked vertically, we can also arrange them horizontally. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . Col ( dbc . ListGroup ([ dbc . ListGroupItem ( \"First is the worst!\" , color = 'danger' ), dbc . ListGroupItem ( \"Second is the best!\" , color = \"success\" ), dbc . ListGroupItem ( \"Third is the one with the Treasure Chest!\" , color = \"info\" ) ], horizontal = True ), width = 6 ) ]) app . run_server ( mode = 'external' ) As seen, it's just a matter of adding the horizontal argument to our dbc.ListGroup() . NOTE: For more information, feel free to check out the following resources: dbc.ListGroup() \"And voila, now you have most of the core tools you need to begin styling,\" finishes the Sheriff. She smiles at us and points towards the horizon, \"As for where you're going to use these elements, you'll find your answer at the TigerGraph Tundra , the next step of your journey. Follow these rivers east, and they'll lead you to what you seek!\" All code segments from this chapter can be found in this Colab Notebook . Feel free to follow along! \u21a9 Everything we've installed so far (prerequistes for next section): ! pip install - q pyTigerGraph import pyTigerGraph as tg TG_SUBDOMAIN = 'healthcare-dash' TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio Link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph conn = tg . TigerGraphConnection ( host = TG_HOST , graphname = TG_GRAPHNAME , username = TG_USERNAME , password = TG_PASSWORD , beta = True ) conn . apiToken = conn . getToken ( conn . createSecret ()) ! pip install - q jupyter - dash import dash import dash_html_components as html from jupyter_dash import JupyterDash import plotly.express as px import pandas as pd import plotly.graph_objects as go import dash_core_components as dcc ! pip install dash - bootstrap - components import dash_bootstrap_components as dbc \u21a9","title":"Ch 05 - Sheriff Styles"},{"location":"learn/05_sheriff-styles/#sheriff-styles","text":"\"I\u2019m Sheriff Styles , in charge of all things related to design. Now see here, you fellers wouldn't happen to be on a quest to create the ultimate dashboard , now would yalls\u2019?\u201d We nod quietly as she beams at us and points to our laptop. \u201cWell then, show me whatcha got!\u201d As we show her our progress, from Installation Island to Dash\u2019s Delta, she smiles. \u201cNow, that\u2019s great y\u2019all. But where\u2019s the flavor? Where\u2019s the heart? Where\u2019s the style? \u201d She beckoned to a nearby treestump. \u201cNow take a seat and pay close attention to this advice...\u201d Sheriff Style's Notes 01","title":"Sheriff Styles \u2b50\ufe0f"},{"location":"learn/05_sheriff-styles/#badges","text":"Badges are an excellent way to better display important information, especially numbers . These elements can be accessed via the Dash Bootstrap components library and can easily be integrated into our dashboard.","title":"Badges"},{"location":"learn/05_sheriff-styles/#basic-badge","text":"They can be used in conjunction with text, as shown below. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ html . H1 ([ \"Number of Animals: \" , dbc . Badge ( \"4\" , className = \"ml-1\" )]), html . H3 ([ \"Number of Countries: \" , dbc . Badge ( \"19\" , className = \"ml-1\" )]), html . H5 ([ \"Number of Lego Sets: \" , dbc . Badge ( \"None Yet!\" , className = \"ml-1\" )]) ]) app . run_server ( mode = 'external' ) As seen, they match the size of the preceding text automatically. Additionally, they can include both numbers and words. When used by themselves, they default to the normal text size of html.P() , as shown below: app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . Badge ( \"Number of Animals: 4\" , className = \"ml-1\" ) ]) app . run_server ( mode = 'external' )","title":"Basic Badge"},{"location":"learn/05_sheriff-styles/#coloring","text":"These badges can be colored as well. They come in a total of eight different pre-built color options, outlined here: primary , secondary , success , warning , danger , info , light . In this example, they've all been wrapped into a row (placed side-by-side) so that the differences in colors can easily be visualized. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) colors = [ 'primary' , 'secondary' , 'success' , 'warning' , 'danger' , 'info' , 'light' ] app . layout = html . Div ( dbc . Row ( [ html . H1 ([ \"\" , dbc . Badge ( value , color = value , className = \"ml-1\" )]) for value in colors ] , style = { \"margin-left\" : \"1rem\" } ) ) app . run_server ( mode = 'external' ) By wrapping each in an empty html.H1() , the size of each badge can be easily increased (a nice little trick \ud83d\ude04).","title":"Coloring"},{"location":"learn/05_sheriff-styles/#pills-links","text":"Badges can also be reshaped into pills (with ovalish corners) and have embedded links. The pills can be set simply via pill=True and the embedded link can be changed via the href argument. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( dbc . Row ([ html . H1 ([ \"\" , dbc . Badge ( \"Click Me!\" , color = 'info' , pill = True , href = \"https://google.com\" , className = \"ml-1\" )]) ], style = { \"margin-left\" : \"1rem\" } ) ) app . run_server ( mode = 'external' ) And those are the core functionalities of badges! As we'll see in the ensuing chapter (TigerGraph Tundra), they can come in quite handy when calling attention to text-based information... NOTE: For more information, feel free to check out the following resources: dbc.Badge() The Sheriff continues onwards... Sheriff Style's Notes 02","title":"Pills, Links"},{"location":"learn/05_sheriff-styles/#html-elements","text":"We can further modify the layout of our dashboard, especially text, by using Dash\u2019s HTML elements.","title":"HTML Elements"},{"location":"learn/05_sheriff-styles/#centering","text":"Going back to our title card from Dash's Delta , we can easily center text using html.Center() . titleCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Welcome to Dash!\" , className = 'card-title' ), ]) ], color = 'dark' , # Options include: primary, secondary, info, success, warning, danger, light, dark inverse = True , style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-top\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . Row ([ html . Center ( titleCard ), ], justify = \"center\" , style = { \"margin-left\" : \"0.5rem\" } ), ]) app . run_server ( mode = 'external' ) This can be used to center any component, beyond just text and cards!","title":"Centering"},{"location":"learn/05_sheriff-styles/#horizontal-rule-hr","text":"The html.Hr() function creates a thin horizontal line that stretches across the page. This can be used to separate distinct sections from one another or for easy aesthetic design. For example, app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ html . Center ( titleCard ), html . Hr (), html . Center ( html . P ( \"Now, we can dive further into this topic...\" , style = { 'fontSize' : 20 })) ]) app . run_server ( mode = 'external' )","title":"Horizontal Rule (Hr)"},{"location":"learn/05_sheriff-styles/#line-break-br","text":"The html.Br() function creates a small line break that can be used to separate text, paragraphs, or components. The size of the line break can be seen below: app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ html . Center ( titleCard ), html . Hr (), html . Center ( html . P ( \"Now, we can dive further into this topic...\" , style = { 'fontSize' : 20 })), html . Br (), html . Center ( html . P ( \"Before we begin, we need to put on our thinking caps!\" , style = { 'fontSize' : 20 })) ]) app . run_server ( mode = 'external' ) And those are the core HTML components to help with style! \"Next up, an easier way to format text!\" exclaims the Sheriff. Sheriff Style's Notes 03","title":"Line Break (Br)"},{"location":"learn/05_sheriff-styles/#dccmarkdown","text":"Markdown allows for the insert of Markdown into Dash (pretty intuitive naming \ud83d\ude05). It's quite straightforward! app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . Col ( dcc . Markdown ( \"\"\" # This is a title! Hello There! This is in **bold** while this is in *italics* * Neat, it's a list :) * Woah, possible foreshadowing? Check out [Google](https://google.com) \"\"\" ) ) ]) app . run_server ( mode = 'external' ) In order to create a title, we can simply use the # . Bolded text is performed using the ** symbols, while italics are added via the * symbol. In order to create lists, we can use the * symbol (asterisk with a space). Links are as simple as adding the visible text in square brackets and placing the link itself in parenthesis. NOTE: For more information, feel free to check out the following resources: dcc.Markdown() \"The last thing we need to cover are lists!\" Sheriff Style's Notes 04","title":"dcc.Markdown()"},{"location":"learn/05_sheriff-styles/#list-group","text":"Dash Bootstrap's List Groups allow for the creation of stylish lists with ease. These lists can be used to store information, serve as embedded links, and help users better navigate and understand the layout of one's dashboard. To create a basic list, we use the following: app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . ListGroup ([ dbc . ListGroupItem ( \"First is the worst!\" ), dbc . ListGroupItem ( \"Second is the best!\" ), dbc . ListGroupItem ( \"Third is the one with the Treasure Chest!\" ) ]), ]) app . run_server ( mode = 'external' ) The dbc.ListGroup() element simply holds different list group items. However, this list spans the entire width of the page (or its parent component) by default. In order to adjust its width, we can wrap the List Group within a dbc.Col() element from earlier. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . Col ( dbc . ListGroup ([ dbc . ListGroupItem ( \"First is the worst!\" ), dbc . ListGroupItem ( \"Second is the best!\" ), dbc . ListGroupItem ( \"Third is the one with the Treasure Chest!\" ) ]), width = 4 ) ]) app . run_server ( mode = 'external' ) There we go, much better! Now let's add some style...","title":"List Group"},{"location":"learn/05_sheriff-styles/#coloring-cells","text":"In order to add color to each list item, we can simply use the color argument: app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . Col ( dbc . ListGroup ([ dbc . ListGroupItem ( \"First is the worst!\" , color = 'danger' ), dbc . ListGroupItem ( \"Second is the best!\" , color = \"success\" ), dbc . ListGroupItem ( \"Third is the one with the Treasure Chest!\" , color = \"info\" ) ]), width = 4 ) ]) app . run_server ( mode = 'external' ) As with other bootstrap components, the pre-built color options carry over in name and hue.","title":"Coloring Cells"},{"location":"learn/05_sheriff-styles/#horizontal-list","text":"Instead of keeping each list item stacked vertically, we can also arrange them horizontally. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . Col ( dbc . ListGroup ([ dbc . ListGroupItem ( \"First is the worst!\" , color = 'danger' ), dbc . ListGroupItem ( \"Second is the best!\" , color = \"success\" ), dbc . ListGroupItem ( \"Third is the one with the Treasure Chest!\" , color = \"info\" ) ], horizontal = True ), width = 6 ) ]) app . run_server ( mode = 'external' ) As seen, it's just a matter of adding the horizontal argument to our dbc.ListGroup() . NOTE: For more information, feel free to check out the following resources: dbc.ListGroup() \"And voila, now you have most of the core tools you need to begin styling,\" finishes the Sheriff. She smiles at us and points towards the horizon, \"As for where you're going to use these elements, you'll find your answer at the TigerGraph Tundra , the next step of your journey. Follow these rivers east, and they'll lead you to what you seek!\" All code segments from this chapter can be found in this Colab Notebook . Feel free to follow along! \u21a9 Everything we've installed so far (prerequistes for next section): ! pip install - q pyTigerGraph import pyTigerGraph as tg TG_SUBDOMAIN = 'healthcare-dash' TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio Link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph conn = tg . TigerGraphConnection ( host = TG_HOST , graphname = TG_GRAPHNAME , username = TG_USERNAME , password = TG_PASSWORD , beta = True ) conn . apiToken = conn . getToken ( conn . createSecret ()) ! pip install - q jupyter - dash import dash import dash_html_components as html from jupyter_dash import JupyterDash import plotly.express as px import pandas as pd import plotly.graph_objects as go import dash_core_components as dcc ! pip install dash - bootstrap - components import dash_bootstrap_components as dbc \u21a9","title":"Horizontal List"},{"location":"learn/06_tigergraph-tundra/","text":"TigerGraph Tundra \ud83d\udc2f \u00b6 As we make our way across the delta, the snow-capped mountains begin to encircle us. With each passing minute, the temperature falls while the gusts grow stronger. Soon, we reach an old wooden sign: \u201cTigerGraph Tundra. Population: 1\u201d Quite strange indeed. The wind begins to howl and the cold flurries continue to gnaw at our ankles. In the buffeting storm, we hear a voice call out to us. \u201cQuick, in here!\u201d An orange outline beckons to us, guiding us towards a rocky cave. Rushing inside, the stranger lights a torch and holds it closer to their face, revealing a\u2026 tiger? \u201cI am the protector of these parts, guide to all those who wish to learn the power of TigerGraph \u201d, the stranger exclaims. \u201cI\u2019ve heard that you are on a quest to create the ultimate dashboard?\u201d We quietly nod as our savior from the storm turns, \u201cCome, warm yourselves by the fire. We\u2019ve got a lot to discuss\u2026\u201d TigerGraph Tutorial 01 Basic pyTigerGraph \u00b6 In Chapter 01 - Installation Island, we had connected to our Healthcare Starter Kit solution using pyTigerGraph. This connection has several existing functions that we can use to access general information about our graph. Running Queries \u00b6 Before beginning, we must execute two queries which will help populate portions of our Graph. More specifically, running the ex2_main_query followed by the algo_louvain query creates referral edges used to link prescribers together. These edges are then used to detect communities of prescribers , which are useful in analyzing the relationships among healthcare providers, claims, and referrals. To run these queries, we simply execute the following: conn . runInstalledQuery ( \"ex2_main_query\" ) conn . runInstalledQuery ( \"algo_louvain\" ) And voila, it's as simple as that! Now, we can begin to analyze the vertices and edges of our Graph... Getting Vertices and Edges \u00b6 In order to get all vertex types, we run conn.getVertexTypes() . Thes types can then be iterated through and the number of vertices belonging to each type can be determined via conn.getVertexCount() . Here's an example! print ( \"Vertices \\n \" ) for vertex in conn . getVertexTypes (): print ( \" \" + vertex + \": \" + repr ( conn . getVertexCount ( vertex ))) A similar methodology can be used for edges. Simply replace \"Vertex\" with \"Edge\", giving us conn.getEdgeTypes() and conn.getEdgeCount() : print ( \"Edges \\n \" ) for edge in conn . getEdgeTypes (): print ( \" \" + edge + \": \" + repr ( conn . getEdgeCount ( edge ))) NOTE: For a comprehensive list, feel free to check out: pyTG functions \"With our general solution statistics ready, we can begin exploring our queries...\" TigerGraph Tutorial 02 Built-in Queries \u00b6 Our Healthcare Starter Kit comes with several pre-built queries. Each of them and their accompanying GSQL can be found in GraphStudio under the \"Write Queries\" tab. Here's a small snippet of what that page looks like: As seen on the left, there are a lot of options to explore! However, in this section we will dive into getClaims() and Print_community() getClaims \u00b6 The getClaims() query simply returns a list of all claims of a given prescriber. Here's a screenshot of the GSQL code (via GraphStudio) In order to access this query from Python, we can use the same conn.runInstalledQuery() as before: person_num = \"pre78\" claims = conn . runInstalledQuery ( \"getClaims\" , params = { \"inputPrescriber\" : person_num })[ 0 ][ 'claims' ] print ( claims ) As seen, the result is a list of claim vertices (established by 'v_type':'Claim' ). Using each claim's attributes dictionary, we can create a few neat visualizations. First, let's process this data... claims = conn . runInstalledQuery ( \"getClaims\" , params = { \"inputPrescriber\" : person_num })[ 0 ][ 'claims' ] title_map = {}; count_list = []; description_list = [] for number , claim in enumerate ( claims ): title = claim [ 'attributes' ][ 'CodeGroupTitle' ] desc = claim [ 'attributes' ][ 'ICD10CodeDescription' ] if desc is \"\" : desc = \"None provided!\" if title in title_map : title_map [ title ] = title_map [ title ] + 1 else : title_map [ title ] = 1 count_list . append ( number ) description_list . append ( desc ) Here, title_map simply keeps track of the frequency of each category of claim . count_list is simply a list of all the claim numbers while description_list holds the description of each claim (ex. \"Displaced fracture\"). Bar Chart \u00b6 Using this data, we can create a bar chart: titleList = [] countList = [] for entry in title_map : titleList . append ( entry ) countList . append ( title_map [ entry ]) # Next, we create a bar chart using a DataFrame countData = pd . DataFrame ( data = ( zip ( titleList , countList )), columns = [ 'Claim Title' , 'Count' ]) bar = px . bar ( countData , x = 'Claim Title' , y = 'Count' , title = '' , color_discrete_sequence = [ \"#DDEE00\" ] * len ( countData )) bar . update_xaxes ( type = 'category' , categoryorder = 'category ascending' ) bar . update_layout ( margin = dict ( l = 1 , r = 1 , t = 1 , b = 1 ), template = 'ggplot2' , xaxis_title = None ) bar . show () Pretty straightforward now that we've processed our query results! Dash Table \u00b6 Additionally, we can create a table of each claim. Using Dash Bootstrap Components , this becomes an easy task: descriptionData = pd . DataFrame ( data = ( zip ( count_list , description_list )), columns = [ 'Claim Num' , 'Claim Description' ]) header = [ html . Thead ( html . Tr ([ html . Th ( \"Claim Number\" ), html . Th ( \"Claim Description\" )]))] table = html . Div ( dbc . Table . from_dataframe ( descriptionData , striped = True , bordered = True ), style = { 'overflowY' : 'scroll' , 'height' : '450px' } ) Although this won't show until we add the table element to our dashboard, here's a sneak peek of the result! Print_Community \u00b6 Next up, we have Print_Community , which outputs the prescriber network that the inputted prescriber belongs to. For example, this is the following result given in GraphStudio when run with the input of \"pre78\" (Prescriber 78): In order to replicate this in Dash, we can utilize dash_cytoscape . This package allows for the creation of interactive graphs which can be easily modified and embedded into our dashboard. ! pip install dash - cytoscape import dash_cytoscape as cyto Now, we can begin impleninging the network. def getNetwork ( person_num ): comms = conn . runInstalledQuery ( \"Print_community\" , params = { \"inputPrescriber\" : person_num })[ 1 ][ '@@edgeList' ] vertices = {} els = [] for entry in comms : source = entry [ 'from_id' ] target = entry [ 'to_id' ] if source not in vertices : if source == person_num : els . append ({ 'data' : { 'id' : source , 'label' : source }, 'classes' : 'red' }) else : els . append ({ 'data' : { 'id' : source , 'label' : source }}) if target not in vertices : els . append ({ 'data' : { 'id' : target , 'label' : target }}) els . append ({ 'data' : { 'source' : source , 'target' : target }}) network = cyto . Cytoscape ( id = 'cytoscape' , elements = els , layout = { 'name' : 'breadthfirst' , 'padding' : 0 , 'x1' : - 1000 }, stylesheet = [ { 'selector' : 'node' , 'style' : { 'content' : 'data(label)' } }, { 'selector' : '.red' , 'style' : { 'background-color' : 'red' , } } ], style = { 'width' : '100%' , 'height' : '500px' , 'margin-left' : 0 } ) return network At the start, we run our query and parse through the results (each vertex/edge) in the prescriber community to create a list of elements, called els . These elements are in the appropriate format needed for Cytoscape. Vertex information is stored as {'data': {'id': source, 'label': source}} while edge information is stored as {'data': {'id': target, 'label': target}} . In both cases, source/target are simply vertex IDs. Although this won't show until we add the network element to our dashboard, here's another sneak peek! NOTE: For more information, feel free to check out the following resources: Dash Cytoscape \"We can add our own custom queries to our solution as well...\" TigerGraph Tutorial 03 Custom Queries \u00b6 We can create custom queries in two ways: Via GSQL in GraphStudio under the \"Write Queries\" tab In our Python Script via the function conn.gsql() Claim_Titles \u00b6 Let's take a look at a GSQL query that returns a frequency map of all the claims within the Graph. Claim_Titles = '''USE GRAPH MyGraph CREATE QUERY Claim_Titles() FOR GRAPH MyGraph { MapAccum<STRING, SumAccum<INT>> @@allClaims; start = {Claim.*}; claims = SELECT c FROM start:c ACCUM @@allClaims += (c.CodeGroupTitle -> 1); PRINT @@allClaims as freqClaims; } INSTALL QUERY Claim_Titles''' print ( conn . gsql ( Claim_Titles , options = [])) First, our GSQL is all stored in one variable , a string. The first line of our GSQL statement establishes which graph we're using The next line is our query header , which establishes the name of the query as well as any parameters or return values. In this case, there are no parameters (indicated by the empty paranthesis after the query name) and we are simply printing the results into a variable rather than returning any values. Now, we can dive into our query logic. With the line MapAccum<STRING, SumAccum<INT>> @@allClaims; , we create an accumulator that maps strings to a sum accumulator. Each string holds the claim title while the sum accumulator simply counts the number of instances of each claim title After this, we start with the entire set of vertices of type \"Claim\". Within our SELECT statement, we iterate across this entire set of claims and update our accumulator via ACCUM @@allClaims += (c.CodeGroupTitle -> 1); Finally, we print our map accumulator so that we may access it via Python The last line simply installs the query After writing this query, we run print(conn.gsql(Claim_Titles, options=[])) in order to install it. NOTE: If a query is already installed, trying to re-install it will result in an error! And voila, now we can access this query in GraphStudio as well. Ahh, you may have noticed the three additional queries on the left. Don't worry, that's part of the next section! Let's create a Pie Chart using this data! def getClaimsPieChart (): res = conn . runInstalledQuery ( \"Claim_Titles\" )[ 0 ][ 'freqClaims' ] claims = list ( res . keys ()) counts = list ( res . values ()) pie = px . pie ( values = counts , names = claims , hole = 0.2 , ) pie . update_layout ( width = 2000 , title_x = 0.5 , showlegend = False , margin = dict ( l = 10 , r = 10 , t = 10 , b = 10 )) pie . update_traces ( textposition = 'inside' , textinfo = 'label+percent' , ) return pie As the outputted result is a map, we can simply use the .keys() and .values() functions in Python in order to access the results. The rest is standard pie chart creation via Plotly Express. And ta-da, here's our fantastic figure: CommVsReferrals \u00b6 Next up, we can create a query to determine if having a larger prescriber network corresponds to an increase in average referrals received. In other words, does being in a prescriber community lead to more business? Before we can tackle this question, we need to create two helper queries in GSQL... Helper_NumMembers \u00b6 First, we need to be able to find the number of community members for a given prescriber. Helper_NumMembers = '''USE GRAPH MyGraph CREATE QUERY Helper_NumMembers(vertex<Prescriber> inputPrescriber) FOR GRAPH MyGraph RETURNS (INT) { SumAccum<INT> @@numMembers; SumAccum<int> @@cid; Start= {inputPrescriber} ; Start=Select s from Start:s post-accum @@cid += s.communityId; Start = {Prescriber.*}; Start = select s from Start:s-(referral:e)-:t where s.communityId == @@cid and s.communityId == t.communityId accum @@numMembers += 1; RETURN @@numMembers; } INSTALL QUERY Helper_NumMembers''' print ( conn . gsql ( Helper_NumMembers , options = [])) Let's break it down! First, this helper query takes a Prescriber vertex as its input. Additionally, it returns a type INT , the number of members in the prescriber's community. We create two accumulators , one to store the number of members in the community, and another to simply store the inputted prescriber's community ID. The inputted prescriber's community ID is stored in the first SELECT statement In the second SELECT statment, we iterate through every prescriber and increment our counter only if the community IDs of two connected prescribers match. This value (the sum accumulator) is returned, not printed! That wasn't so bad to flesh out! Next up, a similar helper function... Helper_NumReferrals \u00b6 Now, we need to be able to find the number of referrals for a given prescriber. Helper_NumReferrals = '''USE GRAPH MyGraph CREATE QUERY Helper_NumReferrals(vertex<Prescriber> inputPrescriber) FOR GRAPH MyGraph RETURNS (INT) { SumAccum<INT> @@numReferrals; Start= {inputPrescriber} ; referrals = SELECT p1 FROM Start:p1 -(referral:r) -Prescriber:p2 ACCUM @@numReferrals += 1; RETURN @@numReferrals; } INSTALL QUERY Helper_NumReferrals''' print ( conn . gsql ( Helper_NumReferrals , options = [])) This is quite similar to our previous helper function: In our first and second line, we specify the input parameter and return type respectively Next, we create a sum accumulator to store the number of referrals for the inputted prescriber In our select statement, we iterate through every referral given and increment the counter by 1. The results are returned, not printed! Using these two helper functions, we can write our main query. Main Query \u00b6 In order to write our main query, we can simply reference our two helper functions: CommVsReferrals = '''USE GRAPH MyGraph CREATE QUERY CommVsReferrals() FOR GRAPH MyGraph { MapAccum<INT, AvgAccum> @@commReferrals; start = {Prescriber.*}; allPres = SELECT p FROM start:p ACCUM @@commReferrals += (Helper_NumMembers(p) -> Helper_NumReferrals(p)); PRINT @@commReferrals as commReferrals; } INSTALL QUERY CommVsReferrals''' print ( conn . gsql ( CommVsReferrals , options = [])) First, we create a Map Accumulator for each community size and the average number of referrals that each member in that community received. Next, we iterate across all prescribers in our SELECT statement and add the number of members as well as the number of referrals. Because of our AvgAccum , we don't have to do any other work! NOTE: As you may have noticed, AvgAccum does not take a datatype as a parameter! With this query installed, we can reference and visualize the results. def getScatterChart (): referrals = conn . runInstalledQuery ( \"CommVsReferrals\" )[ 0 ][ 'commReferrals' ] sizes = list ( referrals . keys ()) avgs = list ( referrals . values ()) scatter = px . scatter ( x = sizes , y = avgs , size = avgs , color = avgs ) scatter . update_coloraxes ( colorbar_title = \"Avg\" ) scatter . update_layout ( title = \"Prescriber Community Size vs. Average Referrals per Prescriber\" , xaxis_title = \"Prescriber Community Size\" , yaxis_title = \"Avg Referrals per Prescriber\" , width = 1000 ) return scatter Once again, as the outputted result is a map, we can simply use the .keys() and .values() functions in Python in order to access the results. And here's the resulting scatter plot. Hmm, a spike around 15 members. A coincidence? Maybe. We'll need more data to find out \ud83d\ude04! \"And finally, we can put together a dashboard using all of what we learned...\" TigerGraph Tutorial 04 Putting it Together \u00b6 In order to piece everything together, we'll start by storing several components in variables. Titles and ListGroups First, we'll create a title card as well as a list group to hold all the vertices and edge counts. titleCard = dbc . Card ([ dbc . CardBody ([ html . Center ( html . H1 ( \"TigerGraph's HealthCare Starter Kit\" , className = 'card-title' )), ]) ], color = 'light' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , #\"margin-left\":\"1rem\", \"margin-top\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) vItems = [ dbc . ListGroupItem ( vertex + \": \" + repr ( conn . getVertexCount ( vertex )), color = 'info' ) for vertex in conn . getVertexTypes ()] eItems = [ dbc . ListGroupItem ( edge + \": \" + repr ( conn . getEdgeCount ( edge )), color = 'success' ) for edge in conn . getEdgeTypes ()] listItems = vItems + eItems statsListGroup = dbc . ListGroup ( listItems , horizontal = True ) Pie, Scatter Chart Next up, we'll use our getClaimsPieChart() and getScatterChart() functions from before to create two cards. pieChart = getClaimsPieChart () scatterChart = getScatterChart () pieChartCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"All Submitted Claims\" , className = 'card-title' ), html . P ( \"Which categories of claims are most frequent? \\n Which areas should prescribers focus on?\" , className = 'card-body' ), dcc . Graph ( id = 'Pie Chart' , figure = pieChart ) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"50rem\" , \"margin-right\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) scatterChartCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Prescriber Communities\" , className = 'card-title' ), html . P ( \"Do communities lead to more business? How do the number of referrals compare to community size?\" , className = 'card-body' ), dcc . Graph ( id = 'Scatter Chart' , figure = scatterChart ) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"50rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) Table, Bar We can piece together a function getClaims() that generates our table and bar chart. def getClaims ( person_num ): claims = conn . runInstalledQuery ( \"getClaims\" , params = { \"inputPrescriber\" : person_num })[ 0 ][ 'claims' ] title_map = {}; count_list = []; description_list = [] for number , claim in enumerate ( claims ): title = claim [ 'attributes' ][ 'CodeGroupTitle' ] desc = claim [ 'attributes' ][ 'ICD10CodeDescription' ] if desc is \"\" : desc = \"None provided!\" if title in title_map : title_map [ title ] = title_map [ title ] + 1 else : title_map [ title ] = 1 count_list . append ( number ) description_list . append ( desc ) # We'll create a table w/ the Descriptions! descriptionData = pd . DataFrame ( data = ( zip ( count_list , description_list )), columns = [ 'Claim Num' , 'Claim Description' ]) header = [ html . Thead ( html . Tr ([ html . Th ( \"Claim Number\" ), html . Th ( \"Claim Description\" )]))] table = html . Div ( dbc . Table . from_dataframe ( descriptionData , striped = True , bordered = True ), style = { 'overflowY' : 'scroll' , 'height' : '450px' } ) # We'll create a bar chart w/ the Claim Titles titleList = [] countList = [] for entry in title_map : titleList . append ( entry ) countList . append ( title_map [ entry ]) countData = pd . DataFrame ( data = ( zip ( titleList , countList )), columns = [ 'Claim Title' , 'Count' ]) bar = px . bar ( countData , x = 'Claim Title' , y = 'Count' , title = '' , color_discrete_sequence = [ \"#DDEE00\" ] * len ( countData )) bar . update_xaxes ( type = 'category' , categoryorder = 'category ascending' ) bar . update_layout ( margin = dict ( l = 1 , r = 1 , t = 1 , b = 1 ), template = 'ggplot2' , xaxis_title = None ) max_key = max ( title_map , key = title_map . get ) return len ( claims ), table , bar , max_key This function will also return the number of claims as well as the highest claim category ( max_key ). Network Graph, Prescriber Info We can use our getNetwork() function from the \"Print_Community\" section as well as getClaims() from above in order to create getPrescriberInfo() . This function will be inputted a prescriber and return the calculated statistics and figures regarding the prescriber. Although this function may seem long, most of it is just stylistic cards! def getPrescriberInfo ( person_num ): network = getNetwork ( person_num ) number , table , bar , max_title = getClaims ( person_num ) prescriberTitleCard = dbc . Card ([ dbc . CardBody ([ html . Center ( dbc . Badge ([ html . H1 ( \" Prescriber \" + person_num + \"'s Claims \" , className = 'card-title' )], color = \"light\" )), html . Center ( html . P ( \"This individual has a total of \" + repr ( number ) + \" claims. Their most referred to specialization is: \" + max_title , className = 'card-body' )), ]) ], outline = True , color = 'info' , style = { \"width\" : \"98rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) tableCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Claims by Prescriber\" , className = 'card-title' ), html . P ( \"A detailed description of each claim...\" , className = 'card-body' ), table ]) ], outline = True , color = 'info' , style = { \"width\" : \"50rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) barCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Claims by Category\" , className = 'card-title' ), html . P ( \"Which claims are being prescribed most?\" , className = 'card-body' ), dcc . Graph ( id = 'Bar Chart' , figure = bar ) ]) ], outline = True , color = 'info' , style = { \"width\" : \"50rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) networkCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Prescriber Network\" , className = 'card-title' ), html . P ( \"Who's part of this prescriber's community?\" , className = 'card-body' ), network ]) ], outline = True , color = 'info' , style = { \"width\" : \"50rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) return prescriberTitleCard , tableCard , barCard , networkCard , network As seen, we store all the figures as variables at the top. Next, we create cards for each. Dashboard Itself \u00b6 With all of the pieces ready to go, we can finally create our new dashboard. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) person_num = \"pre78\" prescriberTitleCard , tableCard , barCard , networkCard , network = getPrescriberInfo ( person_num ) app . layout = html . Center ( html . Div ([ dbc . Row ( titleCard , justify = \"center\" ), dbc . Row ( statsListGroup , justify = \"center\" ), html . Br (), dbc . Row ([ pieChartCard , scatterChartCard , ], justify = \"center\" ), html . Hr (), prescriberTitleCard , dbc . Row ([ dbc . Col ([ tableCard , network ]), dbc . Col ([ barCard , networkCard ]) ], justify = \"center\" ) ])) app . run_server ( mode = 'external' ) Having created all those variables earlier makes the app layout far easier to read and understand. This is a good practice for creating dashboards, as it allows for easier modification and testing instead of having to scroll through hundreds of lines of card bodies, figures, and more. And now, our hard work pays off: The TigerGraph protector looks at us and smiles. \"You've come a long way. Yet there's still more to learn in order to complete your quest. Head east, continue past the Tundra, and find the Elysium of Elements . There, you'll truly be able to access everything that you can create using TigerGraph + Plotly...\" All code segments from this chapter can be found in this Colab Notebook . Feel free to follow along! \u21a9 Everything we've installed so far (prerequistes for next section): ! pip install - q pyTigerGraph import pyTigerGraph as tg TG_SUBDOMAIN = 'healthcare-dash' TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio Link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph conn = tg . TigerGraphConnection ( host = TG_HOST , graphname = TG_GRAPHNAME , username = TG_USERNAME , password = TG_PASSWORD , beta = True ) conn . apiToken = conn . getToken ( conn . createSecret ()) ! pip install - q jupyter - dash import dash import dash_html_components as html from jupyter_dash import JupyterDash import plotly.express as px import pandas as pd import plotly.graph_objects as go import dash_core_components as dcc ! pip install dash - bootstrap - components import dash_bootstrap_components as dbc ! pip install dash - cytoscape import dash_cytoscape as cyto \u21a9","title":"Ch 06 - The TigerGraph Tundra"},{"location":"learn/06_tigergraph-tundra/#tigergraph-tundra","text":"As we make our way across the delta, the snow-capped mountains begin to encircle us. With each passing minute, the temperature falls while the gusts grow stronger. Soon, we reach an old wooden sign: \u201cTigerGraph Tundra. Population: 1\u201d Quite strange indeed. The wind begins to howl and the cold flurries continue to gnaw at our ankles. In the buffeting storm, we hear a voice call out to us. \u201cQuick, in here!\u201d An orange outline beckons to us, guiding us towards a rocky cave. Rushing inside, the stranger lights a torch and holds it closer to their face, revealing a\u2026 tiger? \u201cI am the protector of these parts, guide to all those who wish to learn the power of TigerGraph \u201d, the stranger exclaims. \u201cI\u2019ve heard that you are on a quest to create the ultimate dashboard?\u201d We quietly nod as our savior from the storm turns, \u201cCome, warm yourselves by the fire. We\u2019ve got a lot to discuss\u2026\u201d TigerGraph Tutorial 01","title":"TigerGraph Tundra \ud83d\udc2f"},{"location":"learn/06_tigergraph-tundra/#basic-pytigergraph","text":"In Chapter 01 - Installation Island, we had connected to our Healthcare Starter Kit solution using pyTigerGraph. This connection has several existing functions that we can use to access general information about our graph.","title":"Basic pyTigerGraph"},{"location":"learn/06_tigergraph-tundra/#running-queries","text":"Before beginning, we must execute two queries which will help populate portions of our Graph. More specifically, running the ex2_main_query followed by the algo_louvain query creates referral edges used to link prescribers together. These edges are then used to detect communities of prescribers , which are useful in analyzing the relationships among healthcare providers, claims, and referrals. To run these queries, we simply execute the following: conn . runInstalledQuery ( \"ex2_main_query\" ) conn . runInstalledQuery ( \"algo_louvain\" ) And voila, it's as simple as that! Now, we can begin to analyze the vertices and edges of our Graph...","title":"Running Queries"},{"location":"learn/06_tigergraph-tundra/#getting-vertices-and-edges","text":"In order to get all vertex types, we run conn.getVertexTypes() . Thes types can then be iterated through and the number of vertices belonging to each type can be determined via conn.getVertexCount() . Here's an example! print ( \"Vertices \\n \" ) for vertex in conn . getVertexTypes (): print ( \" \" + vertex + \": \" + repr ( conn . getVertexCount ( vertex ))) A similar methodology can be used for edges. Simply replace \"Vertex\" with \"Edge\", giving us conn.getEdgeTypes() and conn.getEdgeCount() : print ( \"Edges \\n \" ) for edge in conn . getEdgeTypes (): print ( \" \" + edge + \": \" + repr ( conn . getEdgeCount ( edge ))) NOTE: For a comprehensive list, feel free to check out: pyTG functions \"With our general solution statistics ready, we can begin exploring our queries...\" TigerGraph Tutorial 02","title":"Getting Vertices and Edges"},{"location":"learn/06_tigergraph-tundra/#built-in-queries","text":"Our Healthcare Starter Kit comes with several pre-built queries. Each of them and their accompanying GSQL can be found in GraphStudio under the \"Write Queries\" tab. Here's a small snippet of what that page looks like: As seen on the left, there are a lot of options to explore! However, in this section we will dive into getClaims() and Print_community()","title":"Built-in Queries"},{"location":"learn/06_tigergraph-tundra/#getclaims","text":"The getClaims() query simply returns a list of all claims of a given prescriber. Here's a screenshot of the GSQL code (via GraphStudio) In order to access this query from Python, we can use the same conn.runInstalledQuery() as before: person_num = \"pre78\" claims = conn . runInstalledQuery ( \"getClaims\" , params = { \"inputPrescriber\" : person_num })[ 0 ][ 'claims' ] print ( claims ) As seen, the result is a list of claim vertices (established by 'v_type':'Claim' ). Using each claim's attributes dictionary, we can create a few neat visualizations. First, let's process this data... claims = conn . runInstalledQuery ( \"getClaims\" , params = { \"inputPrescriber\" : person_num })[ 0 ][ 'claims' ] title_map = {}; count_list = []; description_list = [] for number , claim in enumerate ( claims ): title = claim [ 'attributes' ][ 'CodeGroupTitle' ] desc = claim [ 'attributes' ][ 'ICD10CodeDescription' ] if desc is \"\" : desc = \"None provided!\" if title in title_map : title_map [ title ] = title_map [ title ] + 1 else : title_map [ title ] = 1 count_list . append ( number ) description_list . append ( desc ) Here, title_map simply keeps track of the frequency of each category of claim . count_list is simply a list of all the claim numbers while description_list holds the description of each claim (ex. \"Displaced fracture\").","title":"getClaims"},{"location":"learn/06_tigergraph-tundra/#bar-chart","text":"Using this data, we can create a bar chart: titleList = [] countList = [] for entry in title_map : titleList . append ( entry ) countList . append ( title_map [ entry ]) # Next, we create a bar chart using a DataFrame countData = pd . DataFrame ( data = ( zip ( titleList , countList )), columns = [ 'Claim Title' , 'Count' ]) bar = px . bar ( countData , x = 'Claim Title' , y = 'Count' , title = '' , color_discrete_sequence = [ \"#DDEE00\" ] * len ( countData )) bar . update_xaxes ( type = 'category' , categoryorder = 'category ascending' ) bar . update_layout ( margin = dict ( l = 1 , r = 1 , t = 1 , b = 1 ), template = 'ggplot2' , xaxis_title = None ) bar . show () Pretty straightforward now that we've processed our query results!","title":"Bar Chart"},{"location":"learn/06_tigergraph-tundra/#dash-table","text":"Additionally, we can create a table of each claim. Using Dash Bootstrap Components , this becomes an easy task: descriptionData = pd . DataFrame ( data = ( zip ( count_list , description_list )), columns = [ 'Claim Num' , 'Claim Description' ]) header = [ html . Thead ( html . Tr ([ html . Th ( \"Claim Number\" ), html . Th ( \"Claim Description\" )]))] table = html . Div ( dbc . Table . from_dataframe ( descriptionData , striped = True , bordered = True ), style = { 'overflowY' : 'scroll' , 'height' : '450px' } ) Although this won't show until we add the table element to our dashboard, here's a sneak peek of the result!","title":"Dash Table"},{"location":"learn/06_tigergraph-tundra/#print_community","text":"Next up, we have Print_Community , which outputs the prescriber network that the inputted prescriber belongs to. For example, this is the following result given in GraphStudio when run with the input of \"pre78\" (Prescriber 78): In order to replicate this in Dash, we can utilize dash_cytoscape . This package allows for the creation of interactive graphs which can be easily modified and embedded into our dashboard. ! pip install dash - cytoscape import dash_cytoscape as cyto Now, we can begin impleninging the network. def getNetwork ( person_num ): comms = conn . runInstalledQuery ( \"Print_community\" , params = { \"inputPrescriber\" : person_num })[ 1 ][ '@@edgeList' ] vertices = {} els = [] for entry in comms : source = entry [ 'from_id' ] target = entry [ 'to_id' ] if source not in vertices : if source == person_num : els . append ({ 'data' : { 'id' : source , 'label' : source }, 'classes' : 'red' }) else : els . append ({ 'data' : { 'id' : source , 'label' : source }}) if target not in vertices : els . append ({ 'data' : { 'id' : target , 'label' : target }}) els . append ({ 'data' : { 'source' : source , 'target' : target }}) network = cyto . Cytoscape ( id = 'cytoscape' , elements = els , layout = { 'name' : 'breadthfirst' , 'padding' : 0 , 'x1' : - 1000 }, stylesheet = [ { 'selector' : 'node' , 'style' : { 'content' : 'data(label)' } }, { 'selector' : '.red' , 'style' : { 'background-color' : 'red' , } } ], style = { 'width' : '100%' , 'height' : '500px' , 'margin-left' : 0 } ) return network At the start, we run our query and parse through the results (each vertex/edge) in the prescriber community to create a list of elements, called els . These elements are in the appropriate format needed for Cytoscape. Vertex information is stored as {'data': {'id': source, 'label': source}} while edge information is stored as {'data': {'id': target, 'label': target}} . In both cases, source/target are simply vertex IDs. Although this won't show until we add the network element to our dashboard, here's another sneak peek! NOTE: For more information, feel free to check out the following resources: Dash Cytoscape \"We can add our own custom queries to our solution as well...\" TigerGraph Tutorial 03","title":"Print_Community"},{"location":"learn/06_tigergraph-tundra/#custom-queries","text":"We can create custom queries in two ways: Via GSQL in GraphStudio under the \"Write Queries\" tab In our Python Script via the function conn.gsql()","title":"Custom Queries"},{"location":"learn/06_tigergraph-tundra/#claim_titles","text":"Let's take a look at a GSQL query that returns a frequency map of all the claims within the Graph. Claim_Titles = '''USE GRAPH MyGraph CREATE QUERY Claim_Titles() FOR GRAPH MyGraph { MapAccum<STRING, SumAccum<INT>> @@allClaims; start = {Claim.*}; claims = SELECT c FROM start:c ACCUM @@allClaims += (c.CodeGroupTitle -> 1); PRINT @@allClaims as freqClaims; } INSTALL QUERY Claim_Titles''' print ( conn . gsql ( Claim_Titles , options = [])) First, our GSQL is all stored in one variable , a string. The first line of our GSQL statement establishes which graph we're using The next line is our query header , which establishes the name of the query as well as any parameters or return values. In this case, there are no parameters (indicated by the empty paranthesis after the query name) and we are simply printing the results into a variable rather than returning any values. Now, we can dive into our query logic. With the line MapAccum<STRING, SumAccum<INT>> @@allClaims; , we create an accumulator that maps strings to a sum accumulator. Each string holds the claim title while the sum accumulator simply counts the number of instances of each claim title After this, we start with the entire set of vertices of type \"Claim\". Within our SELECT statement, we iterate across this entire set of claims and update our accumulator via ACCUM @@allClaims += (c.CodeGroupTitle -> 1); Finally, we print our map accumulator so that we may access it via Python The last line simply installs the query After writing this query, we run print(conn.gsql(Claim_Titles, options=[])) in order to install it. NOTE: If a query is already installed, trying to re-install it will result in an error! And voila, now we can access this query in GraphStudio as well. Ahh, you may have noticed the three additional queries on the left. Don't worry, that's part of the next section! Let's create a Pie Chart using this data! def getClaimsPieChart (): res = conn . runInstalledQuery ( \"Claim_Titles\" )[ 0 ][ 'freqClaims' ] claims = list ( res . keys ()) counts = list ( res . values ()) pie = px . pie ( values = counts , names = claims , hole = 0.2 , ) pie . update_layout ( width = 2000 , title_x = 0.5 , showlegend = False , margin = dict ( l = 10 , r = 10 , t = 10 , b = 10 )) pie . update_traces ( textposition = 'inside' , textinfo = 'label+percent' , ) return pie As the outputted result is a map, we can simply use the .keys() and .values() functions in Python in order to access the results. The rest is standard pie chart creation via Plotly Express. And ta-da, here's our fantastic figure:","title":"Claim_Titles"},{"location":"learn/06_tigergraph-tundra/#commvsreferrals","text":"Next up, we can create a query to determine if having a larger prescriber network corresponds to an increase in average referrals received. In other words, does being in a prescriber community lead to more business? Before we can tackle this question, we need to create two helper queries in GSQL...","title":"CommVsReferrals"},{"location":"learn/06_tigergraph-tundra/#helper_nummembers","text":"First, we need to be able to find the number of community members for a given prescriber. Helper_NumMembers = '''USE GRAPH MyGraph CREATE QUERY Helper_NumMembers(vertex<Prescriber> inputPrescriber) FOR GRAPH MyGraph RETURNS (INT) { SumAccum<INT> @@numMembers; SumAccum<int> @@cid; Start= {inputPrescriber} ; Start=Select s from Start:s post-accum @@cid += s.communityId; Start = {Prescriber.*}; Start = select s from Start:s-(referral:e)-:t where s.communityId == @@cid and s.communityId == t.communityId accum @@numMembers += 1; RETURN @@numMembers; } INSTALL QUERY Helper_NumMembers''' print ( conn . gsql ( Helper_NumMembers , options = [])) Let's break it down! First, this helper query takes a Prescriber vertex as its input. Additionally, it returns a type INT , the number of members in the prescriber's community. We create two accumulators , one to store the number of members in the community, and another to simply store the inputted prescriber's community ID. The inputted prescriber's community ID is stored in the first SELECT statement In the second SELECT statment, we iterate through every prescriber and increment our counter only if the community IDs of two connected prescribers match. This value (the sum accumulator) is returned, not printed! That wasn't so bad to flesh out! Next up, a similar helper function...","title":"Helper_NumMembers"},{"location":"learn/06_tigergraph-tundra/#helper_numreferrals","text":"Now, we need to be able to find the number of referrals for a given prescriber. Helper_NumReferrals = '''USE GRAPH MyGraph CREATE QUERY Helper_NumReferrals(vertex<Prescriber> inputPrescriber) FOR GRAPH MyGraph RETURNS (INT) { SumAccum<INT> @@numReferrals; Start= {inputPrescriber} ; referrals = SELECT p1 FROM Start:p1 -(referral:r) -Prescriber:p2 ACCUM @@numReferrals += 1; RETURN @@numReferrals; } INSTALL QUERY Helper_NumReferrals''' print ( conn . gsql ( Helper_NumReferrals , options = [])) This is quite similar to our previous helper function: In our first and second line, we specify the input parameter and return type respectively Next, we create a sum accumulator to store the number of referrals for the inputted prescriber In our select statement, we iterate through every referral given and increment the counter by 1. The results are returned, not printed! Using these two helper functions, we can write our main query.","title":"Helper_NumReferrals"},{"location":"learn/06_tigergraph-tundra/#main-query","text":"In order to write our main query, we can simply reference our two helper functions: CommVsReferrals = '''USE GRAPH MyGraph CREATE QUERY CommVsReferrals() FOR GRAPH MyGraph { MapAccum<INT, AvgAccum> @@commReferrals; start = {Prescriber.*}; allPres = SELECT p FROM start:p ACCUM @@commReferrals += (Helper_NumMembers(p) -> Helper_NumReferrals(p)); PRINT @@commReferrals as commReferrals; } INSTALL QUERY CommVsReferrals''' print ( conn . gsql ( CommVsReferrals , options = [])) First, we create a Map Accumulator for each community size and the average number of referrals that each member in that community received. Next, we iterate across all prescribers in our SELECT statement and add the number of members as well as the number of referrals. Because of our AvgAccum , we don't have to do any other work! NOTE: As you may have noticed, AvgAccum does not take a datatype as a parameter! With this query installed, we can reference and visualize the results. def getScatterChart (): referrals = conn . runInstalledQuery ( \"CommVsReferrals\" )[ 0 ][ 'commReferrals' ] sizes = list ( referrals . keys ()) avgs = list ( referrals . values ()) scatter = px . scatter ( x = sizes , y = avgs , size = avgs , color = avgs ) scatter . update_coloraxes ( colorbar_title = \"Avg\" ) scatter . update_layout ( title = \"Prescriber Community Size vs. Average Referrals per Prescriber\" , xaxis_title = \"Prescriber Community Size\" , yaxis_title = \"Avg Referrals per Prescriber\" , width = 1000 ) return scatter Once again, as the outputted result is a map, we can simply use the .keys() and .values() functions in Python in order to access the results. And here's the resulting scatter plot. Hmm, a spike around 15 members. A coincidence? Maybe. We'll need more data to find out \ud83d\ude04! \"And finally, we can put together a dashboard using all of what we learned...\" TigerGraph Tutorial 04","title":"Main Query"},{"location":"learn/06_tigergraph-tundra/#putting-it-together","text":"In order to piece everything together, we'll start by storing several components in variables. Titles and ListGroups First, we'll create a title card as well as a list group to hold all the vertices and edge counts. titleCard = dbc . Card ([ dbc . CardBody ([ html . Center ( html . H1 ( \"TigerGraph's HealthCare Starter Kit\" , className = 'card-title' )), ]) ], color = 'light' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , #\"margin-left\":\"1rem\", \"margin-top\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) vItems = [ dbc . ListGroupItem ( vertex + \": \" + repr ( conn . getVertexCount ( vertex )), color = 'info' ) for vertex in conn . getVertexTypes ()] eItems = [ dbc . ListGroupItem ( edge + \": \" + repr ( conn . getEdgeCount ( edge )), color = 'success' ) for edge in conn . getEdgeTypes ()] listItems = vItems + eItems statsListGroup = dbc . ListGroup ( listItems , horizontal = True ) Pie, Scatter Chart Next up, we'll use our getClaimsPieChart() and getScatterChart() functions from before to create two cards. pieChart = getClaimsPieChart () scatterChart = getScatterChart () pieChartCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"All Submitted Claims\" , className = 'card-title' ), html . P ( \"Which categories of claims are most frequent? \\n Which areas should prescribers focus on?\" , className = 'card-body' ), dcc . Graph ( id = 'Pie Chart' , figure = pieChart ) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"50rem\" , \"margin-right\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) scatterChartCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Prescriber Communities\" , className = 'card-title' ), html . P ( \"Do communities lead to more business? How do the number of referrals compare to community size?\" , className = 'card-body' ), dcc . Graph ( id = 'Scatter Chart' , figure = scatterChart ) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"50rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) Table, Bar We can piece together a function getClaims() that generates our table and bar chart. def getClaims ( person_num ): claims = conn . runInstalledQuery ( \"getClaims\" , params = { \"inputPrescriber\" : person_num })[ 0 ][ 'claims' ] title_map = {}; count_list = []; description_list = [] for number , claim in enumerate ( claims ): title = claim [ 'attributes' ][ 'CodeGroupTitle' ] desc = claim [ 'attributes' ][ 'ICD10CodeDescription' ] if desc is \"\" : desc = \"None provided!\" if title in title_map : title_map [ title ] = title_map [ title ] + 1 else : title_map [ title ] = 1 count_list . append ( number ) description_list . append ( desc ) # We'll create a table w/ the Descriptions! descriptionData = pd . DataFrame ( data = ( zip ( count_list , description_list )), columns = [ 'Claim Num' , 'Claim Description' ]) header = [ html . Thead ( html . Tr ([ html . Th ( \"Claim Number\" ), html . Th ( \"Claim Description\" )]))] table = html . Div ( dbc . Table . from_dataframe ( descriptionData , striped = True , bordered = True ), style = { 'overflowY' : 'scroll' , 'height' : '450px' } ) # We'll create a bar chart w/ the Claim Titles titleList = [] countList = [] for entry in title_map : titleList . append ( entry ) countList . append ( title_map [ entry ]) countData = pd . DataFrame ( data = ( zip ( titleList , countList )), columns = [ 'Claim Title' , 'Count' ]) bar = px . bar ( countData , x = 'Claim Title' , y = 'Count' , title = '' , color_discrete_sequence = [ \"#DDEE00\" ] * len ( countData )) bar . update_xaxes ( type = 'category' , categoryorder = 'category ascending' ) bar . update_layout ( margin = dict ( l = 1 , r = 1 , t = 1 , b = 1 ), template = 'ggplot2' , xaxis_title = None ) max_key = max ( title_map , key = title_map . get ) return len ( claims ), table , bar , max_key This function will also return the number of claims as well as the highest claim category ( max_key ). Network Graph, Prescriber Info We can use our getNetwork() function from the \"Print_Community\" section as well as getClaims() from above in order to create getPrescriberInfo() . This function will be inputted a prescriber and return the calculated statistics and figures regarding the prescriber. Although this function may seem long, most of it is just stylistic cards! def getPrescriberInfo ( person_num ): network = getNetwork ( person_num ) number , table , bar , max_title = getClaims ( person_num ) prescriberTitleCard = dbc . Card ([ dbc . CardBody ([ html . Center ( dbc . Badge ([ html . H1 ( \" Prescriber \" + person_num + \"'s Claims \" , className = 'card-title' )], color = \"light\" )), html . Center ( html . P ( \"This individual has a total of \" + repr ( number ) + \" claims. Their most referred to specialization is: \" + max_title , className = 'card-body' )), ]) ], outline = True , color = 'info' , style = { \"width\" : \"98rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) tableCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Claims by Prescriber\" , className = 'card-title' ), html . P ( \"A detailed description of each claim...\" , className = 'card-body' ), table ]) ], outline = True , color = 'info' , style = { \"width\" : \"50rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) barCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Claims by Category\" , className = 'card-title' ), html . P ( \"Which claims are being prescribed most?\" , className = 'card-body' ), dcc . Graph ( id = 'Bar Chart' , figure = bar ) ]) ], outline = True , color = 'info' , style = { \"width\" : \"50rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) networkCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Prescriber Network\" , className = 'card-title' ), html . P ( \"Who's part of this prescriber's community?\" , className = 'card-body' ), network ]) ], outline = True , color = 'info' , style = { \"width\" : \"50rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) return prescriberTitleCard , tableCard , barCard , networkCard , network As seen, we store all the figures as variables at the top. Next, we create cards for each.","title":"Putting it Together"},{"location":"learn/06_tigergraph-tundra/#dashboard-itself","text":"With all of the pieces ready to go, we can finally create our new dashboard. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) person_num = \"pre78\" prescriberTitleCard , tableCard , barCard , networkCard , network = getPrescriberInfo ( person_num ) app . layout = html . Center ( html . Div ([ dbc . Row ( titleCard , justify = \"center\" ), dbc . Row ( statsListGroup , justify = \"center\" ), html . Br (), dbc . Row ([ pieChartCard , scatterChartCard , ], justify = \"center\" ), html . Hr (), prescriberTitleCard , dbc . Row ([ dbc . Col ([ tableCard , network ]), dbc . Col ([ barCard , networkCard ]) ], justify = \"center\" ) ])) app . run_server ( mode = 'external' ) Having created all those variables earlier makes the app layout far easier to read and understand. This is a good practice for creating dashboards, as it allows for easier modification and testing instead of having to scroll through hundreds of lines of card bodies, figures, and more. And now, our hard work pays off: The TigerGraph protector looks at us and smiles. \"You've come a long way. Yet there's still more to learn in order to complete your quest. Head east, continue past the Tundra, and find the Elysium of Elements . There, you'll truly be able to access everything that you can create using TigerGraph + Plotly...\" All code segments from this chapter can be found in this Colab Notebook . Feel free to follow along! \u21a9 Everything we've installed so far (prerequistes for next section): ! pip install - q pyTigerGraph import pyTigerGraph as tg TG_SUBDOMAIN = 'healthcare-dash' TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio Link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph conn = tg . TigerGraphConnection ( host = TG_HOST , graphname = TG_GRAPHNAME , username = TG_USERNAME , password = TG_PASSWORD , beta = True ) conn . apiToken = conn . getToken ( conn . createSecret ()) ! pip install - q jupyter - dash import dash import dash_html_components as html from jupyter_dash import JupyterDash import plotly.express as px import pandas as pd import plotly.graph_objects as go import dash_core_components as dcc ! pip install dash - bootstrap - components import dash_bootstrap_components as dbc ! pip install dash - cytoscape import dash_cytoscape as cyto \u21a9","title":"Dashboard Itself"},{"location":"learn/07_multi-monster/","text":"The Multi-Page Monsters \ud83e\udd96 \u00b6 After waving goodbye to our mysterious friend, we trudge onwards through the TigerGraph tundra, hoping to find the elusive elysium of elements described by the TigerGraph protector . As we make our way in the harsh winds, we hear a roar echoing throughout the valley. Loud stomps grow closer and we clutch our laptop, trembling with panic. A booming voice pierces through the bitter cold: \u201cAhh, we hear you\u2019re on a quest! Well lucky for you, we can help!\u201d Turning around, we see two strange figures beaming at us. \u201cWe\u2019re the Multi-Page monsters, and we have a way to organize your cluttered dashboards! \u201d In an attempt to reassure our quizzical expressions, they laughed. \u201cDon\u2019t worry! It\u2019s quite easy to clean up your dashboard by organizing it into multiple pages\u2026 \u201d Multi-Page Monster Notes 01 A Simple Multi-Page App \u00b6 The first step in creating multiple pages for our Dash app is to separate our content into multiple distinct variables or elements . For example, if we wish to create three pages, we can perform this by create three content variables : page1_content = html . Div ( html . H1 ( \"This is Pg. 1!\" )) page2_content = html . Div ( html . H1 ( html . B ( \"This is Pg. 2!\" ))) page3_content = html . Div ( html . H1 ( html . I ( \"This is Pg. 3!\" ))) Next, we must change our app layout to reflect this: app = JupyterDash ( __name__ ) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def display_page ( pathname ): if pathname == \"/\" : return page1_content elif pathname == \"/page2\" : return page2_content elif pathname == \"/page3\" : return page3_content app . run_server ( mode = 'external' ) And now, running the app will only show us the first page! However, entering the proper link will take us to pages 2 and 3. How are we doing this? Well, using a simple callback... As defined below the app layout, the input is simply the pathname of the current page . The output is the page-content, an html.Div element that we've defined in our app layout. This is where the importance of element id's comes into play! For any element that will be updated via a callback, an id is needed. @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) Breaking down the function display_page() , we simply compare the pathname to several predefined, valid pages. Then, the respective content is returned. This content is stored and displayed in html.Div(id='page-content') . NOTE: We will cover callbacks in the next chapter! This is merely an intro used to navigate through pages . Yet entering any other link will lead to a blank page... uh oh! We need to make sure that the user doesn't accidentally access any unauthorized or unbuilt pages . They should only be able to access the extension links that we've provided. In order to secure this, we can use Dash Bootstrap... Dash Jumbotron \u00b6 The Dash Jumbotron is a Bootstrap component that is used to showcase important messages . In this case, we'll use it to display a \"404 error message\" whenever the user reaches an unauthorized page . Adding this jumbotron is quite simple. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def display_page ( pathname ): if pathname == \"/\" : return page1_content elif pathname == \"/page2\" : return page2_content elif pathname == \"/page3\" : return page3_content return dbc . Jumbotron ( [ html . H1 ( \"404: Not found\" , className = \"text-danger\" ), html . Hr (), html . P ( \"Uh oh! Unfortunately, the pathname {} was unable to be recognised...\" . format ( pathname )), ] ) app . run_server ( mode = 'external' ) And just like that, we've put together a simple multi-page app! In order to modify each page, we can simply change the html.Div() element to contain our page's components. To add pages, we can extend our if/else. Yet as of now, users can only navigate by entering each page's link. \"This isn't the best way to navigate across pages... Users shouldn't have to manually enter the link for each page they wish to reach. Let's take this example one step further...\" Multi-Page Monster Notes 02 Comprehensive Multi-Page App \u00b6 Let's use our Healthcare Dashboard and partition it into two pages . General Page - Contains our title , listgroups , pie , and scatter plot Prescriber Page - contains our table , bar chart , and network graph Global Styles and Variables \u00b6 In order to create a better multi-page app, we must first determine what content is shared across our multiple pages . We can declare these as global variables and have them unchanged upon navigating across pages. This way, our dashboard is more responsive as there is less to recompute upon each refresh . NOTE: At the moment, we don't have any shared content . However, this will change in future chapters! The Two Pages \u00b6 Now, we can create content variables for each of the two pages, stored below: generalPage = html . Div ([ dbc . Row ( titleCard , justify = \"center\" ), dbc . Row ( statsListGroup , justify = \"center\" ), html . Br (), dbc . Row ([ pieChartCard , scatterChartCard , ], justify = \"center\" ), ]) prescriberPage = html . Div ([ dbc . Row ([ dbc . Col ( tableCard ), dbc . Col ([ barCard , networkCard ], ) ], justify = 'center' ), ]) As seen, we just split the two pages where our original html.Hr() used to be! Now, we can add in the simple callback to load the correct page. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def display_page ( pathname ): if pathname == \"/\" : return generalPage elif pathname == \"/pre\" : return prescriberPage return dbc . Jumbotron ( [ html . H1 ( \"404: Not found\" , className = \"text-danger\" ), html . Hr (), html . P ( \"Uh oh! Unfortunately, the pathname {} was unable to be recognised...\" . format ( pathname )), ] ) app . run_server ( mode = 'external' ) And here's our dashboard, now with multiple pages! Dash Links \u00b6 However, having to manually enter the url for each specific page is not a good practice . Luckily, Dash provides several methods for navigating through pages. One of the most common components used for navigation is the Dash Link , which allows users to select which page they wish to reach. Let's take a look! We simply modify our app.layout to include two dcc.Link() 's. These are essentially Dash's equivalent of hyperlinks . No additional callbacks needed, these links function perfectly by themselves! app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), dbc . Row ([ dbc . Col ( dcc . Link ( \"Go to Home\" , href = '/' ), width = 1 ), dbc . Col ( dcc . Link ( 'Go to Prescribers' , href = '/pre' ), width = 2 ), ], justify = \"start\" , ), html . Div ( id = 'page-content' ) ]) By including the dbc.Row() with our two links outside of html.Div(id='page-content') , it remains static and present in the same location on all pages . However, this may not always be needed. For example, we don't need to the \"Go to Prescribers\" hyperlink when we are already on that page. To overcome this, we turn to our layout variables . By adding one dcc.Link in each of our pages, we can remove any unnecessary overlap . generalPage = html . Center ( html . Div ([ dbc . Col ( dcc . Link ( \"Go to Prescribers\" , href = '/pre' ), width = 2 ), dbc . Row ( titleCard , justify = \"center\" ), dbc . Row ( statsListGroup , justify = \"center\" ), html . Br (), dbc . Row ([ pieChartCard , scatterChartCard , ], justify = \"center\" ), ])) prescriberPage = html . Center ( html . Div ([ dbc . Col ( dcc . Link ( \"Go to Home\" , href = '/' ), width = 1 ), prescriberTitleCard , dbc . Row ([ dbc . Col ( tableCard ), dbc . Col ([ barCard , networkCard ], ) ], justify = 'center' ), ])) Once again, no callbacks needed! This functions perfectly using the app.layout from before. The first monster paused, \"This is how one can may piece together a multi-page app . However, it is essential to learn more about callbacks before being able to continue adding intricate functionalities to our dashboard.\" The second monster started jumping up and down, \"Oooh! Oooh! Is it my turn to explain now? I love callbacks!!\" The first monster sighed, and beckoned at its companion to begin... All code segments from this chapter can be found in this Colab Notebook . Feel free to follow along! \u21a9 Everything we've installed so far (prerequistes for next section): ! pip install - q pyTigerGraph import pyTigerGraph as tg TG_SUBDOMAIN = 'healthcare-dash' TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio Link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph conn = tg . TigerGraphConnection ( host = TG_HOST , graphname = TG_GRAPHNAME , username = TG_USERNAME , password = TG_PASSWORD , beta = True ) conn . apiToken = conn . getToken ( conn . createSecret ()) ! pip install - q jupyter - dash import dash import dash_html_components as html from jupyter_dash import JupyterDash import plotly.express as px import pandas as pd import plotly.graph_objects as go import dash_core_components as dcc ! pip install dash - bootstrap - components import dash_bootstrap_components as dbc ! pip install dash - cytoscape import dash_cytoscape as cyto \u21a9","title":"Ch 07 - The Multi-Page Monsters"},{"location":"learn/07_multi-monster/#the-multi-page-monsters","text":"After waving goodbye to our mysterious friend, we trudge onwards through the TigerGraph tundra, hoping to find the elusive elysium of elements described by the TigerGraph protector . As we make our way in the harsh winds, we hear a roar echoing throughout the valley. Loud stomps grow closer and we clutch our laptop, trembling with panic. A booming voice pierces through the bitter cold: \u201cAhh, we hear you\u2019re on a quest! Well lucky for you, we can help!\u201d Turning around, we see two strange figures beaming at us. \u201cWe\u2019re the Multi-Page monsters, and we have a way to organize your cluttered dashboards! \u201d In an attempt to reassure our quizzical expressions, they laughed. \u201cDon\u2019t worry! It\u2019s quite easy to clean up your dashboard by organizing it into multiple pages\u2026 \u201d Multi-Page Monster Notes 01","title":"The Multi-Page Monsters \ud83e\udd96"},{"location":"learn/07_multi-monster/#a-simple-multi-page-app","text":"The first step in creating multiple pages for our Dash app is to separate our content into multiple distinct variables or elements . For example, if we wish to create three pages, we can perform this by create three content variables : page1_content = html . Div ( html . H1 ( \"This is Pg. 1!\" )) page2_content = html . Div ( html . H1 ( html . B ( \"This is Pg. 2!\" ))) page3_content = html . Div ( html . H1 ( html . I ( \"This is Pg. 3!\" ))) Next, we must change our app layout to reflect this: app = JupyterDash ( __name__ ) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def display_page ( pathname ): if pathname == \"/\" : return page1_content elif pathname == \"/page2\" : return page2_content elif pathname == \"/page3\" : return page3_content app . run_server ( mode = 'external' ) And now, running the app will only show us the first page! However, entering the proper link will take us to pages 2 and 3. How are we doing this? Well, using a simple callback... As defined below the app layout, the input is simply the pathname of the current page . The output is the page-content, an html.Div element that we've defined in our app layout. This is where the importance of element id's comes into play! For any element that will be updated via a callback, an id is needed. @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) Breaking down the function display_page() , we simply compare the pathname to several predefined, valid pages. Then, the respective content is returned. This content is stored and displayed in html.Div(id='page-content') . NOTE: We will cover callbacks in the next chapter! This is merely an intro used to navigate through pages . Yet entering any other link will lead to a blank page... uh oh! We need to make sure that the user doesn't accidentally access any unauthorized or unbuilt pages . They should only be able to access the extension links that we've provided. In order to secure this, we can use Dash Bootstrap...","title":"A Simple Multi-Page App"},{"location":"learn/07_multi-monster/#dash-jumbotron","text":"The Dash Jumbotron is a Bootstrap component that is used to showcase important messages . In this case, we'll use it to display a \"404 error message\" whenever the user reaches an unauthorized page . Adding this jumbotron is quite simple. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def display_page ( pathname ): if pathname == \"/\" : return page1_content elif pathname == \"/page2\" : return page2_content elif pathname == \"/page3\" : return page3_content return dbc . Jumbotron ( [ html . H1 ( \"404: Not found\" , className = \"text-danger\" ), html . Hr (), html . P ( \"Uh oh! Unfortunately, the pathname {} was unable to be recognised...\" . format ( pathname )), ] ) app . run_server ( mode = 'external' ) And just like that, we've put together a simple multi-page app! In order to modify each page, we can simply change the html.Div() element to contain our page's components. To add pages, we can extend our if/else. Yet as of now, users can only navigate by entering each page's link. \"This isn't the best way to navigate across pages... Users shouldn't have to manually enter the link for each page they wish to reach. Let's take this example one step further...\" Multi-Page Monster Notes 02","title":"Dash Jumbotron"},{"location":"learn/07_multi-monster/#comprehensive-multi-page-app","text":"Let's use our Healthcare Dashboard and partition it into two pages . General Page - Contains our title , listgroups , pie , and scatter plot Prescriber Page - contains our table , bar chart , and network graph","title":"Comprehensive Multi-Page App"},{"location":"learn/07_multi-monster/#global-styles-and-variables","text":"In order to create a better multi-page app, we must first determine what content is shared across our multiple pages . We can declare these as global variables and have them unchanged upon navigating across pages. This way, our dashboard is more responsive as there is less to recompute upon each refresh . NOTE: At the moment, we don't have any shared content . However, this will change in future chapters!","title":"Global Styles and Variables"},{"location":"learn/07_multi-monster/#the-two-pages","text":"Now, we can create content variables for each of the two pages, stored below: generalPage = html . Div ([ dbc . Row ( titleCard , justify = \"center\" ), dbc . Row ( statsListGroup , justify = \"center\" ), html . Br (), dbc . Row ([ pieChartCard , scatterChartCard , ], justify = \"center\" ), ]) prescriberPage = html . Div ([ dbc . Row ([ dbc . Col ( tableCard ), dbc . Col ([ barCard , networkCard ], ) ], justify = 'center' ), ]) As seen, we just split the two pages where our original html.Hr() used to be! Now, we can add in the simple callback to load the correct page. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def display_page ( pathname ): if pathname == \"/\" : return generalPage elif pathname == \"/pre\" : return prescriberPage return dbc . Jumbotron ( [ html . H1 ( \"404: Not found\" , className = \"text-danger\" ), html . Hr (), html . P ( \"Uh oh! Unfortunately, the pathname {} was unable to be recognised...\" . format ( pathname )), ] ) app . run_server ( mode = 'external' ) And here's our dashboard, now with multiple pages!","title":"The Two Pages"},{"location":"learn/07_multi-monster/#dash-links","text":"However, having to manually enter the url for each specific page is not a good practice . Luckily, Dash provides several methods for navigating through pages. One of the most common components used for navigation is the Dash Link , which allows users to select which page they wish to reach. Let's take a look! We simply modify our app.layout to include two dcc.Link() 's. These are essentially Dash's equivalent of hyperlinks . No additional callbacks needed, these links function perfectly by themselves! app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), dbc . Row ([ dbc . Col ( dcc . Link ( \"Go to Home\" , href = '/' ), width = 1 ), dbc . Col ( dcc . Link ( 'Go to Prescribers' , href = '/pre' ), width = 2 ), ], justify = \"start\" , ), html . Div ( id = 'page-content' ) ]) By including the dbc.Row() with our two links outside of html.Div(id='page-content') , it remains static and present in the same location on all pages . However, this may not always be needed. For example, we don't need to the \"Go to Prescribers\" hyperlink when we are already on that page. To overcome this, we turn to our layout variables . By adding one dcc.Link in each of our pages, we can remove any unnecessary overlap . generalPage = html . Center ( html . Div ([ dbc . Col ( dcc . Link ( \"Go to Prescribers\" , href = '/pre' ), width = 2 ), dbc . Row ( titleCard , justify = \"center\" ), dbc . Row ( statsListGroup , justify = \"center\" ), html . Br (), dbc . Row ([ pieChartCard , scatterChartCard , ], justify = \"center\" ), ])) prescriberPage = html . Center ( html . Div ([ dbc . Col ( dcc . Link ( \"Go to Home\" , href = '/' ), width = 1 ), prescriberTitleCard , dbc . Row ([ dbc . Col ( tableCard ), dbc . Col ([ barCard , networkCard ], ) ], justify = 'center' ), ])) Once again, no callbacks needed! This functions perfectly using the app.layout from before. The first monster paused, \"This is how one can may piece together a multi-page app . However, it is essential to learn more about callbacks before being able to continue adding intricate functionalities to our dashboard.\" The second monster started jumping up and down, \"Oooh! Oooh! Is it my turn to explain now? I love callbacks!!\" The first monster sighed, and beckoned at its companion to begin... All code segments from this chapter can be found in this Colab Notebook . Feel free to follow along! \u21a9 Everything we've installed so far (prerequistes for next section): ! pip install - q pyTigerGraph import pyTigerGraph as tg TG_SUBDOMAIN = 'healthcare-dash' TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio Link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph conn = tg . TigerGraphConnection ( host = TG_HOST , graphname = TG_GRAPHNAME , username = TG_USERNAME , password = TG_PASSWORD , beta = True ) conn . apiToken = conn . getToken ( conn . createSecret ()) ! pip install - q jupyter - dash import dash import dash_html_components as html from jupyter_dash import JupyterDash import plotly.express as px import pandas as pd import plotly.graph_objects as go import dash_core_components as dcc ! pip install dash - bootstrap - components import dash_bootstrap_components as dbc ! pip install dash - cytoscape import dash_cytoscape as cyto \u21a9","title":"Dash Links"},{"location":"learn/08_callback-cliff/","text":"Confronted by Callbacks \ud83e\udd95 \u00b6 The second monster grinned, \"Callbacks are essential to make one's dashboard dynamic! They allow the user to interact with one's page. Luckily for you travelers, I'm quite the expert when it comes to this area.\" The first monster groaned and rolled his eyes, \"Yes yes, quite the professional. Can you just get on with it?\" The second monster laughed. Tracing words into the snow, he began to explain... Callback Notes 01 A Simple Callback \u00b6 Callbacks are functions that are called automatically by Dash everytime a component's property changes . They allow for dynamic pages. We had taken a look at a simple callback in the last chapter, but let's flesh it out further . For reference, here's the code segment from before. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def display_page ( pathname ): if pathname == \"/\" : return generalPage elif pathname == \"/pre\" : return prescriberPage return dbc . Jumbotron ( [ html . H1 ( \"404: Not found\" , className = \"text-danger\" ), html . Hr (), html . P ( \"Uh oh! Unfortunately, the pathname {} was unable to be recognised...\" . format ( pathname )), ] ) app . run_server ( mode = 'external' ) As seen, our callback is introduced with the @ symbol It can take a list of Output elements as well as a list of Input elements In our example, it takes in the input with the ID 'url' . This component is dcc.Location(id=url, refresh=False) , which is a Dash element that simply keeps track of the url of the current page . In our example, the output element is html.Div(id='page-content') , which is just an empty placeholder . It's contents are currently empty, but replaced by the callback upon each url change That wasn't too bad to explain! As seen above, callbacks consist of: Header - specified by @app.callback() , followed immediately by a... Function - can be titled anything , takes in the callback input as a parameter . Let's take a look at a more complicated input! Introducing dbc.Button() \u00b6 Instead of just the url, what if we wanted to add more aesthetic functionality directly onto our dash page. One way to do this is with dbc.Button() element, which allows for cleaner clickability . This bootstrap component is quite easy to set up. generalPage = html . Center ( html . Div ([ dbc . Col ( dbc . Button ( \"Switch Pages\" , id = \"switch-button\" , className = \"mr-2\" , n_clicks = 0 , color = \"info\" , href = \"/pre\" ), width = 2 ), dbc . Row ( titleCard , justify = \"center\" ), dbc . Row ( statsListGroup , justify = \"center\" ), html . Br (), dbc . Row ([ pieChartCard , scatterChartCard , ], justify = \"center\" ), ])) prescriberPage = html . Center ( html . Div ([ dbc . Col ( dbc . Button ( \"Switch Pages\" , id = \"switch-button\" , className = \"mr-2\" , n_clicks = 0 , color = \"info\" , href = \"/\" ), width = 2 ), prescriberTitleCard , dbc . Row ([ dbc . Col ( tableCard ), dbc . Col ([ barCard , networkCard ], ) ], justify = 'center' ), ])) And that's it. No callbacks needed, at least for now . However, the button does have several other functionalities beyond serving as a glorified hyperlink. It can keep track of the number of clicks , serve as a method to download files , and be customized to change on click . NOTE: For more information on Buttons, feel free to check out the following resources: dbc.Button() Introducing dcc.Input() \u00b6 For more intricate input, we turn to dcc.Input() . This Dash Core Component supports several types of text entry , including: \"text\" - regular text, any character goes! \"number\" - numbers and hyphens (for negative) signs only \"password\" - each entered character will be shown as a black dot \"email\" - will ensure that entered text is a valid email format \"tel\" - will ensure that entered text is a valid telephone format This element is quite powerful, and can easily be incorporated as shown in this example: app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dcc . Input ( id = \"example-input\" , type = \"number\" , placeholder = \"Please enter a number.\" ), html . H1 ( \"Your number squared is:\" ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'example-input' , 'value' )]) def display_page ( value ): if value is None : return html . H3 ( \"N/A\" ) return html . H3 ( value * value ) app . run_server ( mode = 'external' ) Taking a closer look, we see that the id of the dcc.Input() is used in our callback. It's value attribute is passed in as the sole parameter of our callback function . Additionally, the input type has been specified to be a number. Additionally, it's good practice to ensure that regardless of the input, the callback returns some acceptable value ! Even if it's an empty html.Div() element, it's good practice to make sure that there are no edge cases. NOTE: Fore more information on input, feel free to check out the following resources: dcc.Input \"Now, it's time to take these callbacks and apply them to your dashboard !\" Callback Notes 02 Currently, the Prescribers page is static, fixed with the value \"pre-78\" . Let's change this so that users may able to search for any valid prescriber within the Graph . First, we need a list of all valid options... Acceptible Prescribers (Query) \u00b6 Using our knowledge from the TigerGraph Tundra , we can write a query that returns all Prescriber IDs. AllPrescribers = '''USE GRAPH MyGraph CREATE QUERY AllPrescribers() FOR GRAPH MyGraph { ListAccum<Vertex<Prescriber>> @@allPrescribers; start = {Prescriber.*}; allPres = SELECT p FROM start:p ACCUM @@allPrescribers += p; PRINT @@allPrescribers as allPrescribers; } INSTALL QUERY AllPrescribers''' print ( conn . gsql ( AllPrescribers , options = [])) Running this query gives us the following output, Now, we can package it into the appropriate format as follows. def getPresList (): pres = conn . runInstalledQuery ( \"AllPrescribers\" )[ 0 ][ 'allPrescribers' ] return [{ 'label' : x , 'value' : x } for x in pres ] Awesome! The question remains, how do we incorporate this list into our search? Although dcc.Input() can support this sort of wordbank in searches, for a simpler implementation we will utilize its close relative, dcc.Dropdown() . Let's take a closer look... Using dcc.Dropdown() \u00b6 Dash's Dropdown allows users to select values from a given list of possible options . This component is very powerful, allowing for multi-value selection , the ability to disable certain options , the ability to clear certain options , and the real-time updating of options based on the user's search terms. For this example, we will be using a basic implementation. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) presList = getPresList () app . layout = html . Div ([ dbc . Col ( dcc . Dropdown ( id = \"example-input\" , placeholder = \"Enter a prescriber...\" , options = presList ), width = 3 ), html . H1 ( \"Your chosen prescriber:\" ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'example-input' , 'value' )]) def display_page ( value ): if value is None : return html . H3 ( \"N/A\" ) return html . H3 ( value + \" is valid!\" ) app . run_server ( mode = 'external' ) Breaking it down, we specify the id , placeholder text , and list of options for our Dropdown element. Then, within our callback, we simply display the chosen value as well as some accompanying text. Here's the result. See, that wasn't so bad! Simple, yet quite powerful. NOTE: For more information on Dropdown, feel free to check out the following resources: dcc.Dropdown() Putting it Together \u00b6 Let's incorporate this search into our Prescribers Page. dropdown = dbc . Col ( dcc . Dropdown ( id = \"pres-dropdown\" , placeholder = \"Enter a prescriber...\" , options = getPresList () ), width = 3 ) def prescriberPage ( pres ): prescriberTitleCard , tableCard , barCard , networkCard = getPrescriberInfo ( pres ) page = html . Center ( html . Div ([ dbc . Row ([ dropdown , dbc . Col ( dbc . Button ( \"Switch Pages\" , id = \"switch-button\" , className = \"mr-2\" , n_clicks = 0 , color = \"info\" , href = \"/\" ), width = 2 ), ], justify = 'center' ), prescriberTitleCard , dbc . Row ([ dbc . Col ( tableCard ), dbc . Col ([ barCard , networkCard ], ) ], justify = 'center' ), ])) return page First, we create our dropdown component. Next, we create a parameterized function that returns the prescriber page for a given prescriber . Within this function, we incorporate the dropdown component (in the first dbc.Row() ). Now, we need to create our app and its callbacks. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ], suppress_callback_exceptions = True ) presPage = html . Div ( prescriberPage ( \"pre78\" ), id = 'pres-content' ) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def display_page ( pathname ): if pathname == \"/\" : return generalPage elif pathname == \"/pre\" : return presPage return dbc . Jumbotron ( [ html . H1 ( \"404: Not found\" , className = \"text-danger\" ), html . Hr (), html . P ( \"Uh oh! Unfortunately, the pathname {} was unable to be recognised...\" . format ( pathname )), ] ) @app . callback ( dash . dependencies . Output ( 'pres-content' , 'children' ), [ dash . dependencies . Input ( 'pres-dropdown' , 'value' )]) def update_pres ( value ): if value is not None : return prescriberPage ( value ) return prescriberPage ( \"pre78\" ) # Our default value app . run_server ( mode = 'external' ) Several changes from before, so let's take a closer look! First, we create a new variable to hold the contents of our prescriber page. Named presPage , this element contains a unique id and is set to store the default prescriber page value using Prescriber #78 . Next, we leave our app.layout() and first callback untouched. These allow for navigation. In order to utilize the value of the dropdown, we write a new callback . This time, it's input is the pres-dropdown component. This callback function simply returns the Prescriber Page with the given prescriber . Note that we've had to add suppress_callback_exceptions=True in order to prevent warning pop-ups. This is because when we are on the general page, the dropdown element has not been loaded yet. Although this is not an issue, Dash registers this as a warning! NOTE: Dashboards can have as many callbacks as desired. Although each callback can take unlimited inputs, each output can only be utilized once in a callback . For example, one cannot have two callbacks that both output page-content . This will return an error when loading the Dash app. This is why dash.dependencies.Output() is simply one element, while dash.dependencies.Input() is within a list. And with that, we have the first verison of our dynamic dashboard! The second monster grins, \"Yay! See, I told you I knew a lot about callbacks! If you want to learn more, continue onwards past the Tundra. I've heard tales of a great Elysium of Elements in that direction. Maybe you can learn more about dashboards there?\" Beaming with pride, we wave goodbye and head off into the horizon. All code segments from this chapter can be found in this Colab Notebook . Feel free to follow along! \u21a9 Everything we've installed so far (prerequistes for next section): ! pip install - q pyTigerGraph import pyTigerGraph as tg TG_SUBDOMAIN = 'healthcare-dash' TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio Link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph conn = tg . TigerGraphConnection ( host = TG_HOST , graphname = TG_GRAPHNAME , username = TG_USERNAME , password = TG_PASSWORD , beta = True ) conn . apiToken = conn . getToken ( conn . createSecret ()) ! pip install - q jupyter - dash import dash import dash_html_components as html from jupyter_dash import JupyterDash import plotly.express as px import pandas as pd import plotly.graph_objects as go import dash_core_components as dcc ! pip install dash - bootstrap - components import dash_bootstrap_components as dbc ! pip install dash - cytoscape import dash_cytoscape as cyto \u21a9","title":"Ch 08 - Confronted by Callbacks"},{"location":"learn/08_callback-cliff/#confronted-by-callbacks","text":"The second monster grinned, \"Callbacks are essential to make one's dashboard dynamic! They allow the user to interact with one's page. Luckily for you travelers, I'm quite the expert when it comes to this area.\" The first monster groaned and rolled his eyes, \"Yes yes, quite the professional. Can you just get on with it?\" The second monster laughed. Tracing words into the snow, he began to explain... Callback Notes 01","title":"Confronted by Callbacks \ud83e\udd95"},{"location":"learn/08_callback-cliff/#a-simple-callback","text":"Callbacks are functions that are called automatically by Dash everytime a component's property changes . They allow for dynamic pages. We had taken a look at a simple callback in the last chapter, but let's flesh it out further . For reference, here's the code segment from before. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def display_page ( pathname ): if pathname == \"/\" : return generalPage elif pathname == \"/pre\" : return prescriberPage return dbc . Jumbotron ( [ html . H1 ( \"404: Not found\" , className = \"text-danger\" ), html . Hr (), html . P ( \"Uh oh! Unfortunately, the pathname {} was unable to be recognised...\" . format ( pathname )), ] ) app . run_server ( mode = 'external' ) As seen, our callback is introduced with the @ symbol It can take a list of Output elements as well as a list of Input elements In our example, it takes in the input with the ID 'url' . This component is dcc.Location(id=url, refresh=False) , which is a Dash element that simply keeps track of the url of the current page . In our example, the output element is html.Div(id='page-content') , which is just an empty placeholder . It's contents are currently empty, but replaced by the callback upon each url change That wasn't too bad to explain! As seen above, callbacks consist of: Header - specified by @app.callback() , followed immediately by a... Function - can be titled anything , takes in the callback input as a parameter . Let's take a look at a more complicated input!","title":"A Simple Callback"},{"location":"learn/08_callback-cliff/#introducing-dbcbutton","text":"Instead of just the url, what if we wanted to add more aesthetic functionality directly onto our dash page. One way to do this is with dbc.Button() element, which allows for cleaner clickability . This bootstrap component is quite easy to set up. generalPage = html . Center ( html . Div ([ dbc . Col ( dbc . Button ( \"Switch Pages\" , id = \"switch-button\" , className = \"mr-2\" , n_clicks = 0 , color = \"info\" , href = \"/pre\" ), width = 2 ), dbc . Row ( titleCard , justify = \"center\" ), dbc . Row ( statsListGroup , justify = \"center\" ), html . Br (), dbc . Row ([ pieChartCard , scatterChartCard , ], justify = \"center\" ), ])) prescriberPage = html . Center ( html . Div ([ dbc . Col ( dbc . Button ( \"Switch Pages\" , id = \"switch-button\" , className = \"mr-2\" , n_clicks = 0 , color = \"info\" , href = \"/\" ), width = 2 ), prescriberTitleCard , dbc . Row ([ dbc . Col ( tableCard ), dbc . Col ([ barCard , networkCard ], ) ], justify = 'center' ), ])) And that's it. No callbacks needed, at least for now . However, the button does have several other functionalities beyond serving as a glorified hyperlink. It can keep track of the number of clicks , serve as a method to download files , and be customized to change on click . NOTE: For more information on Buttons, feel free to check out the following resources: dbc.Button()","title":"Introducing dbc.Button()"},{"location":"learn/08_callback-cliff/#introducing-dccinput","text":"For more intricate input, we turn to dcc.Input() . This Dash Core Component supports several types of text entry , including: \"text\" - regular text, any character goes! \"number\" - numbers and hyphens (for negative) signs only \"password\" - each entered character will be shown as a black dot \"email\" - will ensure that entered text is a valid email format \"tel\" - will ensure that entered text is a valid telephone format This element is quite powerful, and can easily be incorporated as shown in this example: app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dcc . Input ( id = \"example-input\" , type = \"number\" , placeholder = \"Please enter a number.\" ), html . H1 ( \"Your number squared is:\" ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'example-input' , 'value' )]) def display_page ( value ): if value is None : return html . H3 ( \"N/A\" ) return html . H3 ( value * value ) app . run_server ( mode = 'external' ) Taking a closer look, we see that the id of the dcc.Input() is used in our callback. It's value attribute is passed in as the sole parameter of our callback function . Additionally, the input type has been specified to be a number. Additionally, it's good practice to ensure that regardless of the input, the callback returns some acceptable value ! Even if it's an empty html.Div() element, it's good practice to make sure that there are no edge cases. NOTE: Fore more information on input, feel free to check out the following resources: dcc.Input \"Now, it's time to take these callbacks and apply them to your dashboard !\" Callback Notes 02 Currently, the Prescribers page is static, fixed with the value \"pre-78\" . Let's change this so that users may able to search for any valid prescriber within the Graph . First, we need a list of all valid options...","title":"Introducing dcc.Input()"},{"location":"learn/08_callback-cliff/#acceptible-prescribers-query","text":"Using our knowledge from the TigerGraph Tundra , we can write a query that returns all Prescriber IDs. AllPrescribers = '''USE GRAPH MyGraph CREATE QUERY AllPrescribers() FOR GRAPH MyGraph { ListAccum<Vertex<Prescriber>> @@allPrescribers; start = {Prescriber.*}; allPres = SELECT p FROM start:p ACCUM @@allPrescribers += p; PRINT @@allPrescribers as allPrescribers; } INSTALL QUERY AllPrescribers''' print ( conn . gsql ( AllPrescribers , options = [])) Running this query gives us the following output, Now, we can package it into the appropriate format as follows. def getPresList (): pres = conn . runInstalledQuery ( \"AllPrescribers\" )[ 0 ][ 'allPrescribers' ] return [{ 'label' : x , 'value' : x } for x in pres ] Awesome! The question remains, how do we incorporate this list into our search? Although dcc.Input() can support this sort of wordbank in searches, for a simpler implementation we will utilize its close relative, dcc.Dropdown() . Let's take a closer look...","title":"Acceptible Prescribers (Query)"},{"location":"learn/08_callback-cliff/#using-dccdropdown","text":"Dash's Dropdown allows users to select values from a given list of possible options . This component is very powerful, allowing for multi-value selection , the ability to disable certain options , the ability to clear certain options , and the real-time updating of options based on the user's search terms. For this example, we will be using a basic implementation. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) presList = getPresList () app . layout = html . Div ([ dbc . Col ( dcc . Dropdown ( id = \"example-input\" , placeholder = \"Enter a prescriber...\" , options = presList ), width = 3 ), html . H1 ( \"Your chosen prescriber:\" ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'example-input' , 'value' )]) def display_page ( value ): if value is None : return html . H3 ( \"N/A\" ) return html . H3 ( value + \" is valid!\" ) app . run_server ( mode = 'external' ) Breaking it down, we specify the id , placeholder text , and list of options for our Dropdown element. Then, within our callback, we simply display the chosen value as well as some accompanying text. Here's the result. See, that wasn't so bad! Simple, yet quite powerful. NOTE: For more information on Dropdown, feel free to check out the following resources: dcc.Dropdown()","title":"Using dcc.Dropdown()"},{"location":"learn/08_callback-cliff/#putting-it-together","text":"Let's incorporate this search into our Prescribers Page. dropdown = dbc . Col ( dcc . Dropdown ( id = \"pres-dropdown\" , placeholder = \"Enter a prescriber...\" , options = getPresList () ), width = 3 ) def prescriberPage ( pres ): prescriberTitleCard , tableCard , barCard , networkCard = getPrescriberInfo ( pres ) page = html . Center ( html . Div ([ dbc . Row ([ dropdown , dbc . Col ( dbc . Button ( \"Switch Pages\" , id = \"switch-button\" , className = \"mr-2\" , n_clicks = 0 , color = \"info\" , href = \"/\" ), width = 2 ), ], justify = 'center' ), prescriberTitleCard , dbc . Row ([ dbc . Col ( tableCard ), dbc . Col ([ barCard , networkCard ], ) ], justify = 'center' ), ])) return page First, we create our dropdown component. Next, we create a parameterized function that returns the prescriber page for a given prescriber . Within this function, we incorporate the dropdown component (in the first dbc.Row() ). Now, we need to create our app and its callbacks. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ], suppress_callback_exceptions = True ) presPage = html . Div ( prescriberPage ( \"pre78\" ), id = 'pres-content' ) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def display_page ( pathname ): if pathname == \"/\" : return generalPage elif pathname == \"/pre\" : return presPage return dbc . Jumbotron ( [ html . H1 ( \"404: Not found\" , className = \"text-danger\" ), html . Hr (), html . P ( \"Uh oh! Unfortunately, the pathname {} was unable to be recognised...\" . format ( pathname )), ] ) @app . callback ( dash . dependencies . Output ( 'pres-content' , 'children' ), [ dash . dependencies . Input ( 'pres-dropdown' , 'value' )]) def update_pres ( value ): if value is not None : return prescriberPage ( value ) return prescriberPage ( \"pre78\" ) # Our default value app . run_server ( mode = 'external' ) Several changes from before, so let's take a closer look! First, we create a new variable to hold the contents of our prescriber page. Named presPage , this element contains a unique id and is set to store the default prescriber page value using Prescriber #78 . Next, we leave our app.layout() and first callback untouched. These allow for navigation. In order to utilize the value of the dropdown, we write a new callback . This time, it's input is the pres-dropdown component. This callback function simply returns the Prescriber Page with the given prescriber . Note that we've had to add suppress_callback_exceptions=True in order to prevent warning pop-ups. This is because when we are on the general page, the dropdown element has not been loaded yet. Although this is not an issue, Dash registers this as a warning! NOTE: Dashboards can have as many callbacks as desired. Although each callback can take unlimited inputs, each output can only be utilized once in a callback . For example, one cannot have two callbacks that both output page-content . This will return an error when loading the Dash app. This is why dash.dependencies.Output() is simply one element, while dash.dependencies.Input() is within a list. And with that, we have the first verison of our dynamic dashboard! The second monster grins, \"Yay! See, I told you I knew a lot about callbacks! If you want to learn more, continue onwards past the Tundra. I've heard tales of a great Elysium of Elements in that direction. Maybe you can learn more about dashboards there?\" Beaming with pride, we wave goodbye and head off into the horizon. All code segments from this chapter can be found in this Colab Notebook . Feel free to follow along! \u21a9 Everything we've installed so far (prerequistes for next section): ! pip install - q pyTigerGraph import pyTigerGraph as tg TG_SUBDOMAIN = 'healthcare-dash' TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio Link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph conn = tg . TigerGraphConnection ( host = TG_HOST , graphname = TG_GRAPHNAME , username = TG_USERNAME , password = TG_PASSWORD , beta = True ) conn . apiToken = conn . getToken ( conn . createSecret ()) ! pip install - q jupyter - dash import dash import dash_html_components as html from jupyter_dash import JupyterDash import plotly.express as px import pandas as pd import plotly.graph_objects as go import dash_core_components as dcc ! pip install dash - bootstrap - components import dash_bootstrap_components as dbc ! pip install dash - cytoscape import dash_cytoscape as cyto \u21a9","title":"Putting it Together"},{"location":"learn/09_northern-navbars/","text":"Northern Navbars \u26c4\ufe0f \u00b6 As we cross the Tundra, the snow begins to melt, leaving behind vast expanses of dirt and vegetation. Soon, a strange sight crosses our eye. In the distance, there appears to be a snowman meandering slowly through the pine trees . Upon seeing us, it turns and waves. \"Welcome, I'm here to guide you along your quest! Follow me, and I'll teach you what you need to know. As your navigator, it's only fitting that we discuss the importance of navbars! \" Stranger and stranger! Pulling out our laptop, we began to listen... Navbar Notes 01 In the last two chapters, we learned how to navigate across the multiple pages of our dashboard. However, our current system is a little bit clunky. One possible way to fix this is by utilizing a nabvar... Creating Navbar Layout \u00b6 Adding a navbar to our dashboard allows for easier navigation, providing a fixed, non-changing area of our app which can be used to access other pages. In the previous chapter, we implemented a dropdown to navigate across pages. A navbar is as simple as wrapping this dropdown element into a dbc.Navbar() component ! Let's start with a simple example using dbc.Navbarsimple() : navbar = dbc . NavbarSimple ([ dbc . NavItem ( dbc . NavLink ( \"General\" , href = \"/\" )), dbc . DropdownMenu ( children = [ dbc . DropdownMenuItem ( \"More pages\" , header = True ), dbc . DropdownMenuItem ( \"Prescribers\" , href = \"/pre\" ), dbc . DropdownMenuItem ( \"TigerGraph Cloud\" , href = \"https://tgcloud.io/\" ), ], nav = True , in_navbar = True , label = \"More\" , ), ], brand = \"Example Navbar\" , brand_href = \"/\" , color = \"info\" , dark = True , ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ], suppress_callback_exceptions = True ) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), navbar , html . Center ( html . H1 ( \"Wow, look at this amazing navbar!\" )) ]) app . run_server ( mode = 'external' ) Let's break it down! First, we add a dbc.NavItem() which contains a link to the homepage . As a result, the href tag is simply a / . After this, we add our dbc.DropdownMenu() , very similar to dbc.Dropdown() from earlier. This dropdown contains a header, titled \"More Pages\" . Next, it contains a link to our Prescribers page as well as a link to the TigerGraph Cloud Portal . These links are added via dbc.DropdownMenuItem() . With the brand attribute, we can title our navbar and change its home link. Finally, we can modify the colors and styling of the navbar. Although we haven't included the pages themselves in this example, clicking the menu items will update the url. Let's try another example using navbars! The snowman excitedly exclaimed, \"That dropdown you created for your Prescribers page ... let's create a Navbar for that!\" Navbar Notes 02 Adding Navbar Elements \u00b6 Let's add our dropdown to our navbar, and our navbar to our Prescriber Page. dropdown = dbc . Row ( dbc . Col ( dcc . Dropdown ( id = \"pres-dropdown\" , placeholder = \"Enter a prescriber...\" , options = getPresList (), style = { 'width' : '400px' } ), width = 12 , align = \"end\" ), style = { \"margin-left\" : \"600px\" }) navbar = dbc . Navbar ( [ html . A ( # Use row and col to control vertical alignment of logo / brand dbc . Row ( [ dbc . Col ( dbc . NavbarBrand ( \"Healthcare Dashboard - TigerGraph's Dash Class Example\" , className = \"ml-2\" )), ], align = \"center\" , no_gutters = True , ), href = \"/\" , ), dropdown , ], color = \"dark\" , dark = True , ) def prescriberPage ( pres ): prescriberTitleCard , tableCard , barCard , networkCard = getPrescriberInfo ( pres ) page = html . Center ( html . Div ([ navbar , prescriberTitleCard , dbc . Row ([ dbc . Col ( tableCard ), dbc . Col ([ barCard , networkCard ], ) ], justify = 'center' ), ])) return page As seen, the navbar simply contains a hyperlinked header (that takes one back the main page) and a dropdown to enter prescriber information . No additional changes need to be made to the callback function. Here's the result! That helps make the Prescriber Page look a lot better! There's a few other options for Navbars as well, although we won't implement them for now: NavbarSimple - according to Dash, \"simpler, but less flexible\" Navbar - more customizability , but more intricate to set up NavbarBrand - contains a brand name (meant essentially for text) NavbarToggler - essentially a button (tracks clicks, times) NOTE: For more information on navbars, feel free to check out the following resources: dbc.Navbar() As the snowman finishes explaining to us, the dirt under our feet begins to slowly turn into sand. \"This is it, the end of the Tundra and the beginning of the Desert. Continue through here, and you'll find the Elysium of Elements. Beyond that should lie your final destination, the last chapter. \" Before wandering away, the snowman reaches into his pocket and pulls out a sleeping gecko. \"This is Geronimo. Keep him in your pocket and he will help you.\" As we cradle the gecko in our palms, he stirs and begins to slowly awaken. All code segments from this chapter can be found in this Colab Notebook . Feel free to follow along! \u21a9 Everything we've installed so far (prerequistes for next section): ! pip install - q pyTigerGraph import pyTigerGraph as tg TG_SUBDOMAIN = 'healthcare-dash' TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio Link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph conn = tg . TigerGraphConnection ( host = TG_HOST , graphname = TG_GRAPHNAME , username = TG_USERNAME , password = TG_PASSWORD , beta = True ) conn . apiToken = conn . getToken ( conn . createSecret ()) ! pip install - q jupyter - dash import dash import dash_html_components as html from jupyter_dash import JupyterDash import plotly.express as px import pandas as pd import plotly.graph_objects as go import dash_core_components as dcc ! pip install dash - bootstrap - components import dash_bootstrap_components as dbc ! pip install dash - cytoscape import dash_cytoscape as cyto \u21a9","title":"Ch 09 - Northern Navbars"},{"location":"learn/09_northern-navbars/#northern-navbars","text":"As we cross the Tundra, the snow begins to melt, leaving behind vast expanses of dirt and vegetation. Soon, a strange sight crosses our eye. In the distance, there appears to be a snowman meandering slowly through the pine trees . Upon seeing us, it turns and waves. \"Welcome, I'm here to guide you along your quest! Follow me, and I'll teach you what you need to know. As your navigator, it's only fitting that we discuss the importance of navbars! \" Stranger and stranger! Pulling out our laptop, we began to listen... Navbar Notes 01 In the last two chapters, we learned how to navigate across the multiple pages of our dashboard. However, our current system is a little bit clunky. One possible way to fix this is by utilizing a nabvar...","title":"Northern Navbars \u26c4\ufe0f"},{"location":"learn/09_northern-navbars/#creating-navbar-layout","text":"Adding a navbar to our dashboard allows for easier navigation, providing a fixed, non-changing area of our app which can be used to access other pages. In the previous chapter, we implemented a dropdown to navigate across pages. A navbar is as simple as wrapping this dropdown element into a dbc.Navbar() component ! Let's start with a simple example using dbc.Navbarsimple() : navbar = dbc . NavbarSimple ([ dbc . NavItem ( dbc . NavLink ( \"General\" , href = \"/\" )), dbc . DropdownMenu ( children = [ dbc . DropdownMenuItem ( \"More pages\" , header = True ), dbc . DropdownMenuItem ( \"Prescribers\" , href = \"/pre\" ), dbc . DropdownMenuItem ( \"TigerGraph Cloud\" , href = \"https://tgcloud.io/\" ), ], nav = True , in_navbar = True , label = \"More\" , ), ], brand = \"Example Navbar\" , brand_href = \"/\" , color = \"info\" , dark = True , ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ], suppress_callback_exceptions = True ) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), navbar , html . Center ( html . H1 ( \"Wow, look at this amazing navbar!\" )) ]) app . run_server ( mode = 'external' ) Let's break it down! First, we add a dbc.NavItem() which contains a link to the homepage . As a result, the href tag is simply a / . After this, we add our dbc.DropdownMenu() , very similar to dbc.Dropdown() from earlier. This dropdown contains a header, titled \"More Pages\" . Next, it contains a link to our Prescribers page as well as a link to the TigerGraph Cloud Portal . These links are added via dbc.DropdownMenuItem() . With the brand attribute, we can title our navbar and change its home link. Finally, we can modify the colors and styling of the navbar. Although we haven't included the pages themselves in this example, clicking the menu items will update the url. Let's try another example using navbars! The snowman excitedly exclaimed, \"That dropdown you created for your Prescribers page ... let's create a Navbar for that!\" Navbar Notes 02","title":"Creating Navbar Layout"},{"location":"learn/09_northern-navbars/#adding-navbar-elements","text":"Let's add our dropdown to our navbar, and our navbar to our Prescriber Page. dropdown = dbc . Row ( dbc . Col ( dcc . Dropdown ( id = \"pres-dropdown\" , placeholder = \"Enter a prescriber...\" , options = getPresList (), style = { 'width' : '400px' } ), width = 12 , align = \"end\" ), style = { \"margin-left\" : \"600px\" }) navbar = dbc . Navbar ( [ html . A ( # Use row and col to control vertical alignment of logo / brand dbc . Row ( [ dbc . Col ( dbc . NavbarBrand ( \"Healthcare Dashboard - TigerGraph's Dash Class Example\" , className = \"ml-2\" )), ], align = \"center\" , no_gutters = True , ), href = \"/\" , ), dropdown , ], color = \"dark\" , dark = True , ) def prescriberPage ( pres ): prescriberTitleCard , tableCard , barCard , networkCard = getPrescriberInfo ( pres ) page = html . Center ( html . Div ([ navbar , prescriberTitleCard , dbc . Row ([ dbc . Col ( tableCard ), dbc . Col ([ barCard , networkCard ], ) ], justify = 'center' ), ])) return page As seen, the navbar simply contains a hyperlinked header (that takes one back the main page) and a dropdown to enter prescriber information . No additional changes need to be made to the callback function. Here's the result! That helps make the Prescriber Page look a lot better! There's a few other options for Navbars as well, although we won't implement them for now: NavbarSimple - according to Dash, \"simpler, but less flexible\" Navbar - more customizability , but more intricate to set up NavbarBrand - contains a brand name (meant essentially for text) NavbarToggler - essentially a button (tracks clicks, times) NOTE: For more information on navbars, feel free to check out the following resources: dbc.Navbar() As the snowman finishes explaining to us, the dirt under our feet begins to slowly turn into sand. \"This is it, the end of the Tundra and the beginning of the Desert. Continue through here, and you'll find the Elysium of Elements. Beyond that should lie your final destination, the last chapter. \" Before wandering away, the snowman reaches into his pocket and pulls out a sleeping gecko. \"This is Geronimo. Keep him in your pocket and he will help you.\" As we cradle the gecko in our palms, he stirs and begins to slowly awaken. All code segments from this chapter can be found in this Colab Notebook . Feel free to follow along! \u21a9 Everything we've installed so far (prerequistes for next section): ! pip install - q pyTigerGraph import pyTigerGraph as tg TG_SUBDOMAIN = 'healthcare-dash' TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio Link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph conn = tg . TigerGraphConnection ( host = TG_HOST , graphname = TG_GRAPHNAME , username = TG_USERNAME , password = TG_PASSWORD , beta = True ) conn . apiToken = conn . getToken ( conn . createSecret ()) ! pip install - q jupyter - dash import dash import dash_html_components as html from jupyter_dash import JupyterDash import plotly.express as px import pandas as pd import plotly.graph_objects as go import dash_core_components as dcc ! pip install dash - bootstrap - components import dash_bootstrap_components as dbc ! pip install dash - cytoscape import dash_cytoscape as cyto \u21a9","title":"Adding Navbar Elements"},{"location":"learn/10_southern-sidebars/","text":"Southern Sidebars \ud83c\udf35 \u00b6 The gecko stared at us quizzicaly. \"You're not around here, are you? Lost, I'm assuming? \" A quick, quiet nod answers its question. \"Hmm, well you can follow me and I'll lead you across the desert. In the meantime, you know what could help users and yourselves to navigate through large, complicated terrains? Sidebars. \" The gecko looks at our blank stares and gives a wry smile, \"That's right, I'm the next step of your quest! Now listen closely...\" Southern Sidebars 01 Creating Sidebar Layout \u00b6 Just like navbars, sidebars allow for easier navigation across dashboards , especially ones with multiple pages. While the navbar sits on top of the app and is horizontal, the sidebar can usually be found vertically on the left-side . First, we must specify the styling of the sidebar, namely width, padding, and background color . SIDEBAR_STYLE = { \"position\" : \"fixed\" , \"top\" : 0 , \"left\" : 0 , \"bottom\" : 0 , \"width\" : \"16rem\" , \"padding\" : \"2rem 1rem\" , \"background-color\" : \"#f8f9fa\" , } Using this style dictionary , we can create our sidebar layout. sidebar = html . Div ( [ html . H2 ( \"Sidebar\" , className = \"display-4\" ), html . Hr (), html . P ( \"This is an example for TigerGraph's Dash Class\" , className = \"lead\" ), dbc . Nav ( [ dbc . NavLink ( \"Home\" , href = \"/\" , active = \"exact\" ), dbc . NavLink ( \"Prescribers\" , href = \"/pre\" , active = \"exact\" ), dbc . NavLink ( \"TG Cloud \ud83d\udc2f\" , href = \"https://tgcloud.io\" , active = \"exact\" ), ], vertical = True , pills = True , ), ], style = SIDEBAR_STYLE , ) Breaking it down, we have: A header with our sidebar title ( html.H2() ) A paragraph with a short description ( html.P() ) Three nav links : one to home, one to prescribers, and one to TG Cloud Now, we need to incorporate this sidebar into an example app. CONTENT_STYLE = { \"margin-left\" : \"18rem\" , \"margin-right\" : \"2rem\" , \"padding\" : \"2rem 1rem\" , } content = html . Div ( id = \"page-content\" , style = CONTENT_STYLE ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ], suppress_callback_exceptions = True ) app . layout = html . Div ([ dcc . Location ( id = \"url\" ), sidebar , content ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def render_page_content ( pathname ): if pathname == \"/\" : return html . P ( \"Congrats! You've found the home page!\" ) elif pathname == \"/pre\" : return html . P ( \"Woah, you've discovered the Prescribers Page!\" ) return dbc . Jumbotron ( [ html . H1 ( \"404: Not found\" , className = \"text-danger\" ), html . Hr (), html . P ( \"Uh oh! Unfortunately, the pathname {} was unable to be recognised...\" . format ( pathname )), ] ) app . run_server ( mode = 'external' ) First and foremost, we must create a new CONTENT_STYLE dictionary. Note that the margin-left is 18rem, accounting for both the sidebar's width and its padding (16rem and 2rem respectively). Additionally, having a margin-right of 2rem allows for a flush appearance on both sides. We must set the style of our content html.Div() element to match this! Next, within our app.layout() , we must include both the sidebar and content . The rest of the app remains the same, with the callback to navigate across both pages not requiring any changes. And here's the simple sidebar app, Let's customize this for our Healthcare Starter Kit Dashboard! As we continue to trek across the desert, the gecko begins his next story... Southern Sidebars 02 Adding Sidebar Elements \u00b6 Let's add some more elements to our dashboard's sidebar. First, we declare our global variables . SIDEBAR_STYLE = { \"position\" : \"fixed\" , \"top\" : 0 , \"left\" : 0 , \"bottom\" : 0 , \"width\" : \"16rem\" , \"padding\" : \"2rem 1rem\" , \"background-color\" : \"#424242\" , } WHITE = \"#fffff8\" TG_LOGO = \"https://i.ibb.co/gMMXcQB/Untitled-design-9.png\" PLOTLY_LOGO = \"https://dash.plotly.com/docs../assets/images/light_plotly_dash_logo.png\" In addition to the style, we need to store shared colors as well as images we will be referencing as global variables for our dashboard. This allows for easier readability and easier modification of shared content. Next, we can define the sidebar layout. sidebar = html . Div ( [ html . Center ( html . P ( \"A Plotly dashboard for TigerGraph's Healthcare Referrals Starter kit\" , className = \"lead\" , style = { 'color' : \"#ffcf9e\" } )), html . Hr ( style = { 'borderColor' : WHITE }), html . Center ( html . P ( \"Use the following to navigate this dashboard\" , className = \"lead\" , style = { 'color' : WHITE } )), dbc . Nav ( [ dbc . NavLink ( \"Home\" , href = \"/\" , active = \"exact\" , style = { 'color' : WHITE }), dbc . NavLink ( \"Prescribers\" , href = \"/pre\" , active = \"exact\" , style = { 'color' : WHITE }), dbc . NavLink ( \"TG Cloud \ud83d\udc2f\" , href = \"https://tgcloud.io\" , active = \"exact\" , style = { 'color' : WHITE }), ], vertical = True , pills = True , ), html . Hr ( style = { 'borderColor' : WHITE }), html . Center ( html . P ( \"To learn more, feel free to check out the following:\" , className = \"lead\" , style = { 'color' : WHITE } )), html . Li ( html . A ( \"Inroduction to Graphs\" , href = 'https://www.tigergraph.com/blog/what-is-a-graph-database-and-why-should-you-care/' , target = \"_blank\" , style = { 'color' : WHITE }), style = { 'color' : WHITE }), html . Li ( html . A ( \"Introduction to Dash\" , href = 'https://www.youtube.com/watch?v=e4ti2fCpXMI' , target = \"_blank\" , style = { 'color' : WHITE }), style = { 'color' : WHITE }), html . Br (), html . Hr ( style = { 'borderColor' : WHITE }), html . Br (), html . Center ( dbc . Row ( dbc . Col ( html . Img ( src = TG_LOGO , width = \"175px\" , style = { \"margin-bottom\" : \"15px\" , \"margin-top\" : \"50px\" })))), html . Br (), html . Center ( dbc . Row ( dbc . Col ( html . Img ( src = PLOTLY_LOGO , width = \"225px\" , style = { \"margin-bottom\" : \"15px\" })))), ], style = SIDEBAR_STYLE , ) Let's dissect this new sidebar, First, we have our centered title , in a different color than before. This is because the background color of our sidebar is now a darker shade of grey, meaning all text should be lighter colors . Next, we have a standard horizontal rule , however colored white instead of the usual grey. Following this is another short description , in the color white to allow for easier readability. This next section hasn't changed, it simply contains our dbc.Nav() After another white horizontal rule, we have a shot description for further resources Using the html.Li() component, we can include hyperlinks to external webpages . Although this can be achieved using dcc.Link() (as we covered in a previous chapter), it never hurts to learn multiple ways for accomplishing a given task! Both provide similar functionality. Finally, we have two centered images . Our TigerGraph and Plotly Dash logos. With html.Img() , we can specify width, height, and margins . These are stored in dbc.Row() and dbc.Col() to provide consistent borders. Now, it's time to incorporate this sidebar into our app. First, we need to reformat our figures and page layouts to account for the change in width. Reformatted Pie, Scatter pieChart = getClaimsPieChart () scatterChart = getScatterChart () pieChartCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"All Submitted Claims\" , className = 'card-title' ), html . P ( \"Which categories of claims are most frequent? \\n Which areas should prescribers focus on?\" , className = 'card-body' ), dcc . Graph ( id = 'Pie Chart' , figure = pieChart ) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"49rem\" , \"margin-right\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) scatterChartCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Prescriber Communities\" , className = 'card-title' ), html . P ( \"Do communities lead to more business? How do the number of referrals compare to community size?\" , className = 'card-body' ), dcc . Graph ( id = 'Scatter Chart' , figure = scatterChart ) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"50rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) Reformatted getPrescriberInfo() def getPrescriberInfo ( person_num ): network = getNetwork ( person_num ) number , table , bar , max_title = getClaims ( person_num ) prescriberTitleCard = dbc . Card ([ dbc . CardBody ([ html . Center ( dbc . Badge ([ html . H1 ( \" Prescriber \" + person_num + \"'s Claims \" , className = 'card-title' )], color = \"light\" )), html . Center ( html . P ( \"This individual has a total of \" + repr ( number ) + \" claims. Their most referred to specialization is: \" + max_title , className = 'card-body' )), ]) ], outline = True , color = 'info' , style = { \"width\" : \"95rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" , \"margin-right\" : \"1rem\" } ) tableCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Claims by Prescriber\" , className = 'card-title' ), html . P ( \"A detailed description of each claim...\" , className = 'card-body' ), table ]) ], outline = True , color = 'info' , style = { \"width\" : \"48rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) barCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Claims by Category\" , className = 'card-title' ), html . P ( \"Which claims are being prescribed most?\" , className = 'card-body' ), dcc . Graph ( id = 'Bar Chart' , figure = bar ) ]) ], outline = True , color = 'info' , style = { \"width\" : \"48rem\" , \"margin-left\" : \"0rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) networkCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Prescriber Network\" , className = 'card-title' ), html . P ( \"Who's part of this prescriber's community?\" , className = 'card-body' ), network ]) ], outline = True , color = 'info' , style = { \"width\" : \"48rem\" , \"margin-left\" : \"0rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) return prescriberTitleCard , tableCard , barCard , networkCard Reformatted Pages generalPage = html . Center ( html . Div ([ dbc . Col ( dbc . Button ( \"Switch Pages\" , id = \"switch-button\" , className = \"mr-2\" , n_clicks = 0 , color = \"info\" , href = \"/pre\" ), width = 2 ), dbc . Row ( titleCard , justify = \"center\" ), dbc . Row ( statsListGroup , justify = \"center\" ), html . Br (), dbc . Row ([ pieChartCard , scatterChartCard , ], justify = \"center\" ), ], style = { \"width\" : \"100rem\" })) dropdown = dbc . Row ( dbc . Col ( dcc . Dropdown ( id = \"pres-dropdown\" , placeholder = \"Enter a prescriber...\" , options = getPresList (), style = { 'width' : '400px' } ), width = 12 , align = \"end\" ), style = { \"margin-left\" : \"35rem\" }) navbar = dbc . Navbar ( [ html . A ( # Use row and col to control vertical alignment of logo / brand dbc . Row ( [ dbc . Col ( dbc . NavbarBrand ( \"Healthcare Dashboard - TigerGraph's Dash Class Example\" , className = \"ml-2\" )), ], align = \"center\" , no_gutters = True , ), href = \"/\" , ), dropdown , ], color = \"dark\" , dark = True , ) def prescriberPage ( pres ): prescriberTitleCard , tableCard , barCard , networkCard = getPrescriberInfo ( pres ) page = html . Center ( html . Div ([ navbar , prescriberTitleCard , dbc . Row ([ dbc . Col ( tableCard ), dbc . Col ([ barCard , networkCard ], ) ], justify = 'center' ), ], style = { \"width\" : \"100rem\" })) return page Now, we can incorporate our sidebar into the app.layout . It's important to note that only page-content contains CONTENT_STYLE . Our pres-content page doesn't require this styling as it is not part of our app.layout directly. Instead, it is returned to substitute page-content . CONTENT_STYLE = { \"margin-left\" : \"18rem\" , \"margin-right\" : \"2rem\" , \"padding\" : \"2rem 1rem\" , } app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ], suppress_callback_exceptions = True ) presPage = html . Div ( prescriberPage ( \"pre78\" ), id = 'pres-content' ) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), sidebar , html . Div ( id = 'page-content' , style = CONTENT_STYLE ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def display_page ( pathname ): if pathname == \"/\" : return generalPage elif pathname == \"/pre\" : return presPage return dbc . Jumbotron ( [ html . H1 ( \"404: Not found\" , className = \"text-danger\" ), html . Hr (), html . P ( \"Uh oh! Unfortunately, the pathname {} was unable to be recognised...\" . format ( pathname )), ] ) @app . callback ( dash . dependencies . Output ( 'pres-content' , 'children' ), [ dash . dependencies . Input ( 'pres-dropdown' , 'value' )]) def update_pres ( value ): if value is not None : return prescriberPage ( value ) return prescriberPage ( \"pre78\" ) # Our default value app . run_server ( mode = 'external' ) And here's our output, both pages complete with the sidebar! Awesome! And that's how to incorporate a sidebar into one's dashboard :) NOTE: For more information on sidebars, feel free to check out the following resources: Dash Sidebar Video Geronimo the gecko points to a small tornado in the distance, \"You must enter the tornado in order to reach the Elysium of Elements . I know it may seem scary, but it's the only way to find what you seek. Trust me, it'll take you to where you need to go.\" And with that, Geronimo hops out of our hands and crawls away. The tornado grows closer and closer. With our eyes closed, we step cautiously toward its roars. Yet for some strange reason, we don't feel anything . The tempestuous winds cannot be felt, and as it finally passes over us, we open our eyes to find ourselves in a strange new place. A blue and orange-striped orb materializes next to us and begins to chirp. All code segments from this chapter can be found in this Colab Notebook . Feel free to follow along! \u21a9 Everything we've installed so far (prerequistes for next section): ! pip install - q pyTigerGraph import pyTigerGraph as tg TG_SUBDOMAIN = 'healthcare-dash' TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio Link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph conn = tg . TigerGraphConnection ( host = TG_HOST , graphname = TG_GRAPHNAME , username = TG_USERNAME , password = TG_PASSWORD , beta = True ) conn . apiToken = conn . getToken ( conn . createSecret ()) ! pip install - q jupyter - dash import dash import dash_html_components as html from jupyter_dash import JupyterDash import plotly.express as px import pandas as pd import plotly.graph_objects as go import dash_core_components as dcc ! pip install dash - bootstrap - components import dash_bootstrap_components as dbc ! pip install dash - cytoscape import dash_cytoscape as cyto \u21a9","title":"Ch 10 - Southern Sidebars"},{"location":"learn/10_southern-sidebars/#southern-sidebars","text":"The gecko stared at us quizzicaly. \"You're not around here, are you? Lost, I'm assuming? \" A quick, quiet nod answers its question. \"Hmm, well you can follow me and I'll lead you across the desert. In the meantime, you know what could help users and yourselves to navigate through large, complicated terrains? Sidebars. \" The gecko looks at our blank stares and gives a wry smile, \"That's right, I'm the next step of your quest! Now listen closely...\" Southern Sidebars 01","title":"Southern Sidebars \ud83c\udf35"},{"location":"learn/10_southern-sidebars/#creating-sidebar-layout","text":"Just like navbars, sidebars allow for easier navigation across dashboards , especially ones with multiple pages. While the navbar sits on top of the app and is horizontal, the sidebar can usually be found vertically on the left-side . First, we must specify the styling of the sidebar, namely width, padding, and background color . SIDEBAR_STYLE = { \"position\" : \"fixed\" , \"top\" : 0 , \"left\" : 0 , \"bottom\" : 0 , \"width\" : \"16rem\" , \"padding\" : \"2rem 1rem\" , \"background-color\" : \"#f8f9fa\" , } Using this style dictionary , we can create our sidebar layout. sidebar = html . Div ( [ html . H2 ( \"Sidebar\" , className = \"display-4\" ), html . Hr (), html . P ( \"This is an example for TigerGraph's Dash Class\" , className = \"lead\" ), dbc . Nav ( [ dbc . NavLink ( \"Home\" , href = \"/\" , active = \"exact\" ), dbc . NavLink ( \"Prescribers\" , href = \"/pre\" , active = \"exact\" ), dbc . NavLink ( \"TG Cloud \ud83d\udc2f\" , href = \"https://tgcloud.io\" , active = \"exact\" ), ], vertical = True , pills = True , ), ], style = SIDEBAR_STYLE , ) Breaking it down, we have: A header with our sidebar title ( html.H2() ) A paragraph with a short description ( html.P() ) Three nav links : one to home, one to prescribers, and one to TG Cloud Now, we need to incorporate this sidebar into an example app. CONTENT_STYLE = { \"margin-left\" : \"18rem\" , \"margin-right\" : \"2rem\" , \"padding\" : \"2rem 1rem\" , } content = html . Div ( id = \"page-content\" , style = CONTENT_STYLE ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ], suppress_callback_exceptions = True ) app . layout = html . Div ([ dcc . Location ( id = \"url\" ), sidebar , content ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def render_page_content ( pathname ): if pathname == \"/\" : return html . P ( \"Congrats! You've found the home page!\" ) elif pathname == \"/pre\" : return html . P ( \"Woah, you've discovered the Prescribers Page!\" ) return dbc . Jumbotron ( [ html . H1 ( \"404: Not found\" , className = \"text-danger\" ), html . Hr (), html . P ( \"Uh oh! Unfortunately, the pathname {} was unable to be recognised...\" . format ( pathname )), ] ) app . run_server ( mode = 'external' ) First and foremost, we must create a new CONTENT_STYLE dictionary. Note that the margin-left is 18rem, accounting for both the sidebar's width and its padding (16rem and 2rem respectively). Additionally, having a margin-right of 2rem allows for a flush appearance on both sides. We must set the style of our content html.Div() element to match this! Next, within our app.layout() , we must include both the sidebar and content . The rest of the app remains the same, with the callback to navigate across both pages not requiring any changes. And here's the simple sidebar app, Let's customize this for our Healthcare Starter Kit Dashboard! As we continue to trek across the desert, the gecko begins his next story... Southern Sidebars 02","title":"Creating Sidebar Layout"},{"location":"learn/10_southern-sidebars/#adding-sidebar-elements","text":"Let's add some more elements to our dashboard's sidebar. First, we declare our global variables . SIDEBAR_STYLE = { \"position\" : \"fixed\" , \"top\" : 0 , \"left\" : 0 , \"bottom\" : 0 , \"width\" : \"16rem\" , \"padding\" : \"2rem 1rem\" , \"background-color\" : \"#424242\" , } WHITE = \"#fffff8\" TG_LOGO = \"https://i.ibb.co/gMMXcQB/Untitled-design-9.png\" PLOTLY_LOGO = \"https://dash.plotly.com/docs../assets/images/light_plotly_dash_logo.png\" In addition to the style, we need to store shared colors as well as images we will be referencing as global variables for our dashboard. This allows for easier readability and easier modification of shared content. Next, we can define the sidebar layout. sidebar = html . Div ( [ html . Center ( html . P ( \"A Plotly dashboard for TigerGraph's Healthcare Referrals Starter kit\" , className = \"lead\" , style = { 'color' : \"#ffcf9e\" } )), html . Hr ( style = { 'borderColor' : WHITE }), html . Center ( html . P ( \"Use the following to navigate this dashboard\" , className = \"lead\" , style = { 'color' : WHITE } )), dbc . Nav ( [ dbc . NavLink ( \"Home\" , href = \"/\" , active = \"exact\" , style = { 'color' : WHITE }), dbc . NavLink ( \"Prescribers\" , href = \"/pre\" , active = \"exact\" , style = { 'color' : WHITE }), dbc . NavLink ( \"TG Cloud \ud83d\udc2f\" , href = \"https://tgcloud.io\" , active = \"exact\" , style = { 'color' : WHITE }), ], vertical = True , pills = True , ), html . Hr ( style = { 'borderColor' : WHITE }), html . Center ( html . P ( \"To learn more, feel free to check out the following:\" , className = \"lead\" , style = { 'color' : WHITE } )), html . Li ( html . A ( \"Inroduction to Graphs\" , href = 'https://www.tigergraph.com/blog/what-is-a-graph-database-and-why-should-you-care/' , target = \"_blank\" , style = { 'color' : WHITE }), style = { 'color' : WHITE }), html . Li ( html . A ( \"Introduction to Dash\" , href = 'https://www.youtube.com/watch?v=e4ti2fCpXMI' , target = \"_blank\" , style = { 'color' : WHITE }), style = { 'color' : WHITE }), html . Br (), html . Hr ( style = { 'borderColor' : WHITE }), html . Br (), html . Center ( dbc . Row ( dbc . Col ( html . Img ( src = TG_LOGO , width = \"175px\" , style = { \"margin-bottom\" : \"15px\" , \"margin-top\" : \"50px\" })))), html . Br (), html . Center ( dbc . Row ( dbc . Col ( html . Img ( src = PLOTLY_LOGO , width = \"225px\" , style = { \"margin-bottom\" : \"15px\" })))), ], style = SIDEBAR_STYLE , ) Let's dissect this new sidebar, First, we have our centered title , in a different color than before. This is because the background color of our sidebar is now a darker shade of grey, meaning all text should be lighter colors . Next, we have a standard horizontal rule , however colored white instead of the usual grey. Following this is another short description , in the color white to allow for easier readability. This next section hasn't changed, it simply contains our dbc.Nav() After another white horizontal rule, we have a shot description for further resources Using the html.Li() component, we can include hyperlinks to external webpages . Although this can be achieved using dcc.Link() (as we covered in a previous chapter), it never hurts to learn multiple ways for accomplishing a given task! Both provide similar functionality. Finally, we have two centered images . Our TigerGraph and Plotly Dash logos. With html.Img() , we can specify width, height, and margins . These are stored in dbc.Row() and dbc.Col() to provide consistent borders. Now, it's time to incorporate this sidebar into our app. First, we need to reformat our figures and page layouts to account for the change in width. Reformatted Pie, Scatter pieChart = getClaimsPieChart () scatterChart = getScatterChart () pieChartCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"All Submitted Claims\" , className = 'card-title' ), html . P ( \"Which categories of claims are most frequent? \\n Which areas should prescribers focus on?\" , className = 'card-body' ), dcc . Graph ( id = 'Pie Chart' , figure = pieChart ) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"49rem\" , \"margin-right\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) scatterChartCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Prescriber Communities\" , className = 'card-title' ), html . P ( \"Do communities lead to more business? How do the number of referrals compare to community size?\" , className = 'card-body' ), dcc . Graph ( id = 'Scatter Chart' , figure = scatterChart ) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"50rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) Reformatted getPrescriberInfo() def getPrescriberInfo ( person_num ): network = getNetwork ( person_num ) number , table , bar , max_title = getClaims ( person_num ) prescriberTitleCard = dbc . Card ([ dbc . CardBody ([ html . Center ( dbc . Badge ([ html . H1 ( \" Prescriber \" + person_num + \"'s Claims \" , className = 'card-title' )], color = \"light\" )), html . Center ( html . P ( \"This individual has a total of \" + repr ( number ) + \" claims. Their most referred to specialization is: \" + max_title , className = 'card-body' )), ]) ], outline = True , color = 'info' , style = { \"width\" : \"95rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" , \"margin-right\" : \"1rem\" } ) tableCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Claims by Prescriber\" , className = 'card-title' ), html . P ( \"A detailed description of each claim...\" , className = 'card-body' ), table ]) ], outline = True , color = 'info' , style = { \"width\" : \"48rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) barCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Claims by Category\" , className = 'card-title' ), html . P ( \"Which claims are being prescribed most?\" , className = 'card-body' ), dcc . Graph ( id = 'Bar Chart' , figure = bar ) ]) ], outline = True , color = 'info' , style = { \"width\" : \"48rem\" , \"margin-left\" : \"0rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) networkCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Prescriber Network\" , className = 'card-title' ), html . P ( \"Who's part of this prescriber's community?\" , className = 'card-body' ), network ]) ], outline = True , color = 'info' , style = { \"width\" : \"48rem\" , \"margin-left\" : \"0rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) return prescriberTitleCard , tableCard , barCard , networkCard Reformatted Pages generalPage = html . Center ( html . Div ([ dbc . Col ( dbc . Button ( \"Switch Pages\" , id = \"switch-button\" , className = \"mr-2\" , n_clicks = 0 , color = \"info\" , href = \"/pre\" ), width = 2 ), dbc . Row ( titleCard , justify = \"center\" ), dbc . Row ( statsListGroup , justify = \"center\" ), html . Br (), dbc . Row ([ pieChartCard , scatterChartCard , ], justify = \"center\" ), ], style = { \"width\" : \"100rem\" })) dropdown = dbc . Row ( dbc . Col ( dcc . Dropdown ( id = \"pres-dropdown\" , placeholder = \"Enter a prescriber...\" , options = getPresList (), style = { 'width' : '400px' } ), width = 12 , align = \"end\" ), style = { \"margin-left\" : \"35rem\" }) navbar = dbc . Navbar ( [ html . A ( # Use row and col to control vertical alignment of logo / brand dbc . Row ( [ dbc . Col ( dbc . NavbarBrand ( \"Healthcare Dashboard - TigerGraph's Dash Class Example\" , className = \"ml-2\" )), ], align = \"center\" , no_gutters = True , ), href = \"/\" , ), dropdown , ], color = \"dark\" , dark = True , ) def prescriberPage ( pres ): prescriberTitleCard , tableCard , barCard , networkCard = getPrescriberInfo ( pres ) page = html . Center ( html . Div ([ navbar , prescriberTitleCard , dbc . Row ([ dbc . Col ( tableCard ), dbc . Col ([ barCard , networkCard ], ) ], justify = 'center' ), ], style = { \"width\" : \"100rem\" })) return page Now, we can incorporate our sidebar into the app.layout . It's important to note that only page-content contains CONTENT_STYLE . Our pres-content page doesn't require this styling as it is not part of our app.layout directly. Instead, it is returned to substitute page-content . CONTENT_STYLE = { \"margin-left\" : \"18rem\" , \"margin-right\" : \"2rem\" , \"padding\" : \"2rem 1rem\" , } app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ], suppress_callback_exceptions = True ) presPage = html . Div ( prescriberPage ( \"pre78\" ), id = 'pres-content' ) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), sidebar , html . Div ( id = 'page-content' , style = CONTENT_STYLE ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def display_page ( pathname ): if pathname == \"/\" : return generalPage elif pathname == \"/pre\" : return presPage return dbc . Jumbotron ( [ html . H1 ( \"404: Not found\" , className = \"text-danger\" ), html . Hr (), html . P ( \"Uh oh! Unfortunately, the pathname {} was unable to be recognised...\" . format ( pathname )), ] ) @app . callback ( dash . dependencies . Output ( 'pres-content' , 'children' ), [ dash . dependencies . Input ( 'pres-dropdown' , 'value' )]) def update_pres ( value ): if value is not None : return prescriberPage ( value ) return prescriberPage ( \"pre78\" ) # Our default value app . run_server ( mode = 'external' ) And here's our output, both pages complete with the sidebar! Awesome! And that's how to incorporate a sidebar into one's dashboard :) NOTE: For more information on sidebars, feel free to check out the following resources: Dash Sidebar Video Geronimo the gecko points to a small tornado in the distance, \"You must enter the tornado in order to reach the Elysium of Elements . I know it may seem scary, but it's the only way to find what you seek. Trust me, it'll take you to where you need to go.\" And with that, Geronimo hops out of our hands and crawls away. The tornado grows closer and closer. With our eyes closed, we step cautiously toward its roars. Yet for some strange reason, we don't feel anything . The tempestuous winds cannot be felt, and as it finally passes over us, we open our eyes to find ourselves in a strange new place. A blue and orange-striped orb materializes next to us and begins to chirp. All code segments from this chapter can be found in this Colab Notebook . Feel free to follow along! \u21a9 Everything we've installed so far (prerequistes for next section): ! pip install - q pyTigerGraph import pyTigerGraph as tg TG_SUBDOMAIN = 'healthcare-dash' TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio Link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph conn = tg . TigerGraphConnection ( host = TG_HOST , graphname = TG_GRAPHNAME , username = TG_USERNAME , password = TG_PASSWORD , beta = True ) conn . apiToken = conn . getToken ( conn . createSecret ()) ! pip install - q jupyter - dash import dash import dash_html_components as html from jupyter_dash import JupyterDash import plotly.express as px import pandas as pd import plotly.graph_objects as go import dash_core_components as dcc ! pip install dash - bootstrap - components import dash_bootstrap_components as dbc ! pip install dash - cytoscape import dash_cytoscape as cyto \u21a9","title":"Adding Sidebar Elements"},{"location":"learn/11_elysium-elements/","text":"Elysium of Elements \ud83c\udf08 \u00b6 \"Congratulations my weary friends. You've reached the Elysium of Elements This land is home to all the knowledge you seek, complete with archives and resources on Plotly, Dash Core, and Dash Bootstrap . As the last chapter before your quest's finale, I'd recommend exploring a few of these elements... you never know what you may find\" And with that, our mysterious friend floats away, leaving us in a sea of clouds, surrounded by small exhibit booths neatly organized in seemingly infinite lines. The one closest to us reads \"Presenting Plotly Paradise\" ... Elysium of Elements 01 Plotly Paradise \u00b6 Although we've explored several core Plotly figures that are used extensively across dashboards, there are a myriad of other charts that can be made using Plotly. In this section, we'll explore a few of them. NOTE: Feel free to submit requests for other elements. This chapter may be updated to include them as well! Radar Charts \u00b6 Radar charts are used to visualize different traces across different axes . For example, if one wished to compare restaurants across five different categories , a radar chart would be a perfect visualization. Let's take a look at creating one with Plotly. categories = [ 'Food' , 'Service' , 'Affordable' , 'Location' , 'Ambience' ] res = { \"Pop's Pizzas\" : [ 3 , 3 , 5 , 4 , 3 ], \"Tony's Tacos\" : [ 5 , 2 , 4 , 1 , 2 ], \"Bill's Bread\" : [ 2 , 4 , 1 , 2 , 4 ], } fig = go . Figure () for restaurant in res : fig . add_trace ( go . Scatterpolar ( r = res [ restaurant ], theta = categories , fill = 'toself' , name = restaurant , )) fig . update_layout ( polar = dict ( radialaxis = dict ( visible = True ), ), width = 800 ) fig . show () As seen, we create a go.Figure() and add multiple traces. Each trace represents a distinct data entity, in this case different restaurants. Each restaurant has been scored across different categories, and categories are stored in theta , while each value is stored in r . In fig.update_layout() , the figure is converted into polar form to create our circular radar chart. It's a lot easier to visualize how each restaurant compares! NOTE: This format is similar to polar axes, where each point is determine in r and theta instead of x and y. NOTE: For more resources on Radar Charts, feel free to check out the following resources: Plotly Radar 3-D Figures \u00b6 In order to create 3D plots, we can use the px.scatter_3d() function. This simply requires us to enter a list value for x, y, and z. Dataframes can also be used to create a 3-D figure, formatted the same as with px.scatter() . Here's an example of a 3D parabolic curve: import numpy as np t = np . linspace ( - 10 , 10 , 50 ) x = t y = t ** 2 z = 3 * x - 2 * y fig = px . scatter_3d ( x = x , y = y , z = z ) fig . show () NOTE: np.linspace() simply creates a list from -10 to 10, with 50 data points in between, spaced evenly. NOTE: For more information on Radar Charts, feel free to check out the following resources: Scatter , 3D Charts Choropleth (Maps) \u00b6 Plotly allows for the creation and insertion of geographical maps using geojson data. Choropleth maps allow for the visulization of distinct geographical zones with different colors to indicate different attributes. In order to use the Plotly Choropleth example, we need to install the following. ! pip install - U plotly from urllib.request import urlopen import json import pandas as pd import plotly.express as px NOTE: We need to upgrade our version of Plotly to the latest to ensure that Choropleth works! Now, we can use the Plotly datasets in order to visualize the unemployment in the United States. with urlopen ( 'https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json' ) as response : counties = json . load ( response ) df = pd . read_csv ( \"https://raw.githubusercontent.com/plotly/datasets/master/fips-unemp-16.csv\" , dtype = { \"fips\" : str }) fig = px . choropleth ( df , geojson = counties , locations = 'fips' , color = 'unemp' , color_continuous_scale = \"Viridis\" , range_color = ( 0 , 12 ), scope = \"usa\" , labels = { 'unemp' : 'unemployment rate' } ) fig . update_layout ( margin = { \"r\" : 0 , \"t\" : 0 , \"l\" : 0 , \"b\" : 0 }) fig . show () As seen, it's quite a detailed, interactive map! NOTE: For more information on Maps, feel free to check out the following resources: Choropleth We turn to the next booth and continue reading... Elysium of Elements 02 Bootstrap Bliss \u00b6 As with Plotly, there are dozens of other unique Bootstrap components that can be incorporated into one's dashboard. Although we've covered the core elements, we'll explore three more in this section. NOTE: For a comprehensive list on all bootstrap components, feel free to check out: Dash Bootstrap Progress Bars \u00b6 Progress bars are horizontal, rounded rectangles that are quite flexible when it comes to displaying progress. Here's an example of a progress bar with three distinct sections. progress = dbc . Progress ( [ dbc . Progress ( value = 20 , color = \"success\" , bar = True ), dbc . Progress ( value = 30 , color = \"warning\" , bar = True ), dbc . Progress ( value = 20 , color = \"danger\" , bar = True ), ], multi = True , ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Col ( progress , width = 6 ) ]) app . run_server ( mode = 'external' ) As seen, each bar section has a different color and length ( value ). This bar can also be animated , controlled via a button that toggles the bar on and off. progress = html . Div ( [ dbc . Progress ( value = 80 , id = \"animated-progress\" , animated = False , striped = True ), dbc . Button ( \"Toggle animation\" , id = \"animation-toggle\" , className = \"mt-3\" , n_clicks = 0 , ), ] ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Col ( progress , width = 6 ) ]) @app . callback ( dash . dependencies . Output ( \"animated-progress\" , \"animated\" ), [ dash . dependencies . Input ( \"animation-toggle\" , \"n_clicks\" )], [ dash . dependencies . State ( \"animated-progress\" , \"animated\" )], ) def toggle_animation ( n , animated ): if n : return not animated return animated app . run_server ( mode = 'external' ) Ah-ah, one interesting addition is the variable dash.dependencies.State as part of our app's callback. This simply means that the state of the progress bar (whether it is currently animated or not) is also used to determine the output. This makes sense, since our toggle button inverts whatever the state of the progress bar is. NOTE: For more information on progress bars, feel free to check out the following resources: Progress Spinners \u00b6 Next up, spinners! These components are small circles that move to indicate that a process is occurring. Here are three examples (one small, one big, and one growing). spinners = html . Div ( [ dbc . Row ([ dbc . Col ( dbc . Spinner ( size = \"sm\" , color = \"info\" ), width = 1 ), dbc . Col ( dbc . Spinner ( spinner_style = { \"width\" : \"3rem\" , \"height\" : \"3rem\" }, color = \"success\" ), width = 1 ), dbc . Col ( dbc . Spinner ( color = \"danger\" , type = \"grow\" ), width = 1 ), ]) ] ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Col ( spinners , width = 6 ) ]) app . run_server ( mode = 'external' ) Each can be easily colored, resized, and toggled between traditional mode and growing mode. Spinners can also be used to indicate loading, or to be displayed upon a user action . For example, the following displays a spinner based on the number of times the button is pressed. After the time has elapsed, the spinner is replaced with the output. import time loading_spinner = html . Div ( [ dbc . Button ( \"Counter\" , id = \"loading-button\" , n_clicks = 0 ), dbc . Spinner ( html . Div ( id = \"loading-output\" )), ] ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Col ( loading_spinner , width = 3 ) ]) @app . callback ( dash . dependencies . Output ( \"loading-output\" , \"children\" ), [ dash . dependencies . Input ( \"loading-button\" , \"n_clicks\" )] ) def load_output ( n ): if n : time . sleep ( 1 ) return f \"You have clicked { n } times\" return \"No clicks as of yet ;(\" app . run_server ( mode = 'external' ) NOTE: For more information on spinners, feel free to check out the following resources: Dash Spinners Alerts \u00b6 Next up, Dash Alerts! These components are used to display important information, such as messages, information the user should know before proceeding , or any other form of alerts. Like all bootstrap, they are quite flexible. Here's an example with two alerts, one of them dismissible (able to be closed) and the other permanent . alerts = html . Div ([ dbc . Alert ( \"This is a success alert! Luckily, I won't leave!\" , color = \"success\" ), dbc . Alert ( \"This is a warning alert, but you can close me!\" , color = \"warning\" , dismissable = True ), ]) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Col ( alerts , width = 6 ) ]) app . run_server ( mode = 'external' ) These alarms can be easily customized in terms of color and content. Additionally, they can be set to automatically disappear after a certain amount of time . This is done via the keyword duration , which takes in milliseconds. Here's an example with a disappearing alert, accompanied by a button that toggles the state of the alert. alert = html . Div ( [ dbc . Button ( \"Switch States\" , id = \"alert-toggle-auto\" , className = \"mr-1\" , n_clicks = 0 ), html . Hr (), dbc . Alert ( \"I will disappear in 3 seconds...\" , id = \"alert-auto\" , color = \"danger\" , is_open = True , duration = 3000 , # In milliseconds ), ] ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Col ( alert , width = 6 ) ]) @app . callback ( dash . dependencies . Output ( \"alert-auto\" , \"is_open\" ), [ dash . dependencies . Input ( \"alert-toggle-auto\" , \"n_clicks\" )], [ dash . dependencies . State ( \"alert-auto\" , \"is_open\" )], ) def toggle_alert ( n , is_open ): if n : return not is_open return is_open app . run_server ( mode = 'external' ) Quite handy, especially to help users navigate a dashboard for the first time! NOTE: For more information on alerts, feel free to check out the following resources: Dash Alerts A booming voice announces, \"Dear dashboarders, our time in the Elysium is almost up. However, before continuing, let's take a closer look to see all the powerful Plotly + Dash that you've learned along the way\" Elysium of Elements 03 Dash Dreamland \u00b6 There are hundreds of more Dash elements, including Dash Core Components, Dash Bootstrap Components, Plotly, Ploly Express, HTML , and more . Diving into these elements is beyond the scope of this introductory journey! However, here's a quick summary of everything we've learned along the way, a sort of cheat-sheet... Plotly Charts Dash/Tigergraph HTML Dash Core Bootstrap Bar Charts Layout Functions Div Graphs Cards Line Charts Styling App Headers Markdown Row/Col Pie Charts Multi-Paged Paragraph Location Badges Scatter Plots Callbacks Bold/Italic Links ListGroup Cytoscape Navbars Center Input Jumbotron Radar Charts Sidebars Link Dropdown Button 3-D Figures Create Solution Hr. Rule Table Choropleth Connect w/ pyTG Line Break Progress Install Queries Image Spinner Run Queries Alert Feel free to utilize the \"Search\" box at the top right of this webpage to quickly reference each. We've learned quite a lot within the span of less than a dozen chapters \ud83d\ude04. \"Now, it is time to complete your quest .\" The mysterious figure who greeted us returns, and with a wave of their hands, we find ourselves sitting across from them at a round table. A sign behind them reads, \"Destination Deployment\" All code segments from this chapter can be found in this Colab Notebook . Feel free to follow along! \u21a9 Everything we've installed so far (prerequistes for next section): ! pip install - q pyTigerGraph import pyTigerGraph as tg TG_SUBDOMAIN = 'healthcare-dash' TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio Link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph conn = tg . TigerGraphConnection ( host = TG_HOST , graphname = TG_GRAPHNAME , username = TG_USERNAME , password = TG_PASSWORD , beta = True ) conn . apiToken = conn . getToken ( conn . createSecret ()) ! pip install - q jupyter - dash import dash import dash_html_components as html from jupyter_dash import JupyterDash import plotly.express as px import pandas as pd import plotly.graph_objects as go import dash_core_components as dcc ! pip install dash - bootstrap - components import dash_bootstrap_components as dbc ! pip install dash - cytoscape import dash_cytoscape as cyto import numpy as np ! pip install - U plotly from urllib.request import urlopen import json import pandas as pd import plotly.express as px import time \u21a9","title":"Ch 11 - Elysium of Elements"},{"location":"learn/11_elysium-elements/#elysium-of-elements","text":"\"Congratulations my weary friends. You've reached the Elysium of Elements This land is home to all the knowledge you seek, complete with archives and resources on Plotly, Dash Core, and Dash Bootstrap . As the last chapter before your quest's finale, I'd recommend exploring a few of these elements... you never know what you may find\" And with that, our mysterious friend floats away, leaving us in a sea of clouds, surrounded by small exhibit booths neatly organized in seemingly infinite lines. The one closest to us reads \"Presenting Plotly Paradise\" ... Elysium of Elements 01","title":"Elysium of Elements \ud83c\udf08"},{"location":"learn/11_elysium-elements/#plotly-paradise","text":"Although we've explored several core Plotly figures that are used extensively across dashboards, there are a myriad of other charts that can be made using Plotly. In this section, we'll explore a few of them. NOTE: Feel free to submit requests for other elements. This chapter may be updated to include them as well!","title":"Plotly Paradise"},{"location":"learn/11_elysium-elements/#radar-charts","text":"Radar charts are used to visualize different traces across different axes . For example, if one wished to compare restaurants across five different categories , a radar chart would be a perfect visualization. Let's take a look at creating one with Plotly. categories = [ 'Food' , 'Service' , 'Affordable' , 'Location' , 'Ambience' ] res = { \"Pop's Pizzas\" : [ 3 , 3 , 5 , 4 , 3 ], \"Tony's Tacos\" : [ 5 , 2 , 4 , 1 , 2 ], \"Bill's Bread\" : [ 2 , 4 , 1 , 2 , 4 ], } fig = go . Figure () for restaurant in res : fig . add_trace ( go . Scatterpolar ( r = res [ restaurant ], theta = categories , fill = 'toself' , name = restaurant , )) fig . update_layout ( polar = dict ( radialaxis = dict ( visible = True ), ), width = 800 ) fig . show () As seen, we create a go.Figure() and add multiple traces. Each trace represents a distinct data entity, in this case different restaurants. Each restaurant has been scored across different categories, and categories are stored in theta , while each value is stored in r . In fig.update_layout() , the figure is converted into polar form to create our circular radar chart. It's a lot easier to visualize how each restaurant compares! NOTE: This format is similar to polar axes, where each point is determine in r and theta instead of x and y. NOTE: For more resources on Radar Charts, feel free to check out the following resources: Plotly Radar","title":"Radar Charts"},{"location":"learn/11_elysium-elements/#3-d-figures","text":"In order to create 3D plots, we can use the px.scatter_3d() function. This simply requires us to enter a list value for x, y, and z. Dataframes can also be used to create a 3-D figure, formatted the same as with px.scatter() . Here's an example of a 3D parabolic curve: import numpy as np t = np . linspace ( - 10 , 10 , 50 ) x = t y = t ** 2 z = 3 * x - 2 * y fig = px . scatter_3d ( x = x , y = y , z = z ) fig . show () NOTE: np.linspace() simply creates a list from -10 to 10, with 50 data points in between, spaced evenly. NOTE: For more information on Radar Charts, feel free to check out the following resources: Scatter , 3D Charts","title":"3-D Figures"},{"location":"learn/11_elysium-elements/#choropleth-maps","text":"Plotly allows for the creation and insertion of geographical maps using geojson data. Choropleth maps allow for the visulization of distinct geographical zones with different colors to indicate different attributes. In order to use the Plotly Choropleth example, we need to install the following. ! pip install - U plotly from urllib.request import urlopen import json import pandas as pd import plotly.express as px NOTE: We need to upgrade our version of Plotly to the latest to ensure that Choropleth works! Now, we can use the Plotly datasets in order to visualize the unemployment in the United States. with urlopen ( 'https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json' ) as response : counties = json . load ( response ) df = pd . read_csv ( \"https://raw.githubusercontent.com/plotly/datasets/master/fips-unemp-16.csv\" , dtype = { \"fips\" : str }) fig = px . choropleth ( df , geojson = counties , locations = 'fips' , color = 'unemp' , color_continuous_scale = \"Viridis\" , range_color = ( 0 , 12 ), scope = \"usa\" , labels = { 'unemp' : 'unemployment rate' } ) fig . update_layout ( margin = { \"r\" : 0 , \"t\" : 0 , \"l\" : 0 , \"b\" : 0 }) fig . show () As seen, it's quite a detailed, interactive map! NOTE: For more information on Maps, feel free to check out the following resources: Choropleth We turn to the next booth and continue reading... Elysium of Elements 02","title":"Choropleth (Maps)"},{"location":"learn/11_elysium-elements/#bootstrap-bliss","text":"As with Plotly, there are dozens of other unique Bootstrap components that can be incorporated into one's dashboard. Although we've covered the core elements, we'll explore three more in this section. NOTE: For a comprehensive list on all bootstrap components, feel free to check out: Dash Bootstrap","title":"Bootstrap Bliss"},{"location":"learn/11_elysium-elements/#progress-bars","text":"Progress bars are horizontal, rounded rectangles that are quite flexible when it comes to displaying progress. Here's an example of a progress bar with three distinct sections. progress = dbc . Progress ( [ dbc . Progress ( value = 20 , color = \"success\" , bar = True ), dbc . Progress ( value = 30 , color = \"warning\" , bar = True ), dbc . Progress ( value = 20 , color = \"danger\" , bar = True ), ], multi = True , ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Col ( progress , width = 6 ) ]) app . run_server ( mode = 'external' ) As seen, each bar section has a different color and length ( value ). This bar can also be animated , controlled via a button that toggles the bar on and off. progress = html . Div ( [ dbc . Progress ( value = 80 , id = \"animated-progress\" , animated = False , striped = True ), dbc . Button ( \"Toggle animation\" , id = \"animation-toggle\" , className = \"mt-3\" , n_clicks = 0 , ), ] ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Col ( progress , width = 6 ) ]) @app . callback ( dash . dependencies . Output ( \"animated-progress\" , \"animated\" ), [ dash . dependencies . Input ( \"animation-toggle\" , \"n_clicks\" )], [ dash . dependencies . State ( \"animated-progress\" , \"animated\" )], ) def toggle_animation ( n , animated ): if n : return not animated return animated app . run_server ( mode = 'external' ) Ah-ah, one interesting addition is the variable dash.dependencies.State as part of our app's callback. This simply means that the state of the progress bar (whether it is currently animated or not) is also used to determine the output. This makes sense, since our toggle button inverts whatever the state of the progress bar is. NOTE: For more information on progress bars, feel free to check out the following resources: Progress","title":"Progress Bars"},{"location":"learn/11_elysium-elements/#spinners","text":"Next up, spinners! These components are small circles that move to indicate that a process is occurring. Here are three examples (one small, one big, and one growing). spinners = html . Div ( [ dbc . Row ([ dbc . Col ( dbc . Spinner ( size = \"sm\" , color = \"info\" ), width = 1 ), dbc . Col ( dbc . Spinner ( spinner_style = { \"width\" : \"3rem\" , \"height\" : \"3rem\" }, color = \"success\" ), width = 1 ), dbc . Col ( dbc . Spinner ( color = \"danger\" , type = \"grow\" ), width = 1 ), ]) ] ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Col ( spinners , width = 6 ) ]) app . run_server ( mode = 'external' ) Each can be easily colored, resized, and toggled between traditional mode and growing mode. Spinners can also be used to indicate loading, or to be displayed upon a user action . For example, the following displays a spinner based on the number of times the button is pressed. After the time has elapsed, the spinner is replaced with the output. import time loading_spinner = html . Div ( [ dbc . Button ( \"Counter\" , id = \"loading-button\" , n_clicks = 0 ), dbc . Spinner ( html . Div ( id = \"loading-output\" )), ] ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Col ( loading_spinner , width = 3 ) ]) @app . callback ( dash . dependencies . Output ( \"loading-output\" , \"children\" ), [ dash . dependencies . Input ( \"loading-button\" , \"n_clicks\" )] ) def load_output ( n ): if n : time . sleep ( 1 ) return f \"You have clicked { n } times\" return \"No clicks as of yet ;(\" app . run_server ( mode = 'external' ) NOTE: For more information on spinners, feel free to check out the following resources: Dash Spinners","title":"Spinners"},{"location":"learn/11_elysium-elements/#alerts","text":"Next up, Dash Alerts! These components are used to display important information, such as messages, information the user should know before proceeding , or any other form of alerts. Like all bootstrap, they are quite flexible. Here's an example with two alerts, one of them dismissible (able to be closed) and the other permanent . alerts = html . Div ([ dbc . Alert ( \"This is a success alert! Luckily, I won't leave!\" , color = \"success\" ), dbc . Alert ( \"This is a warning alert, but you can close me!\" , color = \"warning\" , dismissable = True ), ]) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Col ( alerts , width = 6 ) ]) app . run_server ( mode = 'external' ) These alarms can be easily customized in terms of color and content. Additionally, they can be set to automatically disappear after a certain amount of time . This is done via the keyword duration , which takes in milliseconds. Here's an example with a disappearing alert, accompanied by a button that toggles the state of the alert. alert = html . Div ( [ dbc . Button ( \"Switch States\" , id = \"alert-toggle-auto\" , className = \"mr-1\" , n_clicks = 0 ), html . Hr (), dbc . Alert ( \"I will disappear in 3 seconds...\" , id = \"alert-auto\" , color = \"danger\" , is_open = True , duration = 3000 , # In milliseconds ), ] ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Col ( alert , width = 6 ) ]) @app . callback ( dash . dependencies . Output ( \"alert-auto\" , \"is_open\" ), [ dash . dependencies . Input ( \"alert-toggle-auto\" , \"n_clicks\" )], [ dash . dependencies . State ( \"alert-auto\" , \"is_open\" )], ) def toggle_alert ( n , is_open ): if n : return not is_open return is_open app . run_server ( mode = 'external' ) Quite handy, especially to help users navigate a dashboard for the first time! NOTE: For more information on alerts, feel free to check out the following resources: Dash Alerts A booming voice announces, \"Dear dashboarders, our time in the Elysium is almost up. However, before continuing, let's take a closer look to see all the powerful Plotly + Dash that you've learned along the way\" Elysium of Elements 03","title":"Alerts"},{"location":"learn/11_elysium-elements/#dash-dreamland","text":"There are hundreds of more Dash elements, including Dash Core Components, Dash Bootstrap Components, Plotly, Ploly Express, HTML , and more . Diving into these elements is beyond the scope of this introductory journey! However, here's a quick summary of everything we've learned along the way, a sort of cheat-sheet... Plotly Charts Dash/Tigergraph HTML Dash Core Bootstrap Bar Charts Layout Functions Div Graphs Cards Line Charts Styling App Headers Markdown Row/Col Pie Charts Multi-Paged Paragraph Location Badges Scatter Plots Callbacks Bold/Italic Links ListGroup Cytoscape Navbars Center Input Jumbotron Radar Charts Sidebars Link Dropdown Button 3-D Figures Create Solution Hr. Rule Table Choropleth Connect w/ pyTG Line Break Progress Install Queries Image Spinner Run Queries Alert Feel free to utilize the \"Search\" box at the top right of this webpage to quickly reference each. We've learned quite a lot within the span of less than a dozen chapters \ud83d\ude04. \"Now, it is time to complete your quest .\" The mysterious figure who greeted us returns, and with a wave of their hands, we find ourselves sitting across from them at a round table. A sign behind them reads, \"Destination Deployment\" All code segments from this chapter can be found in this Colab Notebook . Feel free to follow along! \u21a9 Everything we've installed so far (prerequistes for next section): ! pip install - q pyTigerGraph import pyTigerGraph as tg TG_SUBDOMAIN = 'healthcare-dash' TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio Link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph conn = tg . TigerGraphConnection ( host = TG_HOST , graphname = TG_GRAPHNAME , username = TG_USERNAME , password = TG_PASSWORD , beta = True ) conn . apiToken = conn . getToken ( conn . createSecret ()) ! pip install - q jupyter - dash import dash import dash_html_components as html from jupyter_dash import JupyterDash import plotly.express as px import pandas as pd import plotly.graph_objects as go import dash_core_components as dcc ! pip install dash - bootstrap - components import dash_bootstrap_components as dbc ! pip install dash - cytoscape import dash_cytoscape as cyto import numpy as np ! pip install - U plotly from urllib.request import urlopen import json import pandas as pd import plotly.express as px import time \u21a9","title":"Dash Dreamland"},{"location":"learn/12_destination-deployment/","text":"Destination Deployment \u2728 \u00b6 The figure examined our laptop and smiled, \"I am the user. It is I who tasked you with this quest. I couldn't be more proud of what you've learned and built in such a short time. But there's still one last step left before the completion of your adventure: sharing your work with others. Listen closely, and I'll show you two ways to deploy your dashboard...\" Destination Deployment 01 Heroku, Dash Enterprise \u00b6 According to the Plotly Website, \"Heroku is one of the easiest platforms for deploying and managing public Flask applications.\" Plotly Dash documents the step-by-step procedure needed to deploy one's app on Heroku . Additional Resource: Medium Guide 1 Additional Resource: Medium Guide 2 Another option is via the paid Dash Enterprise platform. Both options are doucmented by Plotly below. window.getElementById('heroku').scrollTo(2000, 2000); \"And after the deployment, I only have one thing left to say...\" Destination Deployment 02 The Fantastic Finale \u00b6 Congratulations! You've put together (and maybe even deployed) your dashboard with TigerGraph + Plotly . It's time to celebrate now! \ud83e\udd73\ud83e\udd73\ud83e\udd73 Feel free to continue adding, maybe with a few queries and some of the elements from \"Elysium of Elements\" . Additionally, there are quite a few examples of other Starter Kits under the \"Examples\" tab!. Finally, make sure to connect with the TigerGraph + Plotly community (found under the \"Community\" tab). Best of luck, and remember to share your cool work with others in the developer world! Congratulations, you've completed TigerGraph's Dash Adventure!","title":"Ch 12 - Destination Deployment"},{"location":"learn/12_destination-deployment/#destination-deployment","text":"The figure examined our laptop and smiled, \"I am the user. It is I who tasked you with this quest. I couldn't be more proud of what you've learned and built in such a short time. But there's still one last step left before the completion of your adventure: sharing your work with others. Listen closely, and I'll show you two ways to deploy your dashboard...\" Destination Deployment 01","title":"Destination Deployment \u2728"},{"location":"learn/12_destination-deployment/#heroku-dash-enterprise","text":"According to the Plotly Website, \"Heroku is one of the easiest platforms for deploying and managing public Flask applications.\" Plotly Dash documents the step-by-step procedure needed to deploy one's app on Heroku . Additional Resource: Medium Guide 1 Additional Resource: Medium Guide 2 Another option is via the paid Dash Enterprise platform. Both options are doucmented by Plotly below. window.getElementById('heroku').scrollTo(2000, 2000); \"And after the deployment, I only have one thing left to say...\" Destination Deployment 02","title":"Heroku, Dash Enterprise"},{"location":"learn/12_destination-deployment/#the-fantastic-finale","text":"Congratulations! You've put together (and maybe even deployed) your dashboard with TigerGraph + Plotly . It's time to celebrate now! \ud83e\udd73\ud83e\udd73\ud83e\udd73 Feel free to continue adding, maybe with a few queries and some of the elements from \"Elysium of Elements\" . Additionally, there are quite a few examples of other Starter Kits under the \"Examples\" tab!. Finally, make sure to connect with the TigerGraph + Plotly community (found under the \"Community\" tab). Best of luck, and remember to share your cool work with others in the developer world! Congratulations, you've completed TigerGraph's Dash Adventure!","title":"The Fantastic Finale"},{"location":"quick/01_notes/","text":"Installation, First Dash App \u00b6 Ch 01 - Installation \u00b6 Creating our Solution Creating our Solution \u00b6 Welcome to Step 1 of the Beginner\u2019s Guide to Dashboarding! In order to load and store the data for our dashboard, we must create a new TigerGraph solution. To do this, we can: Navigate to TigerGraph\u2019s Cloud Portal Login/Register for free using our email address Click on the blue \u201cCreate Solution\u201d button Nagvigate to the Healthcare tab Select \u201cHealthcare Engine\u201d Starter Kit NOTE: For the purposes of learning dashboarding, we will be using TigerGraph\u2019s Healthcare Engine Starter Kit. This Starter Kit comes with over # vertices, # edges, and [still need to finish researching this] data attributes. Next, we must enter the details for our solution. Name - This we can simply keep as \"Healthcare Engine\" Tags - We can add \"Dashboard\", \"Healthcare\" Password - By default, it's \"tigergraph\" Subdomain - This can be \"healthcare-dash\" NOTE: Make sure that your subdomain name is unique! (two solutions cannot have the same subdomain at the same time. This subdomain name is used to access your solution (via GraphStudio, for example) Once this has been completed, click \u201cNext\u201d and then \u201cSubmit\u201d . And voila, in a few seconds, our solution should go from \u201cUninitialized\u201d to \u201cReady\u201d! Loading our Data Loading our Data \u00b6 Ahh, you've reached Step 2 of the Beginner\u2019s Guide to Dashboarding! Next up, it\u2019s time to load in our data. To do this, we need to: Open GraphStudio by selecting it from the Applications tab Click on MyGraph . This is the graph we\u2019ll be using NOTE: Additional graphs can be added, deleted, and modified as desired by the user. For the purposes of this dashboard, we will be using the default graph the Healthcare Engine Starter Kit comes with. Time to take a look at our schema! Navigate over to the \u201cDesign Schema\u201d tab on the right. This is our schema, the blueprint of our graph. It consists of vertices connected to one another via edges. Each vertex can be of a different type and contain different attributes. Similarly, edges can be directional, undirected, and even reversed. Each edge can contain different attributes as well, each with multiple datatypes. Hovering over each component, we see that our schema in this Starter Kit consists of: NOTE: This schema can be modified by switching to \u201cGlobal View\u201d and editing the properties of each vertex and edge. Additionally, vertices and edges may be added and deleted. For a comprehensive guide on creating your own schemas, make sure to check out these resources: TigerGraph Docs , YouTube GSQL 101 Next, we can navigate to the \u201cMap Data to Graph\u201d tab. This section ensures that the raw CSV data files are imported correctly into our graph. Each column is mapped to the appropriate attribute in the appropriate vertex/edge. In order to modify this mapping, we can simply click the \u201cEdit Data Mapping\u201d icon at the top and select the file and component(s) we wish to map. Next, we click on the source column in the CSV file and match it to the corresponding attribute. When we\u2019re all finished, we can click the \u201cPublish Data Mapping\u201d icon at the top left corner. Everything here looks good! Next up, we can navigate to the \u201cLoad Data\u201d tab. Simply press on the white play icon at the top left corner and the loading job should begin automatically. The graph on the right-side displays the progress with respect to time. When the loading has finished, all CSV files should say \u201cfinished\u201d . Connecting wtih pyTG Connecting with pyTG \u00b6 Surprised you made this far, eh? Step 3 of the Beginner\u2019s Guide to Dashboarding! In order to interface with our Graph, we will utilize pyTigerGraph . To begin, we can simply install this package by running the following command. ! pip install - q pyTigerGraph import pyTigerGraph as tg Next, we need to use our solution information from before. TG_SUBDOMAIN = \"healthcare-dash\" TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph NOTE: As mentioned in the previous document, subdomain names should be unique! Now, we can run the following lines to establish a connection with our solution. conn = tg . TigerGraphConnection ( host = TG_HOST , username = TG_USERNAME , password = TG_PASSWORD , graphname = TG_GRAPHNAME ) conn . apiToken = conn . getToken ( conn . createSecret ()) print ( \"Connected!\" ) Voila, we\u2019re in! NOTE: All code segments from this chapter can be found in this Colab Notebook . Ch 02 - Setting up (First App) \u00b6 Proper Prerequisites Proper Prerequisites \u00b6 While TigerGraph\u2019s Cloud Portal provides the solution, data, and queries needed to analyze our graph, we need the help of another tool to create our dashboard. With Plotly , the task of doing so is made simple, intuitive, and easy. To begin, we must first install the proper packages. When running Plotly via a Google Colab , we will first need to use the following command: ! pip install - q jupyter - dash Jupyter-dash allows the dashboard to be configured for modification via a Python Notebook . This way, the dashboard is updated in real-time with the modification of any cells. Without using the jupyter-dash package, every change made to the dashboard would have to be followed by a recompilation of the app (quite tedious) . Now, we can import our Python libraries with the following line: import dash from jupyter_dash import JupyterDash import dash_html_components as html The library dash_html_components allows for access to Plotly Dash\u2019s HTML components, allowing us to display HTML elements such as text and linebreaks. We'll cover more of these in the ensuing sections! Functioning First App Functioning First App \u00b6 In order to create our first app, we can simply run the following lines: app = JupyterDash ( __name__ ) app . layout = html . Div ( children = [ html . P ( children = 'Hello Dash' ), ]) app . run_server ( mode = 'external' ) Running the following produces the following output: Dash App running on : http : // 127.0.0.1 : 8050 / Clicking on the link takes us to our first dashboard! Great! Albeit, quite simple \ud83d\ude05. Breaking it down, we can see that our first line initialized the dash app. Since we are running from the Google Colab Notebook, we will use the JupyterDash() constructor instead of the standard app=dash.Dash() constructor. Next, we define the app\u2019s layout. Using an HTML .Div() element, we can divide our content into different sections. It is simply a container used to hold other components and establish a structure in our dashboard. For example, our Div element currently contains one element, represented by the attribute children = [...] . Any components contained in the attribute \u201cchildren\u201d will belong to this html.Div() element. Each children component must be separated by a comma. We can try adding another html.P (a simple paragraph) to our app: app . layout = html . Div ( children = [ html . P ( children = 'Hello Dash' ), html . P ( \u2018 Guess who \u2019 s back ?\u2019 ), ]) Running this will produce the following output to the right: Ahh, you might have noticed that we\u2019ve omitted the children attribute in the second html.P() statement. This is because \u2018children\u2019 is optional and does not to be specified. For example, app . layout = html . Div ([ html . P ( 'Hello Dash' ), html . P ( \u2018 Guess who \u2019 s back ?\u2019 ), ]) Running this will produce the following output to the right: See, same result as above! NOTE: For more information on .Div(), make sure to check out the following resources: html.Div() Using Layout Functions Using Layout Functions \u00b6 We can create a function to return information to be displayed in our app. This will help make our layout cleaner, more readable, and easier to scale . All content can simply be wrapped in an html.Div() element. To begin, we can add the following functions and change our layout: def setup_TG (): row = html . Div ([ html . P ( \"Connected to TigerGraph Solution Subdomain:\" , TG_SUBDOMAIN ) html . P ( \"Currently working on Graph title:\" , TG_GRAPHNAME ) ]) return row app . layout = html . Div ([ html . P ( \u201c Welcome to Dash \u201d ) setup_TG () ]) And voila, as seen, our app now looks like the following: These functions can come in quite handy when creating complicated layouts. Transforming Text Transforming Text \u00b6 Dash\u2019s text elements are quite powerful . Here are a few simple ways to spice it up! We can modify our simple app as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 TITLE_STYLE = { \"background-color\" : \"#abc7ed\" , \"margin-bottom\" : \"20px\" , \"padding\" : \"5px\" } def setup_TG (): row = html . Div ([ html . P ( html . B ( \"Connected to Solution: \" + TG_SUBDOMAIN ), style = { 'color' : 'green' }), html . P ( html . I ( \"Currently working on Graph title: \" + TG_GRAPHNAME ), style = { 'color' : 'blue' }) ]) return row app = JupyterDash ( __name__ ) app . layout = html . Div ([ html . Div ( html . H1 ( \"Welcome to Dash\" ), style = TITLE_STYLE ), # Adding style, header setup_TG () # Adding style, bold, italics ]) app . run_server ( mode = 'external' ) Here's the resulting output: Let's break it down, component by component! HTML Headers \u00b6 One of the easiest ways to spice up one's dashboard is to vary the text styles . This can be done using simple HTML header elements (H1, H2, H3, H4, H5, H6) . A table showing each one's output can be found below. Header 1 Headers 4 - 6 Header 3 Header 4 Header 5 Header 6 What's Up? Good Day. Bless You! Well done. Happy Birthday! Goodbye? The specific style of each will change based on the font. However, the relative sizes can be seen above. NOTE: For more information on HTML, feel free to check out the following resources: Dash Headers , Dash HTML In line 18 of our code snippet, we see that our html.P() element is now html.H1() . 18 html . Div ( html . H1 ( \"Welcome to Dash\" ), style = TITLE_STYLE ), # Adding style, header Pretty simple and effective! Ahh, you may have noticed the html.Div() element that the header is wrapped in . Let's take a closer look at the reason for this... Style Dictionary \u00b6 One of the best ways to style a dashboard is to use a style dictionary . In these dictionaries, one can specify attributes such as background color, padding, margins, font style, font color, etc . In lines 1- 5, we explicitly create a style dictionary titled TITLE_STYLE . 1 2 3 4 5 TITLE_STYLE = { \"background-color\" : \"#abc7ed\" , \"margin-bottom\" : \"20px\" , \"padding\" : \"5px\" } This dictionary is then passed into the html.Div() element which contains our header. As a result, the header is given extra padding, margin, and a light-blue background . Pretty straightforward! This style dictionary doesn't have to be stored in a variable . In lines 9 and 10, we explicitly change the colors of each html.P() using the keyword style . 9 10 html . P ( html . B ( \"Connected to Solution: \" + TG_SUBDOMAIN ), style = { 'color' : 'green' }), html . P ( html . I ( \"Currently working on Graph title: \" + TG_GRAPHNAME ), style = { 'color' : 'blue' }) NOTE: Color can take both keywords (ex. common colors like red, orange) as well as hex values (ex. 'DD659F') This brings us to our next point, the html.B() and html.I() used in lines 9 and 10. Html.B(), Html.I() \u00b6 In order to bold or italicize sections of text, we can simply use html.B() and html.I() These elements can stand on their own without being wrapped in html.P() elements. However, this removes the division between two lines . For example, the following two lines produce the following output: 9 10 html . B ( \"Connected to Solution: \" + TG_SUBDOMAIN , style = { 'color' : 'green' }), html . I ( \"Currently working on Graph title: \" + TG_GRAPHNAME , style = { 'color' : 'blue' }) NOTE: For more information on these two elements, feel free to check out the following: html.B() , html.I() There are so many more ways to transform text! We'll cover other methods in Chapter 05 - Sheriff Styles ! NOTE: All code segments from this chapter can be found in this Colab Notebook .","title":"Installation, First Dash App"},{"location":"quick/01_notes/#installation-first-dash-app","text":"","title":"Installation, First Dash App"},{"location":"quick/01_notes/#ch-01-installation","text":"Creating our Solution","title":"Ch 01 - Installation"},{"location":"quick/01_notes/#creating-our-solution","text":"Welcome to Step 1 of the Beginner\u2019s Guide to Dashboarding! In order to load and store the data for our dashboard, we must create a new TigerGraph solution. To do this, we can: Navigate to TigerGraph\u2019s Cloud Portal Login/Register for free using our email address Click on the blue \u201cCreate Solution\u201d button Nagvigate to the Healthcare tab Select \u201cHealthcare Engine\u201d Starter Kit NOTE: For the purposes of learning dashboarding, we will be using TigerGraph\u2019s Healthcare Engine Starter Kit. This Starter Kit comes with over # vertices, # edges, and [still need to finish researching this] data attributes. Next, we must enter the details for our solution. Name - This we can simply keep as \"Healthcare Engine\" Tags - We can add \"Dashboard\", \"Healthcare\" Password - By default, it's \"tigergraph\" Subdomain - This can be \"healthcare-dash\" NOTE: Make sure that your subdomain name is unique! (two solutions cannot have the same subdomain at the same time. This subdomain name is used to access your solution (via GraphStudio, for example) Once this has been completed, click \u201cNext\u201d and then \u201cSubmit\u201d . And voila, in a few seconds, our solution should go from \u201cUninitialized\u201d to \u201cReady\u201d! Loading our Data","title":"Creating our Solution"},{"location":"quick/01_notes/#loading-our-data","text":"Ahh, you've reached Step 2 of the Beginner\u2019s Guide to Dashboarding! Next up, it\u2019s time to load in our data. To do this, we need to: Open GraphStudio by selecting it from the Applications tab Click on MyGraph . This is the graph we\u2019ll be using NOTE: Additional graphs can be added, deleted, and modified as desired by the user. For the purposes of this dashboard, we will be using the default graph the Healthcare Engine Starter Kit comes with. Time to take a look at our schema! Navigate over to the \u201cDesign Schema\u201d tab on the right. This is our schema, the blueprint of our graph. It consists of vertices connected to one another via edges. Each vertex can be of a different type and contain different attributes. Similarly, edges can be directional, undirected, and even reversed. Each edge can contain different attributes as well, each with multiple datatypes. Hovering over each component, we see that our schema in this Starter Kit consists of: NOTE: This schema can be modified by switching to \u201cGlobal View\u201d and editing the properties of each vertex and edge. Additionally, vertices and edges may be added and deleted. For a comprehensive guide on creating your own schemas, make sure to check out these resources: TigerGraph Docs , YouTube GSQL 101 Next, we can navigate to the \u201cMap Data to Graph\u201d tab. This section ensures that the raw CSV data files are imported correctly into our graph. Each column is mapped to the appropriate attribute in the appropriate vertex/edge. In order to modify this mapping, we can simply click the \u201cEdit Data Mapping\u201d icon at the top and select the file and component(s) we wish to map. Next, we click on the source column in the CSV file and match it to the corresponding attribute. When we\u2019re all finished, we can click the \u201cPublish Data Mapping\u201d icon at the top left corner. Everything here looks good! Next up, we can navigate to the \u201cLoad Data\u201d tab. Simply press on the white play icon at the top left corner and the loading job should begin automatically. The graph on the right-side displays the progress with respect to time. When the loading has finished, all CSV files should say \u201cfinished\u201d . Connecting wtih pyTG","title":"Loading our Data"},{"location":"quick/01_notes/#connecting-with-pytg","text":"Surprised you made this far, eh? Step 3 of the Beginner\u2019s Guide to Dashboarding! In order to interface with our Graph, we will utilize pyTigerGraph . To begin, we can simply install this package by running the following command. ! pip install - q pyTigerGraph import pyTigerGraph as tg Next, we need to use our solution information from before. TG_SUBDOMAIN = \"healthcare-dash\" TG_HOST = \"https://\" + TG_SUBDOMAIN + \".i.tgcloud.io\" # GraphStudio link TG_USERNAME = \"tigergraph\" # This should remain the same... TG_PASSWORD = \"tigergraph\" # Shh, it's our password! TG_GRAPHNAME = \"MyGraph\" # The name of the graph NOTE: As mentioned in the previous document, subdomain names should be unique! Now, we can run the following lines to establish a connection with our solution. conn = tg . TigerGraphConnection ( host = TG_HOST , username = TG_USERNAME , password = TG_PASSWORD , graphname = TG_GRAPHNAME ) conn . apiToken = conn . getToken ( conn . createSecret ()) print ( \"Connected!\" ) Voila, we\u2019re in! NOTE: All code segments from this chapter can be found in this Colab Notebook .","title":"Connecting with pyTG"},{"location":"quick/01_notes/#ch-02-setting-up-first-app","text":"Proper Prerequisites","title":"Ch 02 - Setting up (First App)"},{"location":"quick/01_notes/#proper-prerequisites","text":"While TigerGraph\u2019s Cloud Portal provides the solution, data, and queries needed to analyze our graph, we need the help of another tool to create our dashboard. With Plotly , the task of doing so is made simple, intuitive, and easy. To begin, we must first install the proper packages. When running Plotly via a Google Colab , we will first need to use the following command: ! pip install - q jupyter - dash Jupyter-dash allows the dashboard to be configured for modification via a Python Notebook . This way, the dashboard is updated in real-time with the modification of any cells. Without using the jupyter-dash package, every change made to the dashboard would have to be followed by a recompilation of the app (quite tedious) . Now, we can import our Python libraries with the following line: import dash from jupyter_dash import JupyterDash import dash_html_components as html The library dash_html_components allows for access to Plotly Dash\u2019s HTML components, allowing us to display HTML elements such as text and linebreaks. We'll cover more of these in the ensuing sections! Functioning First App","title":"Proper Prerequisites"},{"location":"quick/01_notes/#functioning-first-app","text":"In order to create our first app, we can simply run the following lines: app = JupyterDash ( __name__ ) app . layout = html . Div ( children = [ html . P ( children = 'Hello Dash' ), ]) app . run_server ( mode = 'external' ) Running the following produces the following output: Dash App running on : http : // 127.0.0.1 : 8050 / Clicking on the link takes us to our first dashboard! Great! Albeit, quite simple \ud83d\ude05. Breaking it down, we can see that our first line initialized the dash app. Since we are running from the Google Colab Notebook, we will use the JupyterDash() constructor instead of the standard app=dash.Dash() constructor. Next, we define the app\u2019s layout. Using an HTML .Div() element, we can divide our content into different sections. It is simply a container used to hold other components and establish a structure in our dashboard. For example, our Div element currently contains one element, represented by the attribute children = [...] . Any components contained in the attribute \u201cchildren\u201d will belong to this html.Div() element. Each children component must be separated by a comma. We can try adding another html.P (a simple paragraph) to our app: app . layout = html . Div ( children = [ html . P ( children = 'Hello Dash' ), html . P ( \u2018 Guess who \u2019 s back ?\u2019 ), ]) Running this will produce the following output to the right: Ahh, you might have noticed that we\u2019ve omitted the children attribute in the second html.P() statement. This is because \u2018children\u2019 is optional and does not to be specified. For example, app . layout = html . Div ([ html . P ( 'Hello Dash' ), html . P ( \u2018 Guess who \u2019 s back ?\u2019 ), ]) Running this will produce the following output to the right: See, same result as above! NOTE: For more information on .Div(), make sure to check out the following resources: html.Div() Using Layout Functions","title":"Functioning First App"},{"location":"quick/01_notes/#using-layout-functions","text":"We can create a function to return information to be displayed in our app. This will help make our layout cleaner, more readable, and easier to scale . All content can simply be wrapped in an html.Div() element. To begin, we can add the following functions and change our layout: def setup_TG (): row = html . Div ([ html . P ( \"Connected to TigerGraph Solution Subdomain:\" , TG_SUBDOMAIN ) html . P ( \"Currently working on Graph title:\" , TG_GRAPHNAME ) ]) return row app . layout = html . Div ([ html . P ( \u201c Welcome to Dash \u201d ) setup_TG () ]) And voila, as seen, our app now looks like the following: These functions can come in quite handy when creating complicated layouts. Transforming Text","title":"Using Layout Functions"},{"location":"quick/01_notes/#transforming-text","text":"Dash\u2019s text elements are quite powerful . Here are a few simple ways to spice it up! We can modify our simple app as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 TITLE_STYLE = { \"background-color\" : \"#abc7ed\" , \"margin-bottom\" : \"20px\" , \"padding\" : \"5px\" } def setup_TG (): row = html . Div ([ html . P ( html . B ( \"Connected to Solution: \" + TG_SUBDOMAIN ), style = { 'color' : 'green' }), html . P ( html . I ( \"Currently working on Graph title: \" + TG_GRAPHNAME ), style = { 'color' : 'blue' }) ]) return row app = JupyterDash ( __name__ ) app . layout = html . Div ([ html . Div ( html . H1 ( \"Welcome to Dash\" ), style = TITLE_STYLE ), # Adding style, header setup_TG () # Adding style, bold, italics ]) app . run_server ( mode = 'external' ) Here's the resulting output: Let's break it down, component by component!","title":"Transforming Text"},{"location":"quick/01_notes/#html-headers","text":"One of the easiest ways to spice up one's dashboard is to vary the text styles . This can be done using simple HTML header elements (H1, H2, H3, H4, H5, H6) . A table showing each one's output can be found below. Header 1 Headers 4 - 6 Header 3 Header 4 Header 5 Header 6","title":"HTML Headers"},{"location":"quick/01_notes/#style-dictionary","text":"One of the best ways to style a dashboard is to use a style dictionary . In these dictionaries, one can specify attributes such as background color, padding, margins, font style, font color, etc . In lines 1- 5, we explicitly create a style dictionary titled TITLE_STYLE . 1 2 3 4 5 TITLE_STYLE = { \"background-color\" : \"#abc7ed\" , \"margin-bottom\" : \"20px\" , \"padding\" : \"5px\" } This dictionary is then passed into the html.Div() element which contains our header. As a result, the header is given extra padding, margin, and a light-blue background . Pretty straightforward! This style dictionary doesn't have to be stored in a variable . In lines 9 and 10, we explicitly change the colors of each html.P() using the keyword style . 9 10 html . P ( html . B ( \"Connected to Solution: \" + TG_SUBDOMAIN ), style = { 'color' : 'green' }), html . P ( html . I ( \"Currently working on Graph title: \" + TG_GRAPHNAME ), style = { 'color' : 'blue' }) NOTE: Color can take both keywords (ex. common colors like red, orange) as well as hex values (ex. 'DD659F') This brings us to our next point, the html.B() and html.I() used in lines 9 and 10.","title":"Style Dictionary"},{"location":"quick/01_notes/#htmlb-htmli","text":"In order to bold or italicize sections of text, we can simply use html.B() and html.I() These elements can stand on their own without being wrapped in html.P() elements. However, this removes the division between two lines . For example, the following two lines produce the following output: 9 10 html . B ( \"Connected to Solution: \" + TG_SUBDOMAIN , style = { 'color' : 'green' }), html . I ( \"Currently working on Graph title: \" + TG_GRAPHNAME , style = { 'color' : 'blue' }) NOTE: For more information on these two elements, feel free to check out the following: html.B() , html.I() There are so many more ways to transform text! We'll cover other methods in Chapter 05 - Sheriff Styles ! NOTE: All code segments from this chapter can be found in this Colab Notebook .","title":"Html.B(), Html.I()"},{"location":"quick/02_notes/","text":"Plotly, Dash, Style Comps \u00b6 Ch 03 - Plotly \u00b6 Plotly Express and Pandas Plotly Express and Pandas \u00b6 Before beginning to graph with Plotly, we need to import Plotly Express! Plotly Express is a high-level wrapper that allows for the creation of simple visualizations with minimal lines of code. It has numerous features, yet is still intuitive and consistent in terms of the syntax used across multiple chart types. To import the library, we run the following line: import plotly.express as px Next, we need to import the Pandas library. Pandas allows for the creation of dataframes, structured storage systems that integrate easily with Plotly Express. These dataframes can be thought of as data tables or spreadsheets . To import the library, we run the following line: import pandas as pd And that's it! Bar Charts Bar Charts \u00b6 There are a few options to create a bar chart! Loading Data \u00b6 With DataFrame When creating a bar chart, we can use a Pandas Dataframe : raw_data = { 'Animals' : [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ], 'Counts' : [ 2 , 4 , 8 , 4 , 2 ] } df = pd . DataFrame . from_dict ( raw_data ) bar = px . bar ( raw_data , x = 'Animals' , y = 'Counts' ) bar . show () As seen, we pass in the dataframe and specify the x and y column titles . Without DataFrame Here, we can simply pass in two arrays, one for each of x and y. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ] counts = [ 2 , 4 , 8 , 4 , 2 ] bar = px . bar ( x = animals , y = counts ) bar . show () Even if we don't create a dataframe, Plotly will perform this action under-the-hood when generating the bar chart. In both cases, we get the same result. And voila, here are our two bar charts! Ahh, you may have noticed a small difference: the axis labels! When we passed in two arrays, we never specified what the axes were to be titled . How do we fix this and further style our charts? To that, we turn to Plotly's myriad ways of customizing charts . Styling Figure \u00b6 There are many ways to style a bar chart. Here are some of the most important ones! Adding a Title, Axis Labels We can add a title with the following function, bar.update_layout() : animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ] counts = [ 2 , 4 , 8 , 2 , 4 ] bar = px . bar ( x = animals , y = counts ) bar . update_layout ( title = \"Animals vs. Appendages\" , # Adding a title xaxis_title = \"The Amazing Animals\" , # Changing x-axis label yaxis_title = \"How many appendages?\" , # Changing y-axis label font = dict ( family = \"Courier New, monospace\" , # The font style color = \"RebeccaPurple\" , # The font color size = 18 # The font size ) ) bar . show () Adding Color In order to individually select colors for our bar chart, we can use the following: animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ] counts = [ 2 , 4 , 8 , 2 , 4 ] # As seen, each bar segment that hasn't had a discrete color entered will be shown in black bar = px . bar ( x = animals , y = counts , color_discrete_sequence = [[ '#65ff31' , '#4a4aff' , '#aa00aa' ]]) bar . show () We can also use the following argument to make each column visually represent its value . raw_data = { 'Animals' : [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ], 'Counts' : [ 2 , 4 , 8 , 2 , 4 ] } df = pd . DataFrame . from_dict ( raw_data ) # Creates a side color chart --> each color represents count bar = px . bar ( df , x = 'Animals' , y = 'Counts' , color = 'Counts' ) bar . show () As seen, it's just a matter of adding the \"color\" argument! Changing Orientation In order to make the bar chart horizontal, we can simply add the orientation='h' argument. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ] counts = [ 2 , 4 , 8 , 2 , 4 ] # Notice that we've had to switch the axes! bar = px . bar ( x = counts , y = animals , orientation = 'h' ) bar . show () NOTE: As mentioned in the above comments, we've had to switch the axes in this horizontal layout! Width and Height These can be easily changed via the width and height keywords. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ] counts = [ 2 , 4 , 8 , 2 , 4 ] bar = px . bar ( x = animals , y = counts , width = 800 , height = 400 ) bar . show () All Put Together Using these elements, we can create the following bar chart: raw_data = { 'Animals' : [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ], 'Counts' : [ 2 , 4 , 8 , 2 , 4 ] } df = pd . DataFrame . from_dict ( raw_data ) bar = px . bar ( df , x = 'Counts' , y = 'Animals' , orientation = 'h' , color = 'Counts' , width = 800 , height = 400 ) bar . update_layout ( title = \"Animals vs. Appendages\" , # Adding a title yaxis_title = \"The Amazing Animals\" , # Changing x-axis label xaxis_title = \"How many appendages?\" , # Changing y-axis label font = dict ( family = \"Courier New, monospace\" , # The font style color = \"RebeccaPurple\" , # The font color size = 18 # The font size ) ) bar . show () NOTE: For more information, make sure to check out the following: Plotly Bar Charts , px.Bar() Line Charts Line Charts \u00b6 There are a few options to create a line chart! Loading Data \u00b6 Once again, we can either use a Pandas Dataframe or just proceed with arrays! With DataFrame raw_data = { 'Year' : [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ], 'Carbon per Capita' : [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] } df = pd . DataFrame . from_dict ( raw_data ) line = px . line ( df , x = 'Year' , y = 'Carbon per Capita' ) line . show () As seen, we pass in the dataframe and specify the x and y column titles . Without DataFrame Here, we can simply pass in two arrays, one for each of x and y. year = [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ] carbon = [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] line = px . line ( x = year , y = carbon ) line . show () Even if we don't create a dataframe, Plotly will perform this action under-the-hood when generating the line chart. In both cases, we get the same result. And voila, here are our two line charts! Styling Figure \u00b6 The methods to style a line chart are very similar to styling a bar chart! However, one neat feature we haven't covered yet is traces. These are quite effective at visualizing multiple sets of data on the same set of axes. Let's take a closer look! Multiple Traces In order to add multiple traces, we turn to the Plotly Graph Objects library. To import this library, we use the following line: import plotly.graph_objects as go Next, we can create our traces with the .add_trace() function. year = [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ] carbon_USA = [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] carbon_AUS = [ 15.0 , 15.3 , 15.5 , 15.6 , 17.2 , 18.2 , 18.2 , 17.7 , 17.5 , 17.1 , 16.1 , 15.4 , 16.9 , 16.8 ] line = go . Figure () line . add_trace ( go . Scatter ( x = year , y = carbon_USA )) line . add_trace ( go . Scatter ( x = year , y = carbon_AUS )) line . show () Each trace adds a new line (the name go.Scatter() is a bit misleading!) Styling Traces In order to style these traces and change their legend names from 't', we can add the following: year = [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ] carbon_USA = [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] carbon_AUS = [ 15.0 , 15.3 , 15.5 , 15.6 , 17.2 , 18.2 , 18.2 , 17.7 , 17.5 , 17.1 , 16.1 , 15.4 , 16.9 , 16.8 ] line = go . Figure () line . add_trace ( go . Scatter ( x = year , y = carbon_USA , marker = dict ( color = 'MediumPurple' ), name = \"USA Carbon Emissions (per capita)\" )) line . add_trace ( go . Scatter ( x = year , y = carbon_AUS , marker = dict ( color = 'LightSeaGreen' ), name = \"AUS Carbon Emissions (per capita)\" )) line . show () Adding the marker=dict(color='MediumPurple') dictionary allows us to change the color of the two traces. Additionally, the name argument lets us distinguish and label the two traces. Here's the result! We can further style these traces by exploring the marker dictionary: year = [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ] carbon_USA = [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] carbon_AUS = [ 15.0 , 15.3 , 15.5 , 15.6 , 17.2 , 18.2 , 18.2 , 17.7 , 17.5 , 17.1 , 16.1 , 15.4 , 16.9 , 16.8 ] line = go . Figure () line . add_trace ( go . Scatter ( x = year , y = carbon_USA , marker = dict ( size = 25 , color = 'MediumPurple' ), name = \"USA Carbon Emissions (per capita)\" )) line . add_trace ( go . Scatter ( x = year , y = carbon_AUS , marker = dict ( size = 25 , color = 'LightSeaGreen' , symbol = 'square' ), name = \"AUS Carbon Emissions (per capita)\" )) line . show () As seen below, the size and symbols for each trace can be customized as well! All Put Together Using these elements and our stylings from the previous section, we can create the following: year = [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ] carbon_USA = [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] carbon_AUS = [ 15.0 , 15.3 , 15.5 , 15.6 , 17.2 , 18.2 , 18.2 , 17.7 , 17.5 , 17.1 , 16.1 , 15.4 , 16.9 , 16.8 ] line = go . Figure () line . add_trace ( go . Scatter ( x = year , y = carbon_USA , marker = dict ( size = 25 , color = 'MediumPurple' ), name = \"USA Carbon Emissions (per capita)\" )) line . add_trace ( go . Scatter ( x = year , y = carbon_AUS , marker = dict ( size = 25 , color = 'LightSeaGreen' , symbol = 'square' ), name = \"AUS Carbon Emissions (per capita)\" )) line . update_layout ( title = \"Carbon Emissions since 1980 (per capita)\" , xaxis_title = \"Year\" , yaxis_title = \"Annual Emissions in Tons (per capita)\" , plot_bgcolor = 'DarkGrey' , width = 1600 ) line . show () NOTE: For more information, make sure to check out the following: Plotly Line Charts , px.line() Pie Charts Pie Charts \u00b6 There are a few options to create a pie chart! Loading Data \u00b6 When creating a bar chart, we can use a Pandas Dataframe : raw_data = { 'Animals' : [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ], 'Counts' : [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] } df = pd . DataFrame . from_dict ( raw_data ) pie = px . pie ( raw_data , values = 'Counts' , names = 'Animals' ) pie . show () As seen, we pass in the dataframe and specify the x and y column titles . Without DataFrame Here, we can simply pass in two arrays, one for each of x and y. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals ) pie . show () Even if we don't create a dataframe, Plotly will perform this action under-the-hood when generating the pie chart. In both cases, we get the same result. And voila, here are our two bar charts! Unlike with bar charts and line charts, there are truly no differences between each! This is mainly because there are no axes which need labelling \ud83d\ude05. Styling Figure \u00b6 There are many ways to style a bar chart. Here are some of the most important ones! Adding Title, Labels In order to add a title, we can simply pass in the title argument. To change the percentages in each slice into labels, we can use the .update_traces() method. The width of the plot is simply changed via the .update_layouts() method, as done previously. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals , title = \"The Animals of Old McDonald's Farm\" , ) pie . update_traces ( textposition = 'inside' , textinfo = 'label' ) pie . update_layout ( width = 1000 ) pie . show () The title can be centered with the title_x argument, which ranges from 0 to 1. Therefore, setting its value to 0.5 will result in a centered title. Additionally, the .update_traces() method can be modified to include percentages. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals , title = \"The Animals of Old McDonald's Farm\" , ) pie . update_traces ( textposition = 'inside' , textinfo = 'label+percent' ) pie . update_layout ( width = 1000 ) pie . update_layout ( title_x = 0.5 ) pie . show () And here's our centered title (relative to the pie chart). Donuts, Slices \u00b6 Some neat extensions of pie charts includes donuts and slices! In order to create a donut chart, we simply need to add the hole=0.2 argument. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals , title = \"The Animals of Old McDonald's Farm\" , hole = 0.2 , ) pie . update_traces ( textposition = 'inside' , textinfo = 'label+percent' ) pie . update_layout ( width = 1000 ) pie . update_layout ( title_x = 0.5 ) pie . show () In order to highlight specific slices or data values, we can use the pull argument. Here's an example highlighting the Pig slice! animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals , title = \"The Animals of Old McDonald's Farm\" , hole = 0.2 , ) pie . update_traces ( textposition = 'inside' , textinfo = 'label+percent' , pull = [ 0 , 0 , 0 , 0 , 0 , 0 , 0.1 ], ) pie . update_layout ( width = 1000 ) pie . update_layout ( title_x = 0.5 ) pie . show () The length of pull matches the length of animals . Similarly, each value corresponds to a specific animal, in matching result. For example, the last element of pull is 0.1, meaning that the last element of animals , 'Pig', will be pulled out by a factor of 0.1. Let's try applying this knowledge to pull out 'Chicken' and 'Buffalo' as well! animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals , title = \"The Animals of Old McDonald's Farm\" , hole = 0.2 , ) pie . update_traces ( textposition = 'inside' , textinfo = 'label+percent' , opacity = 0.9 , pull = [ 0.2 , 0.3 , 0 , 0 , 0 , 0 , 0.1 ], ) pie . update_layout ( width = 1000 ) pie . update_layout ( title_x = 0.5 ) pie . show () Neat! And with that, we have a rather fancy pie chart put together in less than a dozen lines of code! NOTE: For more information, make sure to check out the following: Plotly Pie Charts , px.Pie() Scatter Plots Scatter Plots \u00b6 As with most other plots, there are a few options to create a scatter plot! Loading Data \u00b6 Here, we'll explore a less-common method with several Star Wars Lego Sets. Each Lego Set is stored as an array of three values: price, piece count, and VIP points. These arrays are added to a list of all eight sets. Using two iterators, we can create a list of prices and pieces (ordered correctly). rep_gunship = [ 349.99 , 3292 , 2275 ]; light_cruiser = [ 159.99 , 1336 , 1040 ] bad_batch_shuttle = [ 99.99 , 969 , 650 ]; meditation_chamber = [ 69.99 , 663 , 455 ] imperial_maurader = [ 39.99 , 478 , 260 ]; mandalorian_forge = [ 29.99 , 258 , 195 ] a_wing = [ 199.99 , 1672 , 1300 ]; razor_crest = [ 129.99 , 1023 , 845 ] sets = [ rep_gunship , light_cruiser , bad_batch_shuttle , meditation_chamber , imperial_maurader , mandalorian_forge , a_wing , razor_crest ] price = [ sets [ i ][ 0 ] for i in range ( len ( sets ))] pieces = [ sets [ i ][ 1 ] for i in range ( len ( sets ))] scatter = px . scatter ( x = price , y = pieces ) scatter . show () Looking good, but let's add some style! Styling Figure \u00b6 Size Attribute One neat way to flavor our scatter plots is to modify the size attribute. Here, we can set the size of each datapoint to match a third attribute. In this case, the third dimension of data will be the number of VIP points earned per set. # Lego Sets from 2021 (Price, Pieces, VIP Points) rep_gunship = [ 349.99 , 3292 , 2275 ]; light_cruiser = [ 159.99 , 1336 , 1040 ] bad_batch_shuttle = [ 99.99 , 969 , 650 ]; meditation_chamber = [ 69.99 , 663 , 455 ] imperial_maurader = [ 39.99 , 478 , 260 ]; mandalorian_forge = [ 29.99 , 258 , 195 ] a_wing = [ 199.99 , 1672 , 1300 ]; razor_crest = [ 129.99 , 1023 , 845 ] sets = [ rep_gunship , light_cruiser , bad_batch_shuttle , meditation_chamber , imperial_maurader , mandalorian_forge , a_wing , razor_crest ] price = [ sets [ i ][ 0 ] for i in range ( len ( sets ))] pieces = [ sets [ i ][ 1 ] for i in range ( len ( sets ))] points = [ sets [ i ][ 2 ] for i in range ( len ( sets ))] scatter = px . scatter ( x = price , y = pieces , size = points ) scatter . show () And ta-da, we can easily visualize that larger sets give the most points! Adding Color As well as representing VIP points by size, we can also represent this data with color. We simply need to add the color argument inside of our px.scatter() function. # Lego Sets from 2021 (Price, Pieces, VIP Points) rep_gunship = [ 349.99 , 3292 , 2275 ]; light_cruiser = [ 159.99 , 1336 , 1040 ] bad_batch_shuttle = [ 99.99 , 969 , 650 ]; meditation_chamber = [ 69.99 , 663 , 455 ] imperial_maurader = [ 39.99 , 478 , 260 ]; mandalorian_forge = [ 29.99 , 258 , 195 ] a_wing = [ 199.99 , 1672 , 1300 ]; razor_crest = [ 129.99 , 1023 , 845 ] sets = [ rep_gunship , light_cruiser , bad_batch_shuttle , meditation_chamber , imperial_maurader , mandalorian_forge , a_wing , razor_crest ] price = [ sets [ i ][ 0 ] for i in range ( len ( sets ))] pieces = [ sets [ i ][ 1 ] for i in range ( len ( sets ))] points = [ sets [ i ][ 2 ] for i in range ( len ( sets ))] scatter = px . scatter ( x = price , y = pieces , size = points , color = points ) scatter . update_coloraxes ( colorbar_title = \"VIP Points\" ) scatter . update_layout ( width = 1000 ) # For better view! scatter . show () Adding Trendline Finally, one useful feature of px.Scatter() is the ability to add trendlines! All it takes is a simple trendline=\"ols\" , where \"ols\" stands for Ordinary Least Squares regression. # Lego Sets from 2021 (Price, Pieces, VIP Points) rep_gunship = [ 349.99 , 3292 , 2275 ]; light_cruiser = [ 159.99 , 1336 , 1040 ] bad_batch_shuttle = [ 99.99 , 969 , 650 ]; meditation_chamber = [ 69.99 , 663 , 455 ] imperial_maurader = [ 39.99 , 478 , 260 ]; mandalorian_forge = [ 29.99 , 258 , 195 ] a_wing = [ 199.99 , 1672 , 1300 ]; razor_crest = [ 129.99 , 1023 , 845 ] sets = [ rep_gunship , light_cruiser , bad_batch_shuttle , meditation_chamber , imperial_maurader , mandalorian_forge , a_wing , razor_crest ] price = [ sets [ i ][ 0 ] for i in range ( len ( sets ))] pieces = [ sets [ i ][ 1 ] for i in range ( len ( sets ))] points = [ sets [ i ][ 2 ] for i in range ( len ( sets ))] scatter = px . scatter ( x = price , y = pieces , size = points , color = points , trendline = \"ols\" ) scatter . update_coloraxes ( colorbar_title = \"VIP Points\" ) scatter . update_layout ( width = 1000 ) # For better view! scatter . show () NOTE: Non-linear regression lines can be added as well! For more information, check out: Plotly Trendlines All Put Together Using these elements and our stylings from the previous section, we can create the following: # Lego Sets from 2021 (Price, Pieces, VIP Points) rep_gunship = [ 349.99 , 3292 , 2275 ]; light_cruiser = [ 159.99 , 1336 , 1040 ] bad_batch_shuttle = [ 99.99 , 969 , 650 ]; meditation_chamber = [ 69.99 , 663 , 455 ] imperial_maurader = [ 39.99 , 478 , 260 ]; mandalorian_forge = [ 29.99 , 258 , 195 ] a_wing = [ 199.99 , 1672 , 1300 ]; razor_crest = [ 129.99 , 1023 , 845 ] sets = [ rep_gunship , light_cruiser , bad_batch_shuttle , meditation_chamber , imperial_maurader , mandalorian_forge , a_wing , razor_crest ] price = [ sets [ i ][ 0 ] for i in range ( len ( sets ))] pieces = [ sets [ i ][ 1 ] for i in range ( len ( sets ))] points = [ sets [ i ][ 2 ] for i in range ( len ( sets ))] scatter = px . scatter ( x = price , y = pieces , size = points , color = points , trendline = \"ols\" ) scatter . update_coloraxes ( colorbar_title = \"VIP Points\" ) scatter . update_layout ( title = \"Lego Star Wars Sets (2021)\" , xaxis_title = \"Price (USD)\" , yaxis_title = \"Total Piece Count\" , width = 1000 ) scatter . show () NOTE: For more information, make sure to check out the following: Plotly Scatter px.Scatter() NOTE: All code segments from this chapter can be found in this Colab Notebook . Ch 04 - Dash \u00b6 Dash's Libraries Dash's Libraries \u00b6 To begin harnessing the power of Dash, we must import the necessary libraries Dash Core \u00b6 Dash's core components are a library of higher-level elements such as tables, graphs, dropdowns, inputs, and links . To use these components, we add the following line: import dash_core_components as dcc NOTE: For a full list of components, feel free to check out the following: Dash Core Documentation Bootstrap \u00b6 Dash allows for the inclusion of native Boostrap components via its Dash Boostrap library. These elements include cards, lists, badges, and more . To use these elements, we install and import the library via the following lines: ! pip install dash - bootstrap - components import dash_bootstrap_components as dbc NOTE: For a full list of components, feel free to check out the following: Dash Boostrap Documentation And voila, we're good to go! Dash Graph Dash Graph \u00b6 The figures made from Plotly are dazzling, but still need to be added into the dashboard! In order to add these charts, we can utilize the dcc.Graph() element. First, we create a function: def getAnimalChart (): raw_data = { 'Animals' : [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ], 'Counts' : [ 2 , 4 , 8 , 2 , 4 ] } df = pd . DataFrame . from_dict ( raw_data ) bar = px . bar ( df , x = 'Counts' , y = 'Animals' , orientation = 'h' , color = 'Counts' , width = 800 , height = 400 ) bar . update_layout ( title = \"Animals vs. Appendages\" , # Adding a title yaxis_title = \"The Amazing Animals\" , # Changing x-axis label xaxis_title = \"How many appendages?\" , # Changing y-axis label font = dict ( family = \"Courier New, monospace\" , # The font style color = \"RebeccaPurple\" , # The font color size = 18 # The font size ) ) return bar This function simply returns our finalized bar chart from the last chapter instead of displaying it. Now, we can add a dcc.Graph() component in our app via the following lines. And here's the result! app = JupyterDash ( __name__ ) app . layout = html . Div ( children = [ html . P ( children = \"Welcome to Dash\" ), dcc . Graph ( id = 'Animal Chart' , figure = getAnimalChart ()) ]) app . run_server ( mode = 'external' ) NOTE: The id attribute is optional, but it's a good practice to include a unique ID for each component. This is especially true for updating figures, which will be covered in a later chapter, \"Confronted by Callbacks\" Pretty straightforward! Now, we can add our Plotly figures to our dashboard \ud83d\ude04 . Dash Cards Dash Cards \u00b6 These graphs we have created are amazing! But not the prettiest... With cards, any component (especially text, images, and figures) can neatly be displayed within a bounded area. These cards can be customized in terms of style, size, color, outline, and more! Basic Elements \u00b6 To get started, we'll create a simple card around our graph from earlier. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ html . P ( children = \"Welcome to Dash\" ), dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Animal Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Animal Chart' , figure = getAnimalChart ()) ]) ], style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" } ) ]) app . run_server ( mode = 'external' ) Alright, let's break it down! At the very top, we must add the Bootstrap external stylesheet in order to utilize the Card component. This stylesheet comes installed with the library and is accessed with external_stylesheets=[dbc.themes.BOOTSTRAP] NOTE: We can add our own custom external stylesheets! We'll dive into this in \"Sheriff Styles\" With our dbc.Card() , we have a Card Body. this dbc.CardBody() contains a header, paragraph, and our graph. You may notice the className attribute. This is a custom CSS styling that was imported from the Bootstrap stylesheet. After this, the dbc.Card() itself contains a style dictionary. In here, we find two attributes: Width - this is simply the width of the card. rem is simply the percentage dimension of the screen. As a result, 55rem means that the card will span 55% of the screen's width. Margin - in particular, the left-most margin has been set to 1% of the screen's width. margin-bottom , margin-top , and margin-right are all valid keywords that can be utilized as well to further adjust our card. And voila, here's our result: Let's try changing some of the colors! Colors, Outlines \u00b6 In order to modify the visual appearance of our cards, we can use the color and outline attributes. color allows for several pre-built options: primary , secondary , info , success , warning , danger , light , and dark . For example, here's what info looks like (a light blue): app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ html . P ( children = \"Welcome to Dash\" ), dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Animal Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Animal Chart' , figure = getAnimalChart ()) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" } ) ]) app . run_server ( mode = 'external' ) We can also create a card to hold our title (looks kind of strange by itself in the top corner \ud83d\ude05) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Welcome to Dash!\" , className = 'card-title' ), ]) ], color = 'dark' , # Options include: primary, secondary, info, success, warning, danger, light, dark inverse = True , style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-top\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ), dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Animal Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Animal Chart' , figure = getAnimalChart ()) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" } ) ]) app . run_server ( mode = 'external' ) There we go, much better now! Ahh, you may have noticed the inverse argument! Setting this to True is helpful when dealing with dark backgrounds as it inverts all text color to white. As a result, we don't have to manually change the title color. NOTE: For more information on dbc.Card(), feel free to check out the following: dbc.Card() Now, what if we want to add multiple cards, but not just continue to vertically stack them? For that, we must turn to rows and columns! Dash Layout Dash Layout \u00b6 The best way to arrange components in our dashboard is via dbc.Row() and dbc.Col() . Let's take a closer look at their power! Creating Cards \u00b6 Before beginning, let's create a few cards for better readability: titleCard titleCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Welcome to Dash!\" , className = 'card-title' ), ]) ], color = 'dark' , # Options include: primary, secondary, info, success, warning, danger, light, dark inverse = True , style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-top\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) animalBarCard def getAnimalBarChart (): raw_data = { 'Animals' : [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ], 'Counts' : [ 2 , 4 , 8 , 2 , 4 ] } df = pd . DataFrame . from_dict ( raw_data ) bar = px . bar ( df , x = 'Counts' , y = 'Animals' , orientation = 'h' , color = 'Counts' , width = 800 , height = 400 ) bar . update_layout ( title = \"Animals vs. Appendages\" , # Adding a title yaxis_title = \"The Amazing Animals\" , # Changing x-axis label xaxis_title = \"How many appendages?\" , # Changing y-axis label font = dict ( family = \"Courier New, monospace\" , # The font style color = \"RebeccaPurple\" , # The font color size = 18 # The font size ) ) return bar animalBarCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Animal Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Animal Chart' , figure = getAnimalBarChart ()) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) carbonLineCard def getCarbonLineChart (): year = [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ] carbon_USA = [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] carbon_AUS = [ 15.0 , 15.3 , 15.5 , 15.6 , 17.2 , 18.2 , 18.2 , 17.7 , 17.5 , 17.1 , 16.1 , 15.4 , 16.9 , 16.8 ] line = go . Figure () line . add_trace ( go . Scatter ( x = year , y = carbon_USA , marker = dict ( size = 25 , color = 'MediumPurple' ), name = \"USA Carbon Emissions (per capita)\" )) line . add_trace ( go . Scatter ( x = year , y = carbon_AUS , marker = dict ( size = 25 , color = 'LightSeaGreen' , symbol = 'square' ), name = \"AUS Carbon Emissions (per capita)\" )) line . update_layout ( title = \"Carbon Emissions since 1980 (per capita)\" , xaxis_title = \"Year\" , yaxis_title = \"Annual Emissions in Tons (per capita)\" , plot_bgcolor = 'DarkGrey' , width = 1600 ) return line carbonLineCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Carbon Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Carbon Chart' , figure = getCarbonLineChart ()) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) animalPieCard def getAnimalPieChart (): animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals , title = \"The Animals of Old McDonald's Farm\" , hole = 0.2 , ) pie . update_traces ( textposition = 'inside' , textinfo = 'label+percent' , opacity = 0.9 , pull = [ 0.2 , 0.3 , 0 , 0 , 0 , 0 , 0.1 ], ) pie . update_layout ( width = 1000 ) pie . update_layout ( title_x = 0.5 ) return pie animalPieCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Animal Pie Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Animal Pie Chart' , figure = getAnimalPieChart ()) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) legoScatterCard def getLegoScatterChart (): rep_gunship = [ 349.99 , 3292 , 2275 ]; light_cruiser = [ 159.99 , 1336 , 1040 ] bad_batch_shuttle = [ 99.99 , 969 , 650 ]; meditation_chamber = [ 69.99 , 663 , 455 ] imperial_maurader = [ 39.99 , 478 , 260 ]; mandalorian_forge = [ 29.99 , 258 , 195 ] a_wing = [ 199.99 , 1672 , 1300 ]; razor_crest = [ 129.99 , 1023 , 845 ] sets = [ rep_gunship , light_cruiser , bad_batch_shuttle , meditation_chamber , imperial_maurader , mandalorian_forge , a_wing , razor_crest ] price = [ sets [ i ][ 0 ] for i in range ( len ( sets ))] pieces = [ sets [ i ][ 1 ] for i in range ( len ( sets ))] points = [ sets [ i ][ 2 ] for i in range ( len ( sets ))] scatter = px . scatter ( x = price , y = pieces , size = points , color = points , trendline = \"ols\" ) scatter . update_coloraxes ( colorbar_title = \"VIP Points\" ) scatter . update_layout ( title = \"Lego Star Wars Sets (2021)\" , xaxis_title = \"Price (USD)\" , yaxis_title = \"Total Piece Count\" , width = 1000 ) return scatter legoScatterCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Lego Scatter Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Lego Chart' , figure = getLegoScatterChart ()) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) There we go! Now we have five variables we can use: titleCard , animalBarCard , carbonLineCard , animalPieCard , legoScatterCard . Let's see what we can do using them! dbc.Row() \u00b6 The function dbc.Row() allows for the creation of rows, enabling horizontal arrangement of elements. For example, we can create two rows: one to hold our title, another to hold two charts. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Row ([ titleCard , ], style = { \"margin-left\" : \"0.5rem\" } ), dbc . Row ([ animalBarCard , carbonLineCard ], style = { \"margin-left\" : \"0.5rem\" } ) ]) app . run_server ( mode = 'external' ) Woah, that looks pretty good! In order to adjust the elements of rows, we can use the justify argument. Possible options include: start , center , end , between , and around . For example, here we'll use center for the title card and around for the body cards. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Row ([ titleCard , ], justify = \"center\" , style = { \"margin-left\" : \"0.5rem\" } ), dbc . Row ([ animalBarCard , carbonLineCard ], justify = \"around\" , style = { \"margin-left\" : \"0.5rem\" , \"margin-right\" : \"0.5rem\" } ) ]) app . run_server ( mode = 'external' ) Alright! That looks pretty good so far! Now, let's take a look at adding columns... dbc.Col() \u00b6 Let's say we want to add our Pie chart underneath our \"Carbon Chart\". In order to do this, we can simply use dbc.Col . To begin, we wrap our \"Carbon Chart\" in a column and include our Pie chart as part of that column: app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Row ([ titleCard , ], justify = \"center\" , style = { \"margin-left\" : \"0.5rem\" } ), dbc . Row ([ animalBarCard , dbc . Col ([ carbonLineCard , animalPieCard ]) ], justify = \"around\" , style = { \"margin-left\" : \"0.5rem\" , \"margin-right\" : \"0.5rem\" } ) ]) app . run_server ( mode = 'external' ) As seen, the row automatically expands in length in order to accommodate for the column's vertical height. In order to adjust the column's width, we can use the width argument. This is a value that ranges between 0 and 12 . As a result, width=4 would lead to a column approximately \u2153 of the width of its parent element. However, we will deal with this keyword and implement it into our dashboard in future chapters! For now, we can create another column to store our Lego Scatter Plot. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Row ([ titleCard , ], justify = \"center\" , style = { \"margin-left\" : \"0.5rem\" } ), dbc . Row ([ dbc . Col ([ animalBarCard , legoScatterCard , ]), dbc . Col ([ carbonLineCard , animalPieCard ]) ], justify = \"around\" , style = { \"margin-left\" : \"0.5rem\" , \"margin-right\" : \"0.5rem\" } ) ]) app . run_server ( mode = 'external' ) Our dashboard already looks quite stunning. All this, in just four quick chapters \ud83e\udd29\ud83d\ude04. Next up, a little more tidying... NOTE: For more information on rows and columns, feel free to check out: dbc.Layout() NOTE: All code segments from this chapter can be found in this Colab Notebook . Ch 05 - Styling \u00b6 Badges Badges \u00b6 Badges are an excellent way to better display important information, especially numbers . These elements can be accessed via the Dash Bootstrap components library and can easily be integrated into our dashboard. Basic Badge \u00b6 They can be used in conjunction with text, as shown below. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ html . H1 ([ \"Number of Animals: \" , dbc . Badge ( \"4\" , className = \"ml-1\" )]), html . H3 ([ \"Number of Countries: \" , dbc . Badge ( \"19\" , className = \"ml-1\" )]), html . H5 ([ \"Number of Lego Sets: \" , dbc . Badge ( \"None Yet!\" , className = \"ml-1\" )]) ]) app . run_server ( mode = 'external' ) As seen, they match the size of the preceding text automatically. Additionally, they can include both numbers and words. When used by themselves, they default to the normal text size of html.P() , as shown below: app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . Badge ( \"Number of Animals: 4\" , className = \"ml-1\" ) ]) app . run_server ( mode = 'external' ) Coloring \u00b6 These badges can be colored as well. They come in a total of eight different pre-built color options, outlined here: primary , secondary , success , warning , danger , info , light . In this example, they've all been wrapped into a row (placed side-by-side) so that the differences in colors can easily be visualized. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) colors = [ 'primary' , 'secondary' , 'success' , 'warning' , 'danger' , 'info' , 'light' ] app . layout = html . Div ( dbc . Row ( [ html . H1 ([ \"\" , dbc . Badge ( value , color = value , className = \"ml-1\" )]) for value in colors ] , style = { \"margin-left\" : \"1rem\" } ) ) app . run_server ( mode = 'external' ) By wrapping each in an empty html.H1() , the size of each badge can be easily increased (a nice little trick \ud83d\ude04). Pills, Links \u00b6 Badges can also be reshaped into pills (with ovalish corners) and have embedded links. The pills can be set simply via pill=True and the embedded link can be changed via the href argument. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( dbc . Row ([ html . H1 ([ \"\" , dbc . Badge ( \"Click Me!\" , color = 'info' , pill = True , href = \"https://google.com\" , className = \"ml-1\" )]) ], style = { \"margin-left\" : \"1rem\" } ) ) app . run_server ( mode = 'external' ) And those are the core functionalities of badges! As we'll see in the ensuing chapter (TigerGraph Tundra), they can come in quite handy when calling attention to text-based information... NOTE: For more information, feel free to check out the following resources: dbc.Badge() HTML Elements HTML Elements \u00b6 We can further modify the layout of our dashboard, especially text, by using Dash\u2019s HTML elements. Centering \u00b6 Going back to our title card from Dash's Delta , we can easily center text using html.Center() . titleCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Welcome to Dash!\" , className = 'card-title' ), ]) ], color = 'dark' , # Options include: primary, secondary, info, success, warning, danger, light, dark inverse = True , style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-top\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . Row ([ html . Center ( titleCard ), ], justify = \"center\" , style = { \"margin-left\" : \"0.5rem\" } ), ]) app . run_server ( mode = 'external' ) This can be used to center any component, beyond just text and cards! Horizontal Rule (Hr) \u00b6 The html.Hr() function creates a thin horizontal line that stretches across the page. This can be used to separate distinct sections from one another or for easy aesthetic design. For example, app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ html . Center ( titleCard ), html . Hr (), html . Center ( html . P ( \"Now, we can dive further into this topic...\" , style = { 'fontSize' : 20 })) ]) app . run_server ( mode = 'external' ) Line Break (Br) \u00b6 The html.Br() function creates a small line break that can be used to separate text, paragraphs, or components. The size of the line break can be seen below: app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ html . Center ( titleCard ), html . Hr (), html . Center ( html . P ( \"Now, we can dive further into this topic...\" , style = { 'fontSize' : 20 })), html . Br (), html . Center ( html . P ( \"Before we begin, we need to put on our thinking caps!\" , style = { 'fontSize' : 20 })) ]) app . run_server ( mode = 'external' ) And those are the core HTML components to help with style! dcc.Markdown() dcc.Markdown() \u00b6 Markdown allows for the insert of Markdown into Dash (pretty intuitive naming \ud83d\ude05). It's quite straightforward! app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . Col ( dcc . Markdown ( \"\"\" # This is a title! Hello There! This is in **bold** while this is in *italics* * Neat, it's a list :) * Woah, possible foreshadowing? Check out [Google](https://google.com) \"\"\" ) ) ]) app . run_server ( mode = 'external' ) In order to create a title, we can simply use the # . Bolded text is performed using the ** symbols, while italics are added via the * symbol. In order to create lists, we can use the * symbol (asterisk with a space). Links are as simple as adding the visible text in square brackets and placing the link itself in parenthesis. NOTE: For more information, feel free to check out the following resources: dcc.Markdown() List Group List Group \u00b6 Dash Bootstrap's List Groups allow for the creation of stylish lists with ease. These lists can be used to store information, serve as embedded links, and help users better navigate and understand the layout of one's dashboard. To create a basic list, we use the following: app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . ListGroup ([ dbc . ListGroupItem ( \"First is the worst!\" ), dbc . ListGroupItem ( \"Second is the best!\" ), dbc . ListGroupItem ( \"Third is the one with the Treasure Chest!\" ) ]), ]) app . run_server ( mode = 'external' ) The dbc.ListGroup() element simply holds different list group items. However, this list spans the entire width of the page (or its parent component) by default. In order to adjust its width, we can wrap the List Group within a dbc.Col() element from earlier. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . Col ( dbc . ListGroup ([ dbc . ListGroupItem ( \"First is the worst!\" ), dbc . ListGroupItem ( \"Second is the best!\" ), dbc . ListGroupItem ( \"Third is the one with the Treasure Chest!\" ) ]), width = 4 ) ]) app . run_server ( mode = 'external' ) There we go, much better! Now let's add some style... Coloring Cells \u00b6 In order to add color to each list item, we can simply use the color argument: app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . Col ( dbc . ListGroup ([ dbc . ListGroupItem ( \"First is the worst!\" , color = 'danger' ), dbc . ListGroupItem ( \"Second is the best!\" , color = \"success\" ), dbc . ListGroupItem ( \"Third is the one with the Treasure Chest!\" , color = \"info\" ) ]), width = 4 ) ]) app . run_server ( mode = 'external' ) As with other bootstrap components, the pre-built color options carry over in name and hue. Horizontal List \u00b6 Instead of keeping each list item stacked vertically, we can also arrange them horizontally. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . Col ( dbc . ListGroup ([ dbc . ListGroupItem ( \"First is the worst!\" , color = 'danger' ), dbc . ListGroupItem ( \"Second is the best!\" , color = \"success\" ), dbc . ListGroupItem ( \"Third is the one with the Treasure Chest!\" , color = \"info\" ) ], horizontal = True ), width = 6 ) ]) app . run_server ( mode = 'external' ) As seen, it's just a matter of adding the horizontal argument to our dbc.ListGroup() . NOTE: For more information, feel free to check out the following resources: dbc.ListGroup() NOTE: All code segments from this chapter can be found in this Colab Notebook .","title":"Plotly, Dash, Styling Elements"},{"location":"quick/02_notes/#plotly-dash-style-comps","text":"","title":"Plotly, Dash, Style Comps"},{"location":"quick/02_notes/#ch-03-plotly","text":"Plotly Express and Pandas","title":"Ch 03 - Plotly"},{"location":"quick/02_notes/#plotly-express-and-pandas","text":"Before beginning to graph with Plotly, we need to import Plotly Express! Plotly Express is a high-level wrapper that allows for the creation of simple visualizations with minimal lines of code. It has numerous features, yet is still intuitive and consistent in terms of the syntax used across multiple chart types. To import the library, we run the following line: import plotly.express as px Next, we need to import the Pandas library. Pandas allows for the creation of dataframes, structured storage systems that integrate easily with Plotly Express. These dataframes can be thought of as data tables or spreadsheets . To import the library, we run the following line: import pandas as pd And that's it! Bar Charts","title":"Plotly Express and Pandas"},{"location":"quick/02_notes/#bar-charts","text":"There are a few options to create a bar chart!","title":"Bar Charts"},{"location":"quick/02_notes/#loading-data","text":"With DataFrame When creating a bar chart, we can use a Pandas Dataframe : raw_data = { 'Animals' : [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ], 'Counts' : [ 2 , 4 , 8 , 4 , 2 ] } df = pd . DataFrame . from_dict ( raw_data ) bar = px . bar ( raw_data , x = 'Animals' , y = 'Counts' ) bar . show () As seen, we pass in the dataframe and specify the x and y column titles . Without DataFrame Here, we can simply pass in two arrays, one for each of x and y. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ] counts = [ 2 , 4 , 8 , 4 , 2 ] bar = px . bar ( x = animals , y = counts ) bar . show () Even if we don't create a dataframe, Plotly will perform this action under-the-hood when generating the bar chart. In both cases, we get the same result. And voila, here are our two bar charts! Ahh, you may have noticed a small difference: the axis labels! When we passed in two arrays, we never specified what the axes were to be titled . How do we fix this and further style our charts? To that, we turn to Plotly's myriad ways of customizing charts .","title":"Loading Data"},{"location":"quick/02_notes/#styling-figure","text":"There are many ways to style a bar chart. Here are some of the most important ones! Adding a Title, Axis Labels We can add a title with the following function, bar.update_layout() : animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ] counts = [ 2 , 4 , 8 , 2 , 4 ] bar = px . bar ( x = animals , y = counts ) bar . update_layout ( title = \"Animals vs. Appendages\" , # Adding a title xaxis_title = \"The Amazing Animals\" , # Changing x-axis label yaxis_title = \"How many appendages?\" , # Changing y-axis label font = dict ( family = \"Courier New, monospace\" , # The font style color = \"RebeccaPurple\" , # The font color size = 18 # The font size ) ) bar . show () Adding Color In order to individually select colors for our bar chart, we can use the following: animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ] counts = [ 2 , 4 , 8 , 2 , 4 ] # As seen, each bar segment that hasn't had a discrete color entered will be shown in black bar = px . bar ( x = animals , y = counts , color_discrete_sequence = [[ '#65ff31' , '#4a4aff' , '#aa00aa' ]]) bar . show () We can also use the following argument to make each column visually represent its value . raw_data = { 'Animals' : [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ], 'Counts' : [ 2 , 4 , 8 , 2 , 4 ] } df = pd . DataFrame . from_dict ( raw_data ) # Creates a side color chart --> each color represents count bar = px . bar ( df , x = 'Animals' , y = 'Counts' , color = 'Counts' ) bar . show () As seen, it's just a matter of adding the \"color\" argument! Changing Orientation In order to make the bar chart horizontal, we can simply add the orientation='h' argument. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ] counts = [ 2 , 4 , 8 , 2 , 4 ] # Notice that we've had to switch the axes! bar = px . bar ( x = counts , y = animals , orientation = 'h' ) bar . show () NOTE: As mentioned in the above comments, we've had to switch the axes in this horizontal layout! Width and Height These can be easily changed via the width and height keywords. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ] counts = [ 2 , 4 , 8 , 2 , 4 ] bar = px . bar ( x = animals , y = counts , width = 800 , height = 400 ) bar . show () All Put Together Using these elements, we can create the following bar chart: raw_data = { 'Animals' : [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ], 'Counts' : [ 2 , 4 , 8 , 2 , 4 ] } df = pd . DataFrame . from_dict ( raw_data ) bar = px . bar ( df , x = 'Counts' , y = 'Animals' , orientation = 'h' , color = 'Counts' , width = 800 , height = 400 ) bar . update_layout ( title = \"Animals vs. Appendages\" , # Adding a title yaxis_title = \"The Amazing Animals\" , # Changing x-axis label xaxis_title = \"How many appendages?\" , # Changing y-axis label font = dict ( family = \"Courier New, monospace\" , # The font style color = \"RebeccaPurple\" , # The font color size = 18 # The font size ) ) bar . show () NOTE: For more information, make sure to check out the following: Plotly Bar Charts , px.Bar() Line Charts","title":"Styling Figure"},{"location":"quick/02_notes/#line-charts","text":"There are a few options to create a line chart!","title":"Line Charts"},{"location":"quick/02_notes/#loading-data_1","text":"Once again, we can either use a Pandas Dataframe or just proceed with arrays! With DataFrame raw_data = { 'Year' : [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ], 'Carbon per Capita' : [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] } df = pd . DataFrame . from_dict ( raw_data ) line = px . line ( df , x = 'Year' , y = 'Carbon per Capita' ) line . show () As seen, we pass in the dataframe and specify the x and y column titles . Without DataFrame Here, we can simply pass in two arrays, one for each of x and y. year = [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ] carbon = [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] line = px . line ( x = year , y = carbon ) line . show () Even if we don't create a dataframe, Plotly will perform this action under-the-hood when generating the line chart. In both cases, we get the same result. And voila, here are our two line charts!","title":"Loading Data"},{"location":"quick/02_notes/#styling-figure_1","text":"The methods to style a line chart are very similar to styling a bar chart! However, one neat feature we haven't covered yet is traces. These are quite effective at visualizing multiple sets of data on the same set of axes. Let's take a closer look! Multiple Traces In order to add multiple traces, we turn to the Plotly Graph Objects library. To import this library, we use the following line: import plotly.graph_objects as go Next, we can create our traces with the .add_trace() function. year = [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ] carbon_USA = [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] carbon_AUS = [ 15.0 , 15.3 , 15.5 , 15.6 , 17.2 , 18.2 , 18.2 , 17.7 , 17.5 , 17.1 , 16.1 , 15.4 , 16.9 , 16.8 ] line = go . Figure () line . add_trace ( go . Scatter ( x = year , y = carbon_USA )) line . add_trace ( go . Scatter ( x = year , y = carbon_AUS )) line . show () Each trace adds a new line (the name go.Scatter() is a bit misleading!) Styling Traces In order to style these traces and change their legend names from 't', we can add the following: year = [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ] carbon_USA = [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] carbon_AUS = [ 15.0 , 15.3 , 15.5 , 15.6 , 17.2 , 18.2 , 18.2 , 17.7 , 17.5 , 17.1 , 16.1 , 15.4 , 16.9 , 16.8 ] line = go . Figure () line . add_trace ( go . Scatter ( x = year , y = carbon_USA , marker = dict ( color = 'MediumPurple' ), name = \"USA Carbon Emissions (per capita)\" )) line . add_trace ( go . Scatter ( x = year , y = carbon_AUS , marker = dict ( color = 'LightSeaGreen' ), name = \"AUS Carbon Emissions (per capita)\" )) line . show () Adding the marker=dict(color='MediumPurple') dictionary allows us to change the color of the two traces. Additionally, the name argument lets us distinguish and label the two traces. Here's the result! We can further style these traces by exploring the marker dictionary: year = [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ] carbon_USA = [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] carbon_AUS = [ 15.0 , 15.3 , 15.5 , 15.6 , 17.2 , 18.2 , 18.2 , 17.7 , 17.5 , 17.1 , 16.1 , 15.4 , 16.9 , 16.8 ] line = go . Figure () line . add_trace ( go . Scatter ( x = year , y = carbon_USA , marker = dict ( size = 25 , color = 'MediumPurple' ), name = \"USA Carbon Emissions (per capita)\" )) line . add_trace ( go . Scatter ( x = year , y = carbon_AUS , marker = dict ( size = 25 , color = 'LightSeaGreen' , symbol = 'square' ), name = \"AUS Carbon Emissions (per capita)\" )) line . show () As seen below, the size and symbols for each trace can be customized as well! All Put Together Using these elements and our stylings from the previous section, we can create the following: year = [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ] carbon_USA = [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] carbon_AUS = [ 15.0 , 15.3 , 15.5 , 15.6 , 17.2 , 18.2 , 18.2 , 17.7 , 17.5 , 17.1 , 16.1 , 15.4 , 16.9 , 16.8 ] line = go . Figure () line . add_trace ( go . Scatter ( x = year , y = carbon_USA , marker = dict ( size = 25 , color = 'MediumPurple' ), name = \"USA Carbon Emissions (per capita)\" )) line . add_trace ( go . Scatter ( x = year , y = carbon_AUS , marker = dict ( size = 25 , color = 'LightSeaGreen' , symbol = 'square' ), name = \"AUS Carbon Emissions (per capita)\" )) line . update_layout ( title = \"Carbon Emissions since 1980 (per capita)\" , xaxis_title = \"Year\" , yaxis_title = \"Annual Emissions in Tons (per capita)\" , plot_bgcolor = 'DarkGrey' , width = 1600 ) line . show () NOTE: For more information, make sure to check out the following: Plotly Line Charts , px.line() Pie Charts","title":"Styling Figure"},{"location":"quick/02_notes/#pie-charts","text":"There are a few options to create a pie chart!","title":"Pie Charts"},{"location":"quick/02_notes/#loading-data_2","text":"When creating a bar chart, we can use a Pandas Dataframe : raw_data = { 'Animals' : [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ], 'Counts' : [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] } df = pd . DataFrame . from_dict ( raw_data ) pie = px . pie ( raw_data , values = 'Counts' , names = 'Animals' ) pie . show () As seen, we pass in the dataframe and specify the x and y column titles . Without DataFrame Here, we can simply pass in two arrays, one for each of x and y. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals ) pie . show () Even if we don't create a dataframe, Plotly will perform this action under-the-hood when generating the pie chart. In both cases, we get the same result. And voila, here are our two bar charts! Unlike with bar charts and line charts, there are truly no differences between each! This is mainly because there are no axes which need labelling \ud83d\ude05.","title":"Loading Data"},{"location":"quick/02_notes/#styling-figure_2","text":"There are many ways to style a bar chart. Here are some of the most important ones! Adding Title, Labels In order to add a title, we can simply pass in the title argument. To change the percentages in each slice into labels, we can use the .update_traces() method. The width of the plot is simply changed via the .update_layouts() method, as done previously. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals , title = \"The Animals of Old McDonald's Farm\" , ) pie . update_traces ( textposition = 'inside' , textinfo = 'label' ) pie . update_layout ( width = 1000 ) pie . show () The title can be centered with the title_x argument, which ranges from 0 to 1. Therefore, setting its value to 0.5 will result in a centered title. Additionally, the .update_traces() method can be modified to include percentages. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals , title = \"The Animals of Old McDonald's Farm\" , ) pie . update_traces ( textposition = 'inside' , textinfo = 'label+percent' ) pie . update_layout ( width = 1000 ) pie . update_layout ( title_x = 0.5 ) pie . show () And here's our centered title (relative to the pie chart).","title":"Styling Figure"},{"location":"quick/02_notes/#donuts-slices","text":"Some neat extensions of pie charts includes donuts and slices! In order to create a donut chart, we simply need to add the hole=0.2 argument. animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals , title = \"The Animals of Old McDonald's Farm\" , hole = 0.2 , ) pie . update_traces ( textposition = 'inside' , textinfo = 'label+percent' ) pie . update_layout ( width = 1000 ) pie . update_layout ( title_x = 0.5 ) pie . show () In order to highlight specific slices or data values, we can use the pull argument. Here's an example highlighting the Pig slice! animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals , title = \"The Animals of Old McDonald's Farm\" , hole = 0.2 , ) pie . update_traces ( textposition = 'inside' , textinfo = 'label+percent' , pull = [ 0 , 0 , 0 , 0 , 0 , 0 , 0.1 ], ) pie . update_layout ( width = 1000 ) pie . update_layout ( title_x = 0.5 ) pie . show () The length of pull matches the length of animals . Similarly, each value corresponds to a specific animal, in matching result. For example, the last element of pull is 0.1, meaning that the last element of animals , 'Pig', will be pulled out by a factor of 0.1. Let's try applying this knowledge to pull out 'Chicken' and 'Buffalo' as well! animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals , title = \"The Animals of Old McDonald's Farm\" , hole = 0.2 , ) pie . update_traces ( textposition = 'inside' , textinfo = 'label+percent' , opacity = 0.9 , pull = [ 0.2 , 0.3 , 0 , 0 , 0 , 0 , 0.1 ], ) pie . update_layout ( width = 1000 ) pie . update_layout ( title_x = 0.5 ) pie . show () Neat! And with that, we have a rather fancy pie chart put together in less than a dozen lines of code! NOTE: For more information, make sure to check out the following: Plotly Pie Charts , px.Pie() Scatter Plots","title":"Donuts, Slices"},{"location":"quick/02_notes/#scatter-plots","text":"As with most other plots, there are a few options to create a scatter plot!","title":"Scatter Plots"},{"location":"quick/02_notes/#loading-data_3","text":"Here, we'll explore a less-common method with several Star Wars Lego Sets. Each Lego Set is stored as an array of three values: price, piece count, and VIP points. These arrays are added to a list of all eight sets. Using two iterators, we can create a list of prices and pieces (ordered correctly). rep_gunship = [ 349.99 , 3292 , 2275 ]; light_cruiser = [ 159.99 , 1336 , 1040 ] bad_batch_shuttle = [ 99.99 , 969 , 650 ]; meditation_chamber = [ 69.99 , 663 , 455 ] imperial_maurader = [ 39.99 , 478 , 260 ]; mandalorian_forge = [ 29.99 , 258 , 195 ] a_wing = [ 199.99 , 1672 , 1300 ]; razor_crest = [ 129.99 , 1023 , 845 ] sets = [ rep_gunship , light_cruiser , bad_batch_shuttle , meditation_chamber , imperial_maurader , mandalorian_forge , a_wing , razor_crest ] price = [ sets [ i ][ 0 ] for i in range ( len ( sets ))] pieces = [ sets [ i ][ 1 ] for i in range ( len ( sets ))] scatter = px . scatter ( x = price , y = pieces ) scatter . show () Looking good, but let's add some style!","title":"Loading Data"},{"location":"quick/02_notes/#styling-figure_3","text":"Size Attribute One neat way to flavor our scatter plots is to modify the size attribute. Here, we can set the size of each datapoint to match a third attribute. In this case, the third dimension of data will be the number of VIP points earned per set. # Lego Sets from 2021 (Price, Pieces, VIP Points) rep_gunship = [ 349.99 , 3292 , 2275 ]; light_cruiser = [ 159.99 , 1336 , 1040 ] bad_batch_shuttle = [ 99.99 , 969 , 650 ]; meditation_chamber = [ 69.99 , 663 , 455 ] imperial_maurader = [ 39.99 , 478 , 260 ]; mandalorian_forge = [ 29.99 , 258 , 195 ] a_wing = [ 199.99 , 1672 , 1300 ]; razor_crest = [ 129.99 , 1023 , 845 ] sets = [ rep_gunship , light_cruiser , bad_batch_shuttle , meditation_chamber , imperial_maurader , mandalorian_forge , a_wing , razor_crest ] price = [ sets [ i ][ 0 ] for i in range ( len ( sets ))] pieces = [ sets [ i ][ 1 ] for i in range ( len ( sets ))] points = [ sets [ i ][ 2 ] for i in range ( len ( sets ))] scatter = px . scatter ( x = price , y = pieces , size = points ) scatter . show () And ta-da, we can easily visualize that larger sets give the most points! Adding Color As well as representing VIP points by size, we can also represent this data with color. We simply need to add the color argument inside of our px.scatter() function. # Lego Sets from 2021 (Price, Pieces, VIP Points) rep_gunship = [ 349.99 , 3292 , 2275 ]; light_cruiser = [ 159.99 , 1336 , 1040 ] bad_batch_shuttle = [ 99.99 , 969 , 650 ]; meditation_chamber = [ 69.99 , 663 , 455 ] imperial_maurader = [ 39.99 , 478 , 260 ]; mandalorian_forge = [ 29.99 , 258 , 195 ] a_wing = [ 199.99 , 1672 , 1300 ]; razor_crest = [ 129.99 , 1023 , 845 ] sets = [ rep_gunship , light_cruiser , bad_batch_shuttle , meditation_chamber , imperial_maurader , mandalorian_forge , a_wing , razor_crest ] price = [ sets [ i ][ 0 ] for i in range ( len ( sets ))] pieces = [ sets [ i ][ 1 ] for i in range ( len ( sets ))] points = [ sets [ i ][ 2 ] for i in range ( len ( sets ))] scatter = px . scatter ( x = price , y = pieces , size = points , color = points ) scatter . update_coloraxes ( colorbar_title = \"VIP Points\" ) scatter . update_layout ( width = 1000 ) # For better view! scatter . show () Adding Trendline Finally, one useful feature of px.Scatter() is the ability to add trendlines! All it takes is a simple trendline=\"ols\" , where \"ols\" stands for Ordinary Least Squares regression. # Lego Sets from 2021 (Price, Pieces, VIP Points) rep_gunship = [ 349.99 , 3292 , 2275 ]; light_cruiser = [ 159.99 , 1336 , 1040 ] bad_batch_shuttle = [ 99.99 , 969 , 650 ]; meditation_chamber = [ 69.99 , 663 , 455 ] imperial_maurader = [ 39.99 , 478 , 260 ]; mandalorian_forge = [ 29.99 , 258 , 195 ] a_wing = [ 199.99 , 1672 , 1300 ]; razor_crest = [ 129.99 , 1023 , 845 ] sets = [ rep_gunship , light_cruiser , bad_batch_shuttle , meditation_chamber , imperial_maurader , mandalorian_forge , a_wing , razor_crest ] price = [ sets [ i ][ 0 ] for i in range ( len ( sets ))] pieces = [ sets [ i ][ 1 ] for i in range ( len ( sets ))] points = [ sets [ i ][ 2 ] for i in range ( len ( sets ))] scatter = px . scatter ( x = price , y = pieces , size = points , color = points , trendline = \"ols\" ) scatter . update_coloraxes ( colorbar_title = \"VIP Points\" ) scatter . update_layout ( width = 1000 ) # For better view! scatter . show () NOTE: Non-linear regression lines can be added as well! For more information, check out: Plotly Trendlines All Put Together Using these elements and our stylings from the previous section, we can create the following: # Lego Sets from 2021 (Price, Pieces, VIP Points) rep_gunship = [ 349.99 , 3292 , 2275 ]; light_cruiser = [ 159.99 , 1336 , 1040 ] bad_batch_shuttle = [ 99.99 , 969 , 650 ]; meditation_chamber = [ 69.99 , 663 , 455 ] imperial_maurader = [ 39.99 , 478 , 260 ]; mandalorian_forge = [ 29.99 , 258 , 195 ] a_wing = [ 199.99 , 1672 , 1300 ]; razor_crest = [ 129.99 , 1023 , 845 ] sets = [ rep_gunship , light_cruiser , bad_batch_shuttle , meditation_chamber , imperial_maurader , mandalorian_forge , a_wing , razor_crest ] price = [ sets [ i ][ 0 ] for i in range ( len ( sets ))] pieces = [ sets [ i ][ 1 ] for i in range ( len ( sets ))] points = [ sets [ i ][ 2 ] for i in range ( len ( sets ))] scatter = px . scatter ( x = price , y = pieces , size = points , color = points , trendline = \"ols\" ) scatter . update_coloraxes ( colorbar_title = \"VIP Points\" ) scatter . update_layout ( title = \"Lego Star Wars Sets (2021)\" , xaxis_title = \"Price (USD)\" , yaxis_title = \"Total Piece Count\" , width = 1000 ) scatter . show () NOTE: For more information, make sure to check out the following: Plotly Scatter px.Scatter() NOTE: All code segments from this chapter can be found in this Colab Notebook .","title":"Styling Figure"},{"location":"quick/02_notes/#ch-04-dash","text":"Dash's Libraries","title":"Ch 04 - Dash"},{"location":"quick/02_notes/#dashs-libraries","text":"To begin harnessing the power of Dash, we must import the necessary libraries","title":"Dash's Libraries"},{"location":"quick/02_notes/#dash-core","text":"Dash's core components are a library of higher-level elements such as tables, graphs, dropdowns, inputs, and links . To use these components, we add the following line: import dash_core_components as dcc NOTE: For a full list of components, feel free to check out the following: Dash Core Documentation","title":"Dash Core"},{"location":"quick/02_notes/#bootstrap","text":"Dash allows for the inclusion of native Boostrap components via its Dash Boostrap library. These elements include cards, lists, badges, and more . To use these elements, we install and import the library via the following lines: ! pip install dash - bootstrap - components import dash_bootstrap_components as dbc NOTE: For a full list of components, feel free to check out the following: Dash Boostrap Documentation And voila, we're good to go! Dash Graph","title":"Bootstrap"},{"location":"quick/02_notes/#dash-graph","text":"The figures made from Plotly are dazzling, but still need to be added into the dashboard! In order to add these charts, we can utilize the dcc.Graph() element. First, we create a function: def getAnimalChart (): raw_data = { 'Animals' : [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ], 'Counts' : [ 2 , 4 , 8 , 2 , 4 ] } df = pd . DataFrame . from_dict ( raw_data ) bar = px . bar ( df , x = 'Counts' , y = 'Animals' , orientation = 'h' , color = 'Counts' , width = 800 , height = 400 ) bar . update_layout ( title = \"Animals vs. Appendages\" , # Adding a title yaxis_title = \"The Amazing Animals\" , # Changing x-axis label xaxis_title = \"How many appendages?\" , # Changing y-axis label font = dict ( family = \"Courier New, monospace\" , # The font style color = \"RebeccaPurple\" , # The font color size = 18 # The font size ) ) return bar This function simply returns our finalized bar chart from the last chapter instead of displaying it. Now, we can add a dcc.Graph() component in our app via the following lines. And here's the result! app = JupyterDash ( __name__ ) app . layout = html . Div ( children = [ html . P ( children = \"Welcome to Dash\" ), dcc . Graph ( id = 'Animal Chart' , figure = getAnimalChart ()) ]) app . run_server ( mode = 'external' ) NOTE: The id attribute is optional, but it's a good practice to include a unique ID for each component. This is especially true for updating figures, which will be covered in a later chapter, \"Confronted by Callbacks\" Pretty straightforward! Now, we can add our Plotly figures to our dashboard \ud83d\ude04 . Dash Cards","title":"Dash Graph"},{"location":"quick/02_notes/#dash-cards","text":"These graphs we have created are amazing! But not the prettiest... With cards, any component (especially text, images, and figures) can neatly be displayed within a bounded area. These cards can be customized in terms of style, size, color, outline, and more!","title":"Dash Cards"},{"location":"quick/02_notes/#basic-elements","text":"To get started, we'll create a simple card around our graph from earlier. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ html . P ( children = \"Welcome to Dash\" ), dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Animal Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Animal Chart' , figure = getAnimalChart ()) ]) ], style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" } ) ]) app . run_server ( mode = 'external' ) Alright, let's break it down! At the very top, we must add the Bootstrap external stylesheet in order to utilize the Card component. This stylesheet comes installed with the library and is accessed with external_stylesheets=[dbc.themes.BOOTSTRAP] NOTE: We can add our own custom external stylesheets! We'll dive into this in \"Sheriff Styles\" With our dbc.Card() , we have a Card Body. this dbc.CardBody() contains a header, paragraph, and our graph. You may notice the className attribute. This is a custom CSS styling that was imported from the Bootstrap stylesheet. After this, the dbc.Card() itself contains a style dictionary. In here, we find two attributes: Width - this is simply the width of the card. rem is simply the percentage dimension of the screen. As a result, 55rem means that the card will span 55% of the screen's width. Margin - in particular, the left-most margin has been set to 1% of the screen's width. margin-bottom , margin-top , and margin-right are all valid keywords that can be utilized as well to further adjust our card. And voila, here's our result: Let's try changing some of the colors!","title":"Basic Elements"},{"location":"quick/02_notes/#colors-outlines","text":"In order to modify the visual appearance of our cards, we can use the color and outline attributes. color allows for several pre-built options: primary , secondary , info , success , warning , danger , light , and dark . For example, here's what info looks like (a light blue): app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ html . P ( children = \"Welcome to Dash\" ), dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Animal Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Animal Chart' , figure = getAnimalChart ()) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" } ) ]) app . run_server ( mode = 'external' ) We can also create a card to hold our title (looks kind of strange by itself in the top corner \ud83d\ude05) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Welcome to Dash!\" , className = 'card-title' ), ]) ], color = 'dark' , # Options include: primary, secondary, info, success, warning, danger, light, dark inverse = True , style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-top\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ), dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Animal Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Animal Chart' , figure = getAnimalChart ()) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" } ) ]) app . run_server ( mode = 'external' ) There we go, much better now! Ahh, you may have noticed the inverse argument! Setting this to True is helpful when dealing with dark backgrounds as it inverts all text color to white. As a result, we don't have to manually change the title color. NOTE: For more information on dbc.Card(), feel free to check out the following: dbc.Card() Now, what if we want to add multiple cards, but not just continue to vertically stack them? For that, we must turn to rows and columns! Dash Layout","title":"Colors, Outlines"},{"location":"quick/02_notes/#dash-layout","text":"The best way to arrange components in our dashboard is via dbc.Row() and dbc.Col() . Let's take a closer look at their power!","title":"Dash Layout"},{"location":"quick/02_notes/#creating-cards","text":"Before beginning, let's create a few cards for better readability: titleCard titleCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Welcome to Dash!\" , className = 'card-title' ), ]) ], color = 'dark' , # Options include: primary, secondary, info, success, warning, danger, light, dark inverse = True , style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-top\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) animalBarCard def getAnimalBarChart (): raw_data = { 'Animals' : [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' ], 'Counts' : [ 2 , 4 , 8 , 2 , 4 ] } df = pd . DataFrame . from_dict ( raw_data ) bar = px . bar ( df , x = 'Counts' , y = 'Animals' , orientation = 'h' , color = 'Counts' , width = 800 , height = 400 ) bar . update_layout ( title = \"Animals vs. Appendages\" , # Adding a title yaxis_title = \"The Amazing Animals\" , # Changing x-axis label xaxis_title = \"How many appendages?\" , # Changing y-axis label font = dict ( family = \"Courier New, monospace\" , # The font style color = \"RebeccaPurple\" , # The font color size = 18 # The font size ) ) return bar animalBarCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Animal Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Animal Chart' , figure = getAnimalBarChart ()) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) carbonLineCard def getCarbonLineChart (): year = [ 1980 , 1985 , 1990 , 1995 , 2000 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2014 , 2015 , 2018 ] carbon_USA = [ 20.8 , 18.9 , 19.3 , 19.3 , 20.2 , 18.5 , 17.2 , 17.4 , 17.0 , 16.3 , 16.3 , 16.5 , 16.3 , 16.1 ] carbon_AUS = [ 15.0 , 15.3 , 15.5 , 15.6 , 17.2 , 18.2 , 18.2 , 17.7 , 17.5 , 17.1 , 16.1 , 15.4 , 16.9 , 16.8 ] line = go . Figure () line . add_trace ( go . Scatter ( x = year , y = carbon_USA , marker = dict ( size = 25 , color = 'MediumPurple' ), name = \"USA Carbon Emissions (per capita)\" )) line . add_trace ( go . Scatter ( x = year , y = carbon_AUS , marker = dict ( size = 25 , color = 'LightSeaGreen' , symbol = 'square' ), name = \"AUS Carbon Emissions (per capita)\" )) line . update_layout ( title = \"Carbon Emissions since 1980 (per capita)\" , xaxis_title = \"Year\" , yaxis_title = \"Annual Emissions in Tons (per capita)\" , plot_bgcolor = 'DarkGrey' , width = 1600 ) return line carbonLineCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Carbon Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Carbon Chart' , figure = getCarbonLineChart ()) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) animalPieCard def getAnimalPieChart (): animals = [ 'Chicken' , 'Buffalo' , 'Octopus' , 'Duck' , 'Lion' , 'Horse' , 'Pig' ] counts = [ 9 , 3 , 1 , 5 , 4 , 8 , 8 ] pie = px . pie ( values = counts , names = animals , title = \"The Animals of Old McDonald's Farm\" , hole = 0.2 , ) pie . update_traces ( textposition = 'inside' , textinfo = 'label+percent' , opacity = 0.9 , pull = [ 0.2 , 0.3 , 0 , 0 , 0 , 0 , 0.1 ], ) pie . update_layout ( width = 1000 ) pie . update_layout ( title_x = 0.5 ) return pie animalPieCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Animal Pie Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Animal Pie Chart' , figure = getAnimalPieChart ()) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) legoScatterCard def getLegoScatterChart (): rep_gunship = [ 349.99 , 3292 , 2275 ]; light_cruiser = [ 159.99 , 1336 , 1040 ] bad_batch_shuttle = [ 99.99 , 969 , 650 ]; meditation_chamber = [ 69.99 , 663 , 455 ] imperial_maurader = [ 39.99 , 478 , 260 ]; mandalorian_forge = [ 29.99 , 258 , 195 ] a_wing = [ 199.99 , 1672 , 1300 ]; razor_crest = [ 129.99 , 1023 , 845 ] sets = [ rep_gunship , light_cruiser , bad_batch_shuttle , meditation_chamber , imperial_maurader , mandalorian_forge , a_wing , razor_crest ] price = [ sets [ i ][ 0 ] for i in range ( len ( sets ))] pieces = [ sets [ i ][ 1 ] for i in range ( len ( sets ))] points = [ sets [ i ][ 2 ] for i in range ( len ( sets ))] scatter = px . scatter ( x = price , y = pieces , size = points , color = points , trendline = \"ols\" ) scatter . update_coloraxes ( colorbar_title = \"VIP Points\" ) scatter . update_layout ( title = \"Lego Star Wars Sets (2021)\" , xaxis_title = \"Price (USD)\" , yaxis_title = \"Total Piece Count\" , width = 1000 ) return scatter legoScatterCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Lego Scatter Chart\" , className = 'card-title' ), html . P ( \"This is an example graph displaying some statistics\" , className = 'card-body' ), dcc . Graph ( id = 'Lego Chart' , figure = getLegoScatterChart ()) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) There we go! Now we have five variables we can use: titleCard , animalBarCard , carbonLineCard , animalPieCard , legoScatterCard . Let's see what we can do using them!","title":"Creating Cards"},{"location":"quick/02_notes/#dbcrow","text":"The function dbc.Row() allows for the creation of rows, enabling horizontal arrangement of elements. For example, we can create two rows: one to hold our title, another to hold two charts. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Row ([ titleCard , ], style = { \"margin-left\" : \"0.5rem\" } ), dbc . Row ([ animalBarCard , carbonLineCard ], style = { \"margin-left\" : \"0.5rem\" } ) ]) app . run_server ( mode = 'external' ) Woah, that looks pretty good! In order to adjust the elements of rows, we can use the justify argument. Possible options include: start , center , end , between , and around . For example, here we'll use center for the title card and around for the body cards. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Row ([ titleCard , ], justify = \"center\" , style = { \"margin-left\" : \"0.5rem\" } ), dbc . Row ([ animalBarCard , carbonLineCard ], justify = \"around\" , style = { \"margin-left\" : \"0.5rem\" , \"margin-right\" : \"0.5rem\" } ) ]) app . run_server ( mode = 'external' ) Alright! That looks pretty good so far! Now, let's take a look at adding columns...","title":"dbc.Row()"},{"location":"quick/02_notes/#dbccol","text":"Let's say we want to add our Pie chart underneath our \"Carbon Chart\". In order to do this, we can simply use dbc.Col . To begin, we wrap our \"Carbon Chart\" in a column and include our Pie chart as part of that column: app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Row ([ titleCard , ], justify = \"center\" , style = { \"margin-left\" : \"0.5rem\" } ), dbc . Row ([ animalBarCard , dbc . Col ([ carbonLineCard , animalPieCard ]) ], justify = \"around\" , style = { \"margin-left\" : \"0.5rem\" , \"margin-right\" : \"0.5rem\" } ) ]) app . run_server ( mode = 'external' ) As seen, the row automatically expands in length in order to accommodate for the column's vertical height. In order to adjust the column's width, we can use the width argument. This is a value that ranges between 0 and 12 . As a result, width=4 would lead to a column approximately \u2153 of the width of its parent element. However, we will deal with this keyword and implement it into our dashboard in future chapters! For now, we can create another column to store our Lego Scatter Plot. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Row ([ titleCard , ], justify = \"center\" , style = { \"margin-left\" : \"0.5rem\" } ), dbc . Row ([ dbc . Col ([ animalBarCard , legoScatterCard , ]), dbc . Col ([ carbonLineCard , animalPieCard ]) ], justify = \"around\" , style = { \"margin-left\" : \"0.5rem\" , \"margin-right\" : \"0.5rem\" } ) ]) app . run_server ( mode = 'external' ) Our dashboard already looks quite stunning. All this, in just four quick chapters \ud83e\udd29\ud83d\ude04. Next up, a little more tidying... NOTE: For more information on rows and columns, feel free to check out: dbc.Layout() NOTE: All code segments from this chapter can be found in this Colab Notebook .","title":"dbc.Col()"},{"location":"quick/02_notes/#ch-05-styling","text":"Badges","title":"Ch 05 - Styling"},{"location":"quick/02_notes/#badges","text":"Badges are an excellent way to better display important information, especially numbers . These elements can be accessed via the Dash Bootstrap components library and can easily be integrated into our dashboard.","title":"Badges"},{"location":"quick/02_notes/#basic-badge","text":"They can be used in conjunction with text, as shown below. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ html . H1 ([ \"Number of Animals: \" , dbc . Badge ( \"4\" , className = \"ml-1\" )]), html . H3 ([ \"Number of Countries: \" , dbc . Badge ( \"19\" , className = \"ml-1\" )]), html . H5 ([ \"Number of Lego Sets: \" , dbc . Badge ( \"None Yet!\" , className = \"ml-1\" )]) ]) app . run_server ( mode = 'external' ) As seen, they match the size of the preceding text automatically. Additionally, they can include both numbers and words. When used by themselves, they default to the normal text size of html.P() , as shown below: app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . Badge ( \"Number of Animals: 4\" , className = \"ml-1\" ) ]) app . run_server ( mode = 'external' )","title":"Basic Badge"},{"location":"quick/02_notes/#coloring","text":"These badges can be colored as well. They come in a total of eight different pre-built color options, outlined here: primary , secondary , success , warning , danger , info , light . In this example, they've all been wrapped into a row (placed side-by-side) so that the differences in colors can easily be visualized. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) colors = [ 'primary' , 'secondary' , 'success' , 'warning' , 'danger' , 'info' , 'light' ] app . layout = html . Div ( dbc . Row ( [ html . H1 ([ \"\" , dbc . Badge ( value , color = value , className = \"ml-1\" )]) for value in colors ] , style = { \"margin-left\" : \"1rem\" } ) ) app . run_server ( mode = 'external' ) By wrapping each in an empty html.H1() , the size of each badge can be easily increased (a nice little trick \ud83d\ude04).","title":"Coloring"},{"location":"quick/02_notes/#pills-links","text":"Badges can also be reshaped into pills (with ovalish corners) and have embedded links. The pills can be set simply via pill=True and the embedded link can be changed via the href argument. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( dbc . Row ([ html . H1 ([ \"\" , dbc . Badge ( \"Click Me!\" , color = 'info' , pill = True , href = \"https://google.com\" , className = \"ml-1\" )]) ], style = { \"margin-left\" : \"1rem\" } ) ) app . run_server ( mode = 'external' ) And those are the core functionalities of badges! As we'll see in the ensuing chapter (TigerGraph Tundra), they can come in quite handy when calling attention to text-based information... NOTE: For more information, feel free to check out the following resources: dbc.Badge() HTML Elements","title":"Pills, Links"},{"location":"quick/02_notes/#html-elements","text":"We can further modify the layout of our dashboard, especially text, by using Dash\u2019s HTML elements.","title":"HTML Elements"},{"location":"quick/02_notes/#centering","text":"Going back to our title card from Dash's Delta , we can easily center text using html.Center() . titleCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Welcome to Dash!\" , className = 'card-title' ), ]) ], color = 'dark' , # Options include: primary, secondary, info, success, warning, danger, light, dark inverse = True , style = { \"width\" : \"55rem\" , \"margin-left\" : \"1rem\" , \"margin-top\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . Row ([ html . Center ( titleCard ), ], justify = \"center\" , style = { \"margin-left\" : \"0.5rem\" } ), ]) app . run_server ( mode = 'external' ) This can be used to center any component, beyond just text and cards!","title":"Centering"},{"location":"quick/02_notes/#horizontal-rule-hr","text":"The html.Hr() function creates a thin horizontal line that stretches across the page. This can be used to separate distinct sections from one another or for easy aesthetic design. For example, app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ html . Center ( titleCard ), html . Hr (), html . Center ( html . P ( \"Now, we can dive further into this topic...\" , style = { 'fontSize' : 20 })) ]) app . run_server ( mode = 'external' )","title":"Horizontal Rule (Hr)"},{"location":"quick/02_notes/#line-break-br","text":"The html.Br() function creates a small line break that can be used to separate text, paragraphs, or components. The size of the line break can be seen below: app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ html . Center ( titleCard ), html . Hr (), html . Center ( html . P ( \"Now, we can dive further into this topic...\" , style = { 'fontSize' : 20 })), html . Br (), html . Center ( html . P ( \"Before we begin, we need to put on our thinking caps!\" , style = { 'fontSize' : 20 })) ]) app . run_server ( mode = 'external' ) And those are the core HTML components to help with style! dcc.Markdown()","title":"Line Break (Br)"},{"location":"quick/02_notes/#dccmarkdown","text":"Markdown allows for the insert of Markdown into Dash (pretty intuitive naming \ud83d\ude05). It's quite straightforward! app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . Col ( dcc . Markdown ( \"\"\" # This is a title! Hello There! This is in **bold** while this is in *italics* * Neat, it's a list :) * Woah, possible foreshadowing? Check out [Google](https://google.com) \"\"\" ) ) ]) app . run_server ( mode = 'external' ) In order to create a title, we can simply use the # . Bolded text is performed using the ** symbols, while italics are added via the * symbol. In order to create lists, we can use the * symbol (asterisk with a space). Links are as simple as adding the visible text in square brackets and placing the link itself in parenthesis. NOTE: For more information, feel free to check out the following resources: dcc.Markdown() List Group","title":"dcc.Markdown()"},{"location":"quick/02_notes/#list-group","text":"Dash Bootstrap's List Groups allow for the creation of stylish lists with ease. These lists can be used to store information, serve as embedded links, and help users better navigate and understand the layout of one's dashboard. To create a basic list, we use the following: app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . ListGroup ([ dbc . ListGroupItem ( \"First is the worst!\" ), dbc . ListGroupItem ( \"Second is the best!\" ), dbc . ListGroupItem ( \"Third is the one with the Treasure Chest!\" ) ]), ]) app . run_server ( mode = 'external' ) The dbc.ListGroup() element simply holds different list group items. However, this list spans the entire width of the page (or its parent component) by default. In order to adjust its width, we can wrap the List Group within a dbc.Col() element from earlier. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . Col ( dbc . ListGroup ([ dbc . ListGroupItem ( \"First is the worst!\" ), dbc . ListGroupItem ( \"Second is the best!\" ), dbc . ListGroupItem ( \"Third is the one with the Treasure Chest!\" ) ]), width = 4 ) ]) app . run_server ( mode = 'external' ) There we go, much better! Now let's add some style...","title":"List Group"},{"location":"quick/02_notes/#coloring-cells","text":"In order to add color to each list item, we can simply use the color argument: app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . Col ( dbc . ListGroup ([ dbc . ListGroupItem ( \"First is the worst!\" , color = 'danger' ), dbc . ListGroupItem ( \"Second is the best!\" , color = \"success\" ), dbc . ListGroupItem ( \"Third is the one with the Treasure Chest!\" , color = \"info\" ) ]), width = 4 ) ]) app . run_server ( mode = 'external' ) As with other bootstrap components, the pre-built color options carry over in name and hue.","title":"Coloring Cells"},{"location":"quick/02_notes/#horizontal-list","text":"Instead of keeping each list item stacked vertically, we can also arrange them horizontally. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dbc . Col ( dbc . ListGroup ([ dbc . ListGroupItem ( \"First is the worst!\" , color = 'danger' ), dbc . ListGroupItem ( \"Second is the best!\" , color = \"success\" ), dbc . ListGroupItem ( \"Third is the one with the Treasure Chest!\" , color = \"info\" ) ], horizontal = True ), width = 6 ) ]) app . run_server ( mode = 'external' ) As seen, it's just a matter of adding the horizontal argument to our dbc.ListGroup() . NOTE: For more information, feel free to check out the following resources: dbc.ListGroup() NOTE: All code segments from this chapter can be found in this Colab Notebook .","title":"Horizontal List"},{"location":"quick/03_notes/","text":"TigerGraph (pyTG, queries) \u00b6 Ch 06 - TigerGraph \u00b6 Basic pyTigerGraph Basic pyTigerGraph \u00b6 In Chapter 01 - Installation Island, we had connected to our Healthcare Starter Kit solution using pyTigerGraph. This connection has several existing functions that we can use to access general information about our graph. Running Queries \u00b6 Before beginning, we must execute two queries which will help populate portions of our Graph. More specifically, running the ex2_main_query followed by the algo_louvain query creates referral edges used to link prescribers together. These edges are then used to detect communities of prescribers , which are useful in analyzing the relationships among healthcare providers, claims, and referrals. To run these queries, we simply execute the following: conn . runInstalledQuery ( \"ex2_main_query\" ) conn . runInstalledQuery ( \"algo_louvain\" ) And voila, it's as simple as that! Now, we can begin to analyze the vertices and edges of our Graph... Getting Vertices and Edges \u00b6 In order to get all vertex types, we run conn.getVertexTypes() . Thes types can then be iterated through and the number of vertices belonging to each type can be determined via conn.getVertexCount() . Here's an example! print ( \"Vertices \\n \" ) for vertex in conn . getVertexTypes (): print ( \" \" + vertex + \": \" + repr ( conn . getVertexCount ( vertex ))) A similar methodology can be used for edges. Simply replace \"Vertex\" with \"Edge\", giving us conn.getEdgeTypes() and conn.getEdgeCount() : print ( \"Edges \\n \" ) for edge in conn . getEdgeTypes (): print ( \" \" + edge + \": \" + repr ( conn . getEdgeCount ( edge ))) NOTE: For a comprehensive list, feel free to check out: pyTG functions Built-in Queries Built-in Queries \u00b6 Our Healthcare Starter Kit comes with several pre-built queries. Each of them and their accompanying GSQL can be found in GraphStudio under the \"Write Queries\" tab. Here's a small snippet of what that page looks like: As seen on the left, there are a lot of options to explore! However, in this section we will dive into getClaims() and Print_community() getClaims \u00b6 The getClaims() query simply returns a list of all claims of a given prescriber. Here's a screenshot of the GSQL code (via GraphStudio) In order to access this query from Python, we can use the same conn.runInstalledQuery() as before: person_num = \"pre78\" claims = conn . runInstalledQuery ( \"getClaims\" , params = { \"inputPrescriber\" : person_num })[ 0 ][ 'claims' ] print ( claims ) As seen, the result is a list of claim vertices (established by 'v_type':'Claim' ). Using each claim's attributes dictionary, we can create a few neat visualizations. First, let's process this data... claims = conn . runInstalledQuery ( \"getClaims\" , params = { \"inputPrescriber\" : person_num })[ 0 ][ 'claims' ] title_map = {}; count_list = []; description_list = [] for number , claim in enumerate ( claims ): title = claim [ 'attributes' ][ 'CodeGroupTitle' ] desc = claim [ 'attributes' ][ 'ICD10CodeDescription' ] if desc is \"\" : desc = \"None provided!\" if title in title_map : title_map [ title ] = title_map [ title ] + 1 else : title_map [ title ] = 1 count_list . append ( number ) description_list . append ( desc ) Here, title_map simply keeps track of the frequency of each category of claim . count_list is simply a list of all the claim numbers while description_list holds the description of each claim (ex. \"Displaced fracture\"). Bar Chart \u00b6 Using this data, we can create a bar chart: titleList = [] countList = [] for entry in title_map : titleList . append ( entry ) countList . append ( title_map [ entry ]) # Next, we create a bar chart using a DataFrame countData = pd . DataFrame ( data = ( zip ( titleList , countList )), columns = [ 'Claim Title' , 'Count' ]) bar = px . bar ( countData , x = 'Claim Title' , y = 'Count' , title = '' , color_discrete_sequence = [ \"#DDEE00\" ] * len ( countData )) bar . update_xaxes ( type = 'category' , categoryorder = 'category ascending' ) bar . update_layout ( margin = dict ( l = 1 , r = 1 , t = 1 , b = 1 ), template = 'ggplot2' , xaxis_title = None ) bar . show () Pretty straightforward now that we've processed our query results! Dash Table \u00b6 Additionally, we can create a table of each claim. Using Dash Bootstrap Components , this becomes an easy task: descriptionData = pd . DataFrame ( data = ( zip ( count_list , description_list )), columns = [ 'Claim Num' , 'Claim Description' ]) header = [ html . Thead ( html . Tr ([ html . Th ( \"Claim Number\" ), html . Th ( \"Claim Description\" )]))] table = html . Div ( dbc . Table . from_dataframe ( descriptionData , striped = True , bordered = True ), style = { 'overflowY' : 'scroll' , 'height' : '450px' } ) Although this won't show until we add the table element to our dashboard, here's a sneak peek of the result! Print_Community \u00b6 Next up, we have Print_Community , which outputs the prescriber network that the inputted prescriber belongs to. For example, this is the following result given in GraphStudio when run with the input of \"pre78\" (Prescriber 78): In order to replicate this in Dash, we can utilize dash_cytoscape . This package allows for the creation of interactive graphs which can be easily modified and embedded into our dashboard. ! pip install dash - cytoscape import dash_cytoscape as cyto Now, we can begin impleninging the network. def getNetwork ( person_num ): comms = conn . runInstalledQuery ( \"Print_community\" , params = { \"inputPrescriber\" : person_num })[ 1 ][ '@@edgeList' ] vertices = {} els = [] for entry in comms : source = entry [ 'from_id' ] target = entry [ 'to_id' ] if source not in vertices : if source == person_num : els . append ({ 'data' : { 'id' : source , 'label' : source }, 'classes' : 'red' }) else : els . append ({ 'data' : { 'id' : source , 'label' : source }}) if target not in vertices : els . append ({ 'data' : { 'id' : target , 'label' : target }}) els . append ({ 'data' : { 'source' : source , 'target' : target }}) network = cyto . Cytoscape ( id = 'cytoscape' , elements = els , layout = { 'name' : 'breadthfirst' , 'padding' : 0 , 'x1' : - 1000 }, stylesheet = [ { 'selector' : 'node' , 'style' : { 'content' : 'data(label)' } }, { 'selector' : '.red' , 'style' : { 'background-color' : 'red' , } } ], style = { 'width' : '100%' , 'height' : '500px' , 'margin-left' : 0 } ) return network At the start, we run our query and parse through the results (each vertex/edge) in the prescriber community to create a list of elements, called els . These elements are in the appropriate format needed for Cytoscape. Vertex information is stored as {'data': {'id': source, 'label': source}} while edge information is stored as {'data': {'id': target, 'label': target}} . In both cases, source/target are simply vertex IDs. Although this won't show until we add the network element to our dashboard, here's another sneak peek! NOTE: For more information, feel free to check out the following resources: Dash Cytoscape Custom Queries Custom Queries \u00b6 We can create custom queries in two ways: Via GSQL in GraphStudio under the \"Write Queries\" tab In our Python Script via the function conn.gsql() Claim_Titles \u00b6 Let's take a look at a GSQL query that returns a frequency map of all the claims within the Graph. Claim_Titles = '''USE GRAPH MyGraph CREATE QUERY Claim_Titles() FOR GRAPH MyGraph { MapAccum<STRING, SumAccum<INT>> @@allClaims; start = {Claim.*}; claims = SELECT c FROM start:c ACCUM @@allClaims += (c.CodeGroupTitle -> 1); PRINT @@allClaims as freqClaims; } INSTALL QUERY Claim_Titles''' print ( conn . gsql ( Claim_Titles , options = [])) First, our GSQL is all stored in one variable , a string. The first line of our GSQL statement establishes which graph we're using The next line is our query header , which establishes the name of the query as well as any parameters or return values. In this case, there are no parameters (indicated by the empty paranthesis after the query name) and we are simply printing the results into a variable rather than returning any values. Now, we can dive into our query logic. With the line MapAccum<STRING, SumAccum<INT>> @@allClaims; , we create an accumulator that maps strings to a sum accumulator. Each string holds the claim title while the sum accumulator simply counts the number of instances of each claim title After this, we start with the entire set of vertices of type \"Claim\". Within our SELECT statement, we iterate across this entire set of claims and update our accumulator via ACCUM @@allClaims += (c.CodeGroupTitle -> 1); Finally, we print our map accumulator so that we may access it via Python The last line simply installs the query After writing this query, we run print(conn.gsql(Claim_Titles, options=[])) in order to install it. NOTE: If a query is already installed, trying to re-install it will result in an error! And voila, now we can access this query in GraphStudio as well. Ahh, you may have noticed the three additional queries on the left. Don't worry, that's part of the next section! Let's create a Pie Chart using this data! def getClaimsPieChart (): res = conn . runInstalledQuery ( \"Claim_Titles\" )[ 0 ][ 'freqClaims' ] claims = list ( res . keys ()) counts = list ( res . values ()) pie = px . pie ( values = counts , names = claims , hole = 0.2 , ) pie . update_layout ( width = 2000 , title_x = 0.5 , showlegend = False , margin = dict ( l = 10 , r = 10 , t = 10 , b = 10 )) pie . update_traces ( textposition = 'inside' , textinfo = 'label+percent' , ) return pie As the outputted result is a map, we can simply use the .keys() and .values() functions in Python in order to access the results. The rest is standard pie chart creation via Plotly Express. And ta-da, here's our fantastic figure: CommVsReferrals \u00b6 Next up, we can create a query to determine if having a larger prescriber network corresponds to an increase in average referrals received. In other words, does being in a prescriber community lead to more business? Before we can tackle this question, we need to create two helper queries in GSQL... Helper_NumMembers \u00b6 First, we need to be able to find the number of community members for a given prescriber. Helper_NumMembers = '''USE GRAPH MyGraph CREATE QUERY Helper_NumMembers(vertex<Prescriber> inputPrescriber) FOR GRAPH MyGraph RETURNS (INT) { SumAccum<INT> @@numMembers; SumAccum<int> @@cid; Start= {inputPrescriber} ; Start=Select s from Start:s post-accum @@cid += s.communityId; Start = {Prescriber.*}; Start = select s from Start:s-(referral:e)-:t where s.communityId == @@cid and s.communityId == t.communityId accum @@numMembers += 1; RETURN @@numMembers; } INSTALL QUERY Helper_NumMembers''' print ( conn . gsql ( Helper_NumMembers , options = [])) Let's break it down! First, this helper query takes a Prescriber vertex as its input. Additionally, it returns a type INT , the number of members in the prescriber's community. We create two accumulators , one to store the number of members in the community, and another to simply store the inputted prescriber's community ID. The inputted prescriber's community ID is stored in the first SELECT statement In the second SELECT statment, we iterate through every prescriber and increment our counter only if the community IDs of two connected prescribers match. This value (the sum accumulator) is returned, not printed! That wasn't so bad to flesh out! Next up, a similar helper function... Helper_NumReferrals \u00b6 Now, we need to be able to find the number of referrals for a given prescriber. Helper_NumReferrals = '''USE GRAPH MyGraph CREATE QUERY Helper_NumReferrals(vertex<Prescriber> inputPrescriber) FOR GRAPH MyGraph RETURNS (INT) { SumAccum<INT> @@numReferrals; Start= {inputPrescriber} ; referrals = SELECT p1 FROM Start:p1 -(referral:r) -Prescriber:p2 ACCUM @@numReferrals += 1; RETURN @@numReferrals; } INSTALL QUERY Helper_NumReferrals''' print ( conn . gsql ( Helper_NumReferrals , options = [])) This is quite similar to our previous helper function: In our first and second line, we specify the input parameter and return type respectively Next, we create a sum accumulator to store the number of referrals for the inputted prescriber In our select statement, we iterate through every referral given and increment the counter by 1. The results are returned, not printed! Using these two helper functions, we can write our main query. Main Query \u00b6 In order to write our main query, we can simply reference our two helper functions: CommVsReferrals = '''USE GRAPH MyGraph CREATE QUERY CommVsReferrals() FOR GRAPH MyGraph { MapAccum<INT, AvgAccum> @@commReferrals; start = {Prescriber.*}; allPres = SELECT p FROM start:p ACCUM @@commReferrals += (Helper_NumMembers(p) -> Helper_NumReferrals(p)); PRINT @@commReferrals as commReferrals; } INSTALL QUERY CommVsReferrals''' print ( conn . gsql ( CommVsReferrals , options = [])) First, we create a Map Accumulator for each community size and the average number of referrals that each member in that community received. Next, we iterate across all prescribers in our SELECT statement and add the number of members as well as the number of referrals. Because of our AvgAccum , we don't have to do any other work! NOTE: As you may have noticed, AvgAccum does not take a datatype as a parameter! With this query installed, we can reference and visualize the results. def getScatterChart (): referrals = conn . runInstalledQuery ( \"CommVsReferrals\" )[ 0 ][ 'commReferrals' ] sizes = list ( referrals . keys ()) avgs = list ( referrals . values ()) scatter = px . scatter ( x = sizes , y = avgs , size = avgs , color = avgs ) scatter . update_coloraxes ( colorbar_title = \"Avg\" ) scatter . update_layout ( title = \"Prescriber Community Size vs. Average Referrals per Prescriber\" , xaxis_title = \"Prescriber Community Size\" , yaxis_title = \"Avg Referrals per Prescriber\" , width = 1000 ) return scatter Once again, as the outputted result is a map, we can simply use the .keys() and .values() functions in Python in order to access the results. And here's the resulting scatter plot. Hmm, a spike around 15 members. A coincidence? Maybe. We'll need more data to find out \ud83d\ude04! Putting it Together Putting it Together \u00b6 In order to piece everything together, we'll start by storing several components in variables. Titles and ListGroups First, we'll create a title card as well as a list group to hold all the vertices and edge counts. titleCard = dbc . Card ([ dbc . CardBody ([ html . Center ( html . H1 ( \"TigerGraph's HealthCare Starter Kit\" , className = 'card-title' )), ]) ], color = 'light' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , #\"margin-left\":\"1rem\", \"margin-top\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) vItems = [ dbc . ListGroupItem ( vertex + \": \" + repr ( conn . getVertexCount ( vertex )), color = 'info' ) for vertex in conn . getVertexTypes ()] eItems = [ dbc . ListGroupItem ( edge + \": \" + repr ( conn . getEdgeCount ( edge )), color = 'success' ) for edge in conn . getEdgeTypes ()] listItems = vItems + eItems statsListGroup = dbc . ListGroup ( listItems , horizontal = True ) Pie, Scatter Chart Next up, we'll use our getClaimsPieChart() and getScatterChart() functions from before to create two cards. pieChart = getClaimsPieChart () scatterChart = getScatterChart () pieChartCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"All Submitted Claims\" , className = 'card-title' ), html . P ( \"Which categories of claims are most frequent? \\n Which areas should prescribers focus on?\" , className = 'card-body' ), dcc . Graph ( id = 'Pie Chart' , figure = pieChart ) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"50rem\" , \"margin-right\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) scatterChartCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Prescriber Communities\" , className = 'card-title' ), html . P ( \"Do communities lead to more business? How do the number of referrals compare to community size?\" , className = 'card-body' ), dcc . Graph ( id = 'Scatter Chart' , figure = scatterChart ) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"50rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) Table, Bar We can piece together a function getClaims() that generates our table and bar chart. def getClaims ( person_num ): claims = conn . runInstalledQuery ( \"getClaims\" , params = { \"inputPrescriber\" : person_num })[ 0 ][ 'claims' ] title_map = {}; count_list = []; description_list = [] for number , claim in enumerate ( claims ): title = claim [ 'attributes' ][ 'CodeGroupTitle' ] desc = claim [ 'attributes' ][ 'ICD10CodeDescription' ] if desc is \"\" : desc = \"None provided!\" if title in title_map : title_map [ title ] = title_map [ title ] + 1 else : title_map [ title ] = 1 count_list . append ( number ) description_list . append ( desc ) # We'll create a table w/ the Descriptions! descriptionData = pd . DataFrame ( data = ( zip ( count_list , description_list )), columns = [ 'Claim Num' , 'Claim Description' ]) header = [ html . Thead ( html . Tr ([ html . Th ( \"Claim Number\" ), html . Th ( \"Claim Description\" )]))] table = html . Div ( dbc . Table . from_dataframe ( descriptionData , striped = True , bordered = True ), style = { 'overflowY' : 'scroll' , 'height' : '450px' } ) # We'll create a bar chart w/ the Claim Titles titleList = [] countList = [] for entry in title_map : titleList . append ( entry ) countList . append ( title_map [ entry ]) countData = pd . DataFrame ( data = ( zip ( titleList , countList )), columns = [ 'Claim Title' , 'Count' ]) bar = px . bar ( countData , x = 'Claim Title' , y = 'Count' , title = '' , color_discrete_sequence = [ \"#DDEE00\" ] * len ( countData )) bar . update_xaxes ( type = 'category' , categoryorder = 'category ascending' ) bar . update_layout ( margin = dict ( l = 1 , r = 1 , t = 1 , b = 1 ), template = 'ggplot2' , xaxis_title = None ) max_key = max ( title_map , key = title_map . get ) return len ( claims ), table , bar , max_key This function will also return the number of claims as well as the highest claim category ( max_key ). Network Graph, Prescriber Info We can use our getNetwork() function from the \"Print_Community\" section as well as getClaims() from above in order to create getPrescriberInfo() . This function will be inputted a prescriber and return the calculated statistics and figures regarding the prescriber. Although this function may seem long, most of it is just stylistic cards! def getPrescriberInfo ( person_num ): network = getNetwork ( person_num ) number , table , bar , max_title = getClaims ( person_num ) prescriberTitleCard = dbc . Card ([ dbc . CardBody ([ html . Center ( dbc . Badge ([ html . H1 ( \" Prescriber \" + person_num + \"'s Claims \" , className = 'card-title' )], color = \"light\" )), html . Center ( html . P ( \"This individual has a total of \" + repr ( number ) + \" claims. Their most referred to specialization is: \" + max_title , className = 'card-body' )), ]) ], outline = True , color = 'info' , style = { \"width\" : \"98rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) tableCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Claims by Prescriber\" , className = 'card-title' ), html . P ( \"A detailed description of each claim...\" , className = 'card-body' ), table ]) ], outline = True , color = 'info' , style = { \"width\" : \"50rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) barCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Claims by Category\" , className = 'card-title' ), html . P ( \"Which claims are being prescribed most?\" , className = 'card-body' ), dcc . Graph ( id = 'Bar Chart' , figure = bar ) ]) ], outline = True , color = 'info' , style = { \"width\" : \"50rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) networkCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Prescriber Network\" , className = 'card-title' ), html . P ( \"Who's part of this prescriber's community?\" , className = 'card-body' ), network ]) ], outline = True , color = 'info' , style = { \"width\" : \"50rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) return prescriberTitleCard , tableCard , barCard , networkCard , network As seen, we store all the figures as variables at the top. Next, we create cards for each. Dashboard Itself \u00b6 With all of the pieces ready to go, we can finally create our new dashboard. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) person_num = \"pre78\" prescriberTitleCard , tableCard , barCard , networkCard , network = getPrescriberInfo ( person_num ) app . layout = html . Center ( html . Div ([ dbc . Row ( titleCard , justify = \"center\" ), dbc . Row ( statsListGroup , justify = \"center\" ), html . Br (), dbc . Row ([ pieChartCard , scatterChartCard , ], justify = \"center\" ), html . Hr (), prescriberTitleCard , dbc . Row ([ dbc . Col ([ tableCard , network ]), dbc . Col ([ barCard , networkCard ]) ], justify = \"center\" ) ])) app . run_server ( mode = 'external' ) Having created all those variables earlier makes the app layout far easier to read and understand. This is a good practice for creating dashboards, as it allows for easier modification and testing instead of having to scroll through hundreds of lines of card bodies, figures, and more. And now, our hard work pays off: NOTE: All code segments from this chapter can be found in this Colab Notebook .","title":"TigerGraph (pyTG, queries) \ud83d\udc2f"},{"location":"quick/03_notes/#tigergraph-pytg-queries","text":"","title":"TigerGraph (pyTG, queries)"},{"location":"quick/03_notes/#ch-06-tigergraph","text":"Basic pyTigerGraph","title":"Ch 06 - TigerGraph"},{"location":"quick/03_notes/#basic-pytigergraph","text":"In Chapter 01 - Installation Island, we had connected to our Healthcare Starter Kit solution using pyTigerGraph. This connection has several existing functions that we can use to access general information about our graph.","title":"Basic pyTigerGraph"},{"location":"quick/03_notes/#running-queries","text":"Before beginning, we must execute two queries which will help populate portions of our Graph. More specifically, running the ex2_main_query followed by the algo_louvain query creates referral edges used to link prescribers together. These edges are then used to detect communities of prescribers , which are useful in analyzing the relationships among healthcare providers, claims, and referrals. To run these queries, we simply execute the following: conn . runInstalledQuery ( \"ex2_main_query\" ) conn . runInstalledQuery ( \"algo_louvain\" ) And voila, it's as simple as that! Now, we can begin to analyze the vertices and edges of our Graph...","title":"Running Queries"},{"location":"quick/03_notes/#getting-vertices-and-edges","text":"In order to get all vertex types, we run conn.getVertexTypes() . Thes types can then be iterated through and the number of vertices belonging to each type can be determined via conn.getVertexCount() . Here's an example! print ( \"Vertices \\n \" ) for vertex in conn . getVertexTypes (): print ( \" \" + vertex + \": \" + repr ( conn . getVertexCount ( vertex ))) A similar methodology can be used for edges. Simply replace \"Vertex\" with \"Edge\", giving us conn.getEdgeTypes() and conn.getEdgeCount() : print ( \"Edges \\n \" ) for edge in conn . getEdgeTypes (): print ( \" \" + edge + \": \" + repr ( conn . getEdgeCount ( edge ))) NOTE: For a comprehensive list, feel free to check out: pyTG functions Built-in Queries","title":"Getting Vertices and Edges"},{"location":"quick/03_notes/#built-in-queries","text":"Our Healthcare Starter Kit comes with several pre-built queries. Each of them and their accompanying GSQL can be found in GraphStudio under the \"Write Queries\" tab. Here's a small snippet of what that page looks like: As seen on the left, there are a lot of options to explore! However, in this section we will dive into getClaims() and Print_community()","title":"Built-in Queries"},{"location":"quick/03_notes/#getclaims","text":"The getClaims() query simply returns a list of all claims of a given prescriber. Here's a screenshot of the GSQL code (via GraphStudio) In order to access this query from Python, we can use the same conn.runInstalledQuery() as before: person_num = \"pre78\" claims = conn . runInstalledQuery ( \"getClaims\" , params = { \"inputPrescriber\" : person_num })[ 0 ][ 'claims' ] print ( claims ) As seen, the result is a list of claim vertices (established by 'v_type':'Claim' ). Using each claim's attributes dictionary, we can create a few neat visualizations. First, let's process this data... claims = conn . runInstalledQuery ( \"getClaims\" , params = { \"inputPrescriber\" : person_num })[ 0 ][ 'claims' ] title_map = {}; count_list = []; description_list = [] for number , claim in enumerate ( claims ): title = claim [ 'attributes' ][ 'CodeGroupTitle' ] desc = claim [ 'attributes' ][ 'ICD10CodeDescription' ] if desc is \"\" : desc = \"None provided!\" if title in title_map : title_map [ title ] = title_map [ title ] + 1 else : title_map [ title ] = 1 count_list . append ( number ) description_list . append ( desc ) Here, title_map simply keeps track of the frequency of each category of claim . count_list is simply a list of all the claim numbers while description_list holds the description of each claim (ex. \"Displaced fracture\").","title":"getClaims"},{"location":"quick/03_notes/#bar-chart","text":"Using this data, we can create a bar chart: titleList = [] countList = [] for entry in title_map : titleList . append ( entry ) countList . append ( title_map [ entry ]) # Next, we create a bar chart using a DataFrame countData = pd . DataFrame ( data = ( zip ( titleList , countList )), columns = [ 'Claim Title' , 'Count' ]) bar = px . bar ( countData , x = 'Claim Title' , y = 'Count' , title = '' , color_discrete_sequence = [ \"#DDEE00\" ] * len ( countData )) bar . update_xaxes ( type = 'category' , categoryorder = 'category ascending' ) bar . update_layout ( margin = dict ( l = 1 , r = 1 , t = 1 , b = 1 ), template = 'ggplot2' , xaxis_title = None ) bar . show () Pretty straightforward now that we've processed our query results!","title":"Bar Chart"},{"location":"quick/03_notes/#dash-table","text":"Additionally, we can create a table of each claim. Using Dash Bootstrap Components , this becomes an easy task: descriptionData = pd . DataFrame ( data = ( zip ( count_list , description_list )), columns = [ 'Claim Num' , 'Claim Description' ]) header = [ html . Thead ( html . Tr ([ html . Th ( \"Claim Number\" ), html . Th ( \"Claim Description\" )]))] table = html . Div ( dbc . Table . from_dataframe ( descriptionData , striped = True , bordered = True ), style = { 'overflowY' : 'scroll' , 'height' : '450px' } ) Although this won't show until we add the table element to our dashboard, here's a sneak peek of the result!","title":"Dash Table"},{"location":"quick/03_notes/#print_community","text":"Next up, we have Print_Community , which outputs the prescriber network that the inputted prescriber belongs to. For example, this is the following result given in GraphStudio when run with the input of \"pre78\" (Prescriber 78): In order to replicate this in Dash, we can utilize dash_cytoscape . This package allows for the creation of interactive graphs which can be easily modified and embedded into our dashboard. ! pip install dash - cytoscape import dash_cytoscape as cyto Now, we can begin impleninging the network. def getNetwork ( person_num ): comms = conn . runInstalledQuery ( \"Print_community\" , params = { \"inputPrescriber\" : person_num })[ 1 ][ '@@edgeList' ] vertices = {} els = [] for entry in comms : source = entry [ 'from_id' ] target = entry [ 'to_id' ] if source not in vertices : if source == person_num : els . append ({ 'data' : { 'id' : source , 'label' : source }, 'classes' : 'red' }) else : els . append ({ 'data' : { 'id' : source , 'label' : source }}) if target not in vertices : els . append ({ 'data' : { 'id' : target , 'label' : target }}) els . append ({ 'data' : { 'source' : source , 'target' : target }}) network = cyto . Cytoscape ( id = 'cytoscape' , elements = els , layout = { 'name' : 'breadthfirst' , 'padding' : 0 , 'x1' : - 1000 }, stylesheet = [ { 'selector' : 'node' , 'style' : { 'content' : 'data(label)' } }, { 'selector' : '.red' , 'style' : { 'background-color' : 'red' , } } ], style = { 'width' : '100%' , 'height' : '500px' , 'margin-left' : 0 } ) return network At the start, we run our query and parse through the results (each vertex/edge) in the prescriber community to create a list of elements, called els . These elements are in the appropriate format needed for Cytoscape. Vertex information is stored as {'data': {'id': source, 'label': source}} while edge information is stored as {'data': {'id': target, 'label': target}} . In both cases, source/target are simply vertex IDs. Although this won't show until we add the network element to our dashboard, here's another sneak peek! NOTE: For more information, feel free to check out the following resources: Dash Cytoscape Custom Queries","title":"Print_Community"},{"location":"quick/03_notes/#custom-queries","text":"We can create custom queries in two ways: Via GSQL in GraphStudio under the \"Write Queries\" tab In our Python Script via the function conn.gsql()","title":"Custom Queries"},{"location":"quick/03_notes/#claim_titles","text":"Let's take a look at a GSQL query that returns a frequency map of all the claims within the Graph. Claim_Titles = '''USE GRAPH MyGraph CREATE QUERY Claim_Titles() FOR GRAPH MyGraph { MapAccum<STRING, SumAccum<INT>> @@allClaims; start = {Claim.*}; claims = SELECT c FROM start:c ACCUM @@allClaims += (c.CodeGroupTitle -> 1); PRINT @@allClaims as freqClaims; } INSTALL QUERY Claim_Titles''' print ( conn . gsql ( Claim_Titles , options = [])) First, our GSQL is all stored in one variable , a string. The first line of our GSQL statement establishes which graph we're using The next line is our query header , which establishes the name of the query as well as any parameters or return values. In this case, there are no parameters (indicated by the empty paranthesis after the query name) and we are simply printing the results into a variable rather than returning any values. Now, we can dive into our query logic. With the line MapAccum<STRING, SumAccum<INT>> @@allClaims; , we create an accumulator that maps strings to a sum accumulator. Each string holds the claim title while the sum accumulator simply counts the number of instances of each claim title After this, we start with the entire set of vertices of type \"Claim\". Within our SELECT statement, we iterate across this entire set of claims and update our accumulator via ACCUM @@allClaims += (c.CodeGroupTitle -> 1); Finally, we print our map accumulator so that we may access it via Python The last line simply installs the query After writing this query, we run print(conn.gsql(Claim_Titles, options=[])) in order to install it. NOTE: If a query is already installed, trying to re-install it will result in an error! And voila, now we can access this query in GraphStudio as well. Ahh, you may have noticed the three additional queries on the left. Don't worry, that's part of the next section! Let's create a Pie Chart using this data! def getClaimsPieChart (): res = conn . runInstalledQuery ( \"Claim_Titles\" )[ 0 ][ 'freqClaims' ] claims = list ( res . keys ()) counts = list ( res . values ()) pie = px . pie ( values = counts , names = claims , hole = 0.2 , ) pie . update_layout ( width = 2000 , title_x = 0.5 , showlegend = False , margin = dict ( l = 10 , r = 10 , t = 10 , b = 10 )) pie . update_traces ( textposition = 'inside' , textinfo = 'label+percent' , ) return pie As the outputted result is a map, we can simply use the .keys() and .values() functions in Python in order to access the results. The rest is standard pie chart creation via Plotly Express. And ta-da, here's our fantastic figure:","title":"Claim_Titles"},{"location":"quick/03_notes/#commvsreferrals","text":"Next up, we can create a query to determine if having a larger prescriber network corresponds to an increase in average referrals received. In other words, does being in a prescriber community lead to more business? Before we can tackle this question, we need to create two helper queries in GSQL...","title":"CommVsReferrals"},{"location":"quick/03_notes/#helper_nummembers","text":"First, we need to be able to find the number of community members for a given prescriber. Helper_NumMembers = '''USE GRAPH MyGraph CREATE QUERY Helper_NumMembers(vertex<Prescriber> inputPrescriber) FOR GRAPH MyGraph RETURNS (INT) { SumAccum<INT> @@numMembers; SumAccum<int> @@cid; Start= {inputPrescriber} ; Start=Select s from Start:s post-accum @@cid += s.communityId; Start = {Prescriber.*}; Start = select s from Start:s-(referral:e)-:t where s.communityId == @@cid and s.communityId == t.communityId accum @@numMembers += 1; RETURN @@numMembers; } INSTALL QUERY Helper_NumMembers''' print ( conn . gsql ( Helper_NumMembers , options = [])) Let's break it down! First, this helper query takes a Prescriber vertex as its input. Additionally, it returns a type INT , the number of members in the prescriber's community. We create two accumulators , one to store the number of members in the community, and another to simply store the inputted prescriber's community ID. The inputted prescriber's community ID is stored in the first SELECT statement In the second SELECT statment, we iterate through every prescriber and increment our counter only if the community IDs of two connected prescribers match. This value (the sum accumulator) is returned, not printed! That wasn't so bad to flesh out! Next up, a similar helper function...","title":"Helper_NumMembers"},{"location":"quick/03_notes/#helper_numreferrals","text":"Now, we need to be able to find the number of referrals for a given prescriber. Helper_NumReferrals = '''USE GRAPH MyGraph CREATE QUERY Helper_NumReferrals(vertex<Prescriber> inputPrescriber) FOR GRAPH MyGraph RETURNS (INT) { SumAccum<INT> @@numReferrals; Start= {inputPrescriber} ; referrals = SELECT p1 FROM Start:p1 -(referral:r) -Prescriber:p2 ACCUM @@numReferrals += 1; RETURN @@numReferrals; } INSTALL QUERY Helper_NumReferrals''' print ( conn . gsql ( Helper_NumReferrals , options = [])) This is quite similar to our previous helper function: In our first and second line, we specify the input parameter and return type respectively Next, we create a sum accumulator to store the number of referrals for the inputted prescriber In our select statement, we iterate through every referral given and increment the counter by 1. The results are returned, not printed! Using these two helper functions, we can write our main query.","title":"Helper_NumReferrals"},{"location":"quick/03_notes/#main-query","text":"In order to write our main query, we can simply reference our two helper functions: CommVsReferrals = '''USE GRAPH MyGraph CREATE QUERY CommVsReferrals() FOR GRAPH MyGraph { MapAccum<INT, AvgAccum> @@commReferrals; start = {Prescriber.*}; allPres = SELECT p FROM start:p ACCUM @@commReferrals += (Helper_NumMembers(p) -> Helper_NumReferrals(p)); PRINT @@commReferrals as commReferrals; } INSTALL QUERY CommVsReferrals''' print ( conn . gsql ( CommVsReferrals , options = [])) First, we create a Map Accumulator for each community size and the average number of referrals that each member in that community received. Next, we iterate across all prescribers in our SELECT statement and add the number of members as well as the number of referrals. Because of our AvgAccum , we don't have to do any other work! NOTE: As you may have noticed, AvgAccum does not take a datatype as a parameter! With this query installed, we can reference and visualize the results. def getScatterChart (): referrals = conn . runInstalledQuery ( \"CommVsReferrals\" )[ 0 ][ 'commReferrals' ] sizes = list ( referrals . keys ()) avgs = list ( referrals . values ()) scatter = px . scatter ( x = sizes , y = avgs , size = avgs , color = avgs ) scatter . update_coloraxes ( colorbar_title = \"Avg\" ) scatter . update_layout ( title = \"Prescriber Community Size vs. Average Referrals per Prescriber\" , xaxis_title = \"Prescriber Community Size\" , yaxis_title = \"Avg Referrals per Prescriber\" , width = 1000 ) return scatter Once again, as the outputted result is a map, we can simply use the .keys() and .values() functions in Python in order to access the results. And here's the resulting scatter plot. Hmm, a spike around 15 members. A coincidence? Maybe. We'll need more data to find out \ud83d\ude04! Putting it Together","title":"Main Query"},{"location":"quick/03_notes/#putting-it-together","text":"In order to piece everything together, we'll start by storing several components in variables. Titles and ListGroups First, we'll create a title card as well as a list group to hold all the vertices and edge counts. titleCard = dbc . Card ([ dbc . CardBody ([ html . Center ( html . H1 ( \"TigerGraph's HealthCare Starter Kit\" , className = 'card-title' )), ]) ], color = 'light' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"55rem\" , #\"margin-left\":\"1rem\", \"margin-top\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) vItems = [ dbc . ListGroupItem ( vertex + \": \" + repr ( conn . getVertexCount ( vertex )), color = 'info' ) for vertex in conn . getVertexTypes ()] eItems = [ dbc . ListGroupItem ( edge + \": \" + repr ( conn . getEdgeCount ( edge )), color = 'success' ) for edge in conn . getEdgeTypes ()] listItems = vItems + eItems statsListGroup = dbc . ListGroup ( listItems , horizontal = True ) Pie, Scatter Chart Next up, we'll use our getClaimsPieChart() and getScatterChart() functions from before to create two cards. pieChart = getClaimsPieChart () scatterChart = getScatterChart () pieChartCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"All Submitted Claims\" , className = 'card-title' ), html . P ( \"Which categories of claims are most frequent? \\n Which areas should prescribers focus on?\" , className = 'card-body' ), dcc . Graph ( id = 'Pie Chart' , figure = pieChart ) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"50rem\" , \"margin-right\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) scatterChartCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Prescriber Communities\" , className = 'card-title' ), html . P ( \"Do communities lead to more business? How do the number of referrals compare to community size?\" , className = 'card-body' ), dcc . Graph ( id = 'Scatter Chart' , figure = scatterChart ) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"50rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) Table, Bar We can piece together a function getClaims() that generates our table and bar chart. def getClaims ( person_num ): claims = conn . runInstalledQuery ( \"getClaims\" , params = { \"inputPrescriber\" : person_num })[ 0 ][ 'claims' ] title_map = {}; count_list = []; description_list = [] for number , claim in enumerate ( claims ): title = claim [ 'attributes' ][ 'CodeGroupTitle' ] desc = claim [ 'attributes' ][ 'ICD10CodeDescription' ] if desc is \"\" : desc = \"None provided!\" if title in title_map : title_map [ title ] = title_map [ title ] + 1 else : title_map [ title ] = 1 count_list . append ( number ) description_list . append ( desc ) # We'll create a table w/ the Descriptions! descriptionData = pd . DataFrame ( data = ( zip ( count_list , description_list )), columns = [ 'Claim Num' , 'Claim Description' ]) header = [ html . Thead ( html . Tr ([ html . Th ( \"Claim Number\" ), html . Th ( \"Claim Description\" )]))] table = html . Div ( dbc . Table . from_dataframe ( descriptionData , striped = True , bordered = True ), style = { 'overflowY' : 'scroll' , 'height' : '450px' } ) # We'll create a bar chart w/ the Claim Titles titleList = [] countList = [] for entry in title_map : titleList . append ( entry ) countList . append ( title_map [ entry ]) countData = pd . DataFrame ( data = ( zip ( titleList , countList )), columns = [ 'Claim Title' , 'Count' ]) bar = px . bar ( countData , x = 'Claim Title' , y = 'Count' , title = '' , color_discrete_sequence = [ \"#DDEE00\" ] * len ( countData )) bar . update_xaxes ( type = 'category' , categoryorder = 'category ascending' ) bar . update_layout ( margin = dict ( l = 1 , r = 1 , t = 1 , b = 1 ), template = 'ggplot2' , xaxis_title = None ) max_key = max ( title_map , key = title_map . get ) return len ( claims ), table , bar , max_key This function will also return the number of claims as well as the highest claim category ( max_key ). Network Graph, Prescriber Info We can use our getNetwork() function from the \"Print_Community\" section as well as getClaims() from above in order to create getPrescriberInfo() . This function will be inputted a prescriber and return the calculated statistics and figures regarding the prescriber. Although this function may seem long, most of it is just stylistic cards! def getPrescriberInfo ( person_num ): network = getNetwork ( person_num ) number , table , bar , max_title = getClaims ( person_num ) prescriberTitleCard = dbc . Card ([ dbc . CardBody ([ html . Center ( dbc . Badge ([ html . H1 ( \" Prescriber \" + person_num + \"'s Claims \" , className = 'card-title' )], color = \"light\" )), html . Center ( html . P ( \"This individual has a total of \" + repr ( number ) + \" claims. Their most referred to specialization is: \" + max_title , className = 'card-body' )), ]) ], outline = True , color = 'info' , style = { \"width\" : \"98rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) tableCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Claims by Prescriber\" , className = 'card-title' ), html . P ( \"A detailed description of each claim...\" , className = 'card-body' ), table ]) ], outline = True , color = 'info' , style = { \"width\" : \"50rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) barCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Claims by Category\" , className = 'card-title' ), html . P ( \"Which claims are being prescribed most?\" , className = 'card-body' ), dcc . Graph ( id = 'Bar Chart' , figure = bar ) ]) ], outline = True , color = 'info' , style = { \"width\" : \"50rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) networkCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Prescriber Network\" , className = 'card-title' ), html . P ( \"Who's part of this prescriber's community?\" , className = 'card-body' ), network ]) ], outline = True , color = 'info' , style = { \"width\" : \"50rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) return prescriberTitleCard , tableCard , barCard , networkCard , network As seen, we store all the figures as variables at the top. Next, we create cards for each.","title":"Putting it Together"},{"location":"quick/03_notes/#dashboard-itself","text":"With all of the pieces ready to go, we can finally create our new dashboard. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) person_num = \"pre78\" prescriberTitleCard , tableCard , barCard , networkCard , network = getPrescriberInfo ( person_num ) app . layout = html . Center ( html . Div ([ dbc . Row ( titleCard , justify = \"center\" ), dbc . Row ( statsListGroup , justify = \"center\" ), html . Br (), dbc . Row ([ pieChartCard , scatterChartCard , ], justify = \"center\" ), html . Hr (), prescriberTitleCard , dbc . Row ([ dbc . Col ([ tableCard , network ]), dbc . Col ([ barCard , networkCard ]) ], justify = \"center\" ) ])) app . run_server ( mode = 'external' ) Having created all those variables earlier makes the app layout far easier to read and understand. This is a good practice for creating dashboards, as it allows for easier modification and testing instead of having to scroll through hundreds of lines of card bodies, figures, and more. And now, our hard work pays off: NOTE: All code segments from this chapter can be found in this Colab Notebook .","title":"Dashboard Itself"},{"location":"quick/04_notes/","text":"Multi-Page Layout, Callbacks \u00b6 Ch 07 - Multi-Page Layout \u00b6 A Simple Multi-Page App A Simple Multi-Page App \u00b6 The first step in creating multiple pages for our Dash app is to separate our content into multiple distinct variables or elements . For example, if we wish to create three pages, we can perform this by create three content variables : page1_content = html . Div ( html . H1 ( \"This is Pg. 1!\" )) page2_content = html . Div ( html . H1 ( html . B ( \"This is Pg. 2!\" ))) page3_content = html . Div ( html . H1 ( html . I ( \"This is Pg. 3!\" ))) Next, we must change our app layout to reflect this: app = JupyterDash ( __name__ ) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def display_page ( pathname ): if pathname == \"/\" : return page1_content elif pathname == \"/page2\" : return page2_content elif pathname == \"/page3\" : return page3_content app . run_server ( mode = 'external' ) And now, running the app will only show us the first page! However, entering the proper link will take us to pages 2 and 3. How are we doing this? Well, using a simple callback... As defined below the app layout, the input is simply the pathname of the current page . The output is the page-content, an html.Div element that we've defined in our app layout. This is where the importance of element id's comes into play! For any element that will be updated via a callback, an id is needed. @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) Breaking down the function display_page() , we simply compare the pathname to several predefined, valid pages. Then, the respective content is returned. This content is stored and displayed in html.Div(id='page-content') . NOTE: We will cover callbacks in the next chapter! This is merely an intro used to navigate through pages . Yet entering any other link will lead to a blank page... uh oh! We need to make sure that the user doesn't accidentally access any unauthorized or unbuilt pages . They should only be able to access the extension links that we've provided. In order to secure this, we can use Dash Bootstrap... Dash Jumbotron \u00b6 The Dash Jumbotron is a Bootstrap component that is used to showcase important messages . In this case, we'll use it to display a \"404 error message\" whenever the user reaches an unauthorized page . Adding this jumbotron is quite simple. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def display_page ( pathname ): if pathname == \"/\" : return page1_content elif pathname == \"/page2\" : return page2_content elif pathname == \"/page3\" : return page3_content return dbc . Jumbotron ( [ html . H1 ( \"404: Not found\" , className = \"text-danger\" ), html . Hr (), html . P ( \"Uh oh! Unfortunately, the pathname {} was unable to be recognised...\" . format ( pathname )), ] ) app . run_server ( mode = 'external' ) And just like that, we've put together a simple multi-page app! In order to modify each page, we can simply change the html.Div() element to contain our page's components. To add pages, we can extend our if/else. Yet as of now, users can only navigate by entering each page's link. Comprehensive Multi-Page App Comprehensive Multi-Page App \u00b6 Let's use our Healthcare Dashboard and partition it into two pages . General Page - Contains our title , listgroups , pie , and scatter plot Prescriber Page - contains our table , bar chart , and network graph Global Styles and Variables \u00b6 In order to create a better multi-page app, we must first determine what content is shared across our multiple pages . We can declare these as global variables and have them unchanged upon navigating across pages. This way, our dashboard is more responsive as there is less to recompute upon each refresh . NOTE: At the moment, we don't have any shared content . However, this will change in future chapters! The Two Pages \u00b6 Now, we can create content variables for each of the two pages, stored below: generalPage = html . Div ([ dbc . Row ( titleCard , justify = \"center\" ), dbc . Row ( statsListGroup , justify = \"center\" ), html . Br (), dbc . Row ([ pieChartCard , scatterChartCard , ], justify = \"center\" ), ]) prescriberPage = html . Div ([ dbc . Row ([ dbc . Col ( tableCard ), dbc . Col ([ barCard , networkCard ], ) ], justify = 'center' ), ]) As seen, we just split the two pages where our original html.Hr() used to be! Now, we can add in the simple callback to load the correct page. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def display_page ( pathname ): if pathname == \"/\" : return generalPage elif pathname == \"/pre\" : return prescriberPage return dbc . Jumbotron ( [ html . H1 ( \"404: Not found\" , className = \"text-danger\" ), html . Hr (), html . P ( \"Uh oh! Unfortunately, the pathname {} was unable to be recognised...\" . format ( pathname )), ] ) app . run_server ( mode = 'external' ) And here's our dashboard, now with multiple pages! Dash Links \u00b6 However, having to manually enter the url for each specific page is not a good practice . Luckily, Dash provides several methods for navigating through pages. One of the most common components used for navigation is the Dash Link , which allows users to select which page they wish to reach. Let's take a look! We simply modify our app.layout to include two dcc.Link() 's. These are essentially Dash's equivalent of hyperlinks . No additional callbacks needed, these links function perfectly by themselves! app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), dbc . Row ([ dbc . Col ( dcc . Link ( \"Go to Home\" , href = '/' ), width = 1 ), dbc . Col ( dcc . Link ( 'Go to Prescribers' , href = '/pre' ), width = 2 ), ], justify = \"start\" , ), html . Div ( id = 'page-content' ) ]) By including the dbc.Row() with our two links outside of html.Div(id='page-content') , it remains static and present in the same location on all pages . However, this may not always be needed. For example, we don't need to the \"Go to Prescribers\" hyperlink when we are already on that page. To overcome this, we turn to our layout variables . By adding one dcc.Link in each of our pages, we can remove any unnecessary overlap . generalPage = html . Center ( html . Div ([ dbc . Col ( dcc . Link ( \"Go to Prescribers\" , href = '/pre' ), width = 2 ), dbc . Row ( titleCard , justify = \"center\" ), dbc . Row ( statsListGroup , justify = \"center\" ), html . Br (), dbc . Row ([ pieChartCard , scatterChartCard , ], justify = \"center\" ), ])) prescriberPage = html . Center ( html . Div ([ dbc . Col ( dcc . Link ( \"Go to Home\" , href = '/' ), width = 1 ), prescriberTitleCard , dbc . Row ([ dbc . Col ( tableCard ), dbc . Col ([ barCard , networkCard ], ) ], justify = 'center' ), ])) Once again, no callbacks needed! This functions perfectly using the app.layout from before. NOTE: All code segments from this chapter can be found in this Colab Notebook . Ch 08 - Callbacks \u00b6 A Simple Callback A Simple Callback \u00b6 Callbacks are functions that are called automatically by Dash everytime a component's property changes . They allow for dynamic pages. We had taken a look at a simple callback in the last chapter, but let's flesh it out further . For reference, here's the code segment from before. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def display_page ( pathname ): if pathname == \"/\" : return generalPage elif pathname == \"/pre\" : return prescriberPage return dbc . Jumbotron ( [ html . H1 ( \"404: Not found\" , className = \"text-danger\" ), html . Hr (), html . P ( \"Uh oh! Unfortunately, the pathname {} was unable to be recognised...\" . format ( pathname )), ] ) app . run_server ( mode = 'external' ) As seen, our callback is introduced with the @ symbol It can take a list of Output elements as well as a list of Input elements In our example, it takes in the input with the ID 'url' . This component is dcc.Location(id=url, refresh=False) , which is a Dash element that simply keeps track of the url of the current page . In our example, the output element is html.Div(id='page-content') , which is just an empty placeholder . It's contents are currently empty, but replaced by the callback upon each url change That wasn't too bad to explain! As seen above, callbacks consist of: Header - specified by @app.callback() , followed immediately by a... Function - can be titled anything , takes in the callback input as a parameter . Let's take a look at a more complicated input! Introducing dbc.Button() \u00b6 Instead of just the url, what if we wanted to add more aesthetic functionality directly onto our dash page. One way to do this is with dbc.Button() element, which allows for cleaner clickability . This bootstrap component is quite easy to set up. generalPage = html . Center ( html . Div ([ dbc . Col ( dbc . Button ( \"Switch Pages\" , id = \"switch-button\" , className = \"mr-2\" , n_clicks = 0 , color = \"info\" , href = \"/pre\" ), width = 2 ), dbc . Row ( titleCard , justify = \"center\" ), dbc . Row ( statsListGroup , justify = \"center\" ), html . Br (), dbc . Row ([ pieChartCard , scatterChartCard , ], justify = \"center\" ), ])) prescriberPage = html . Center ( html . Div ([ dbc . Col ( dbc . Button ( \"Switch Pages\" , id = \"switch-button\" , className = \"mr-2\" , n_clicks = 0 , color = \"info\" , href = \"/\" ), width = 2 ), prescriberTitleCard , dbc . Row ([ dbc . Col ( tableCard ), dbc . Col ([ barCard , networkCard ], ) ], justify = 'center' ), ])) And that's it. No callbacks needed, at least for now . However, the button does have several other functionalities beyond serving as a glorified hyperlink. It can keep track of the number of clicks , serve as a method to download files , and be customized to change on click . NOTE: For more information on Buttons, feel free to check out the following resources: dbc.Button() Introducing dcc.Input() \u00b6 For more intricate input, we turn to dcc.Input() . This Dash Core Component supports several types of text entry , including: \"text\" - regular text, any character goes! \"number\" - numbers and hyphens (for negative) signs only \"password\" - each entered character will be shown as a black dot \"email\" - will ensure that entered text is a valid email format \"tel\" - will ensure that entered text is a valid telephone format This element is quite powerful, and can easily be incorporated as shown in this example: app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dcc . Input ( id = \"example-input\" , type = \"number\" , placeholder = \"Please enter a number.\" ), html . H1 ( \"Your number squared is:\" ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'example-input' , 'value' )]) def display_page ( value ): if value is None : return html . H3 ( \"N/A\" ) return html . H3 ( value * value ) app . run_server ( mode = 'external' ) Taking a closer look, we see that the id of the dcc.Input() is used in our callback. It's value attribute is passed in as the sole parameter of our callback function . Additionally, the input type has been specified to be a number. Additionally, it's good practice to ensure that regardless of the input, the callback returns some acceptable value ! Even if it's an empty html.Div() element, it's good practice to make sure that there are no edge cases. NOTE: Fore more information on input, feel free to check out the following resources: dcc.Input Comprehensive Callback Currently, the Prescribers page is static, fixed with the value \"pre-78\" . Let's change this so that users may able to search for any valid prescriber within the Graph . First, we need a list of all valid options... Acceptible Prescribers (Query) \u00b6 Using our knowledge from the TigerGraph Tundra , we can write a query that returns all Prescriber IDs. AllPrescribers = '''USE GRAPH MyGraph CREATE QUERY AllPrescribers() FOR GRAPH MyGraph { ListAccum<Vertex<Prescriber>> @@allPrescribers; start = {Prescriber.*}; allPres = SELECT p FROM start:p ACCUM @@allPrescribers += p; PRINT @@allPrescribers as allPrescribers; } INSTALL QUERY AllPrescribers''' print ( conn . gsql ( AllPrescribers , options = [])) Running this query gives us the following output, Now, we can package it into the appropriate format as follows. def getPresList (): pres = conn . runInstalledQuery ( \"AllPrescribers\" )[ 0 ][ 'allPrescribers' ] return [{ 'label' : x , 'value' : x } for x in pres ] Awesome! The question remains, how do we incorporate this list into our search? Although dcc.Input() can support this sort of wordbank in searches, for a simpler implementation we will utilize its close relative, dcc.Dropdown() . Let's take a closer look... Using dcc.Dropdown() \u00b6 Dash's Dropdown allows users to select values from a given list of possible options . This component is very powerful, allowing for multi-value selection , the ability to disable certain options , the ability to clear certain options , and the real-time updating of options based on the user's search terms. For this example, we will be using a basic implementation. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) presList = getPresList () app . layout = html . Div ([ dbc . Col ( dcc . Dropdown ( id = \"example-input\" , placeholder = \"Enter a prescriber...\" , options = presList ), width = 3 ), html . H1 ( \"Your chosen prescriber:\" ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'example-input' , 'value' )]) def display_page ( value ): if value is None : return html . H3 ( \"N/A\" ) return html . H3 ( value + \" is valid!\" ) app . run_server ( mode = 'external' ) Breaking it down, we specify the id , placeholder text , and list of options for our Dropdown element. Then, within our callback, we simply display the chosen value as well as some accompanying text. Here's the result. See, that wasn't so bad! Simple, yet quite powerful. NOTE: For more information on Dropdown, feel free to check out the following resources: dcc.Dropdown() Putting it Together \u00b6 Let's incorporate this search into our Prescribers Page. dropdown = dbc . Col ( dcc . Dropdown ( id = \"pres-dropdown\" , placeholder = \"Enter a prescriber...\" , options = getPresList () ), width = 3 ) def prescriberPage ( pres ): prescriberTitleCard , tableCard , barCard , networkCard = getPrescriberInfo ( pres ) page = html . Center ( html . Div ([ dbc . Row ([ dropdown , dbc . Col ( dbc . Button ( \"Switch Pages\" , id = \"switch-button\" , className = \"mr-2\" , n_clicks = 0 , color = \"info\" , href = \"/\" ), width = 2 ), ], justify = 'center' ), prescriberTitleCard , dbc . Row ([ dbc . Col ( tableCard ), dbc . Col ([ barCard , networkCard ], ) ], justify = 'center' ), ])) return page First, we create our dropdown component. Next, we create a parameterized function that returns the prescriber page for a given prescriber . Within this function, we incorporate the dropdown component (in the first dbc.Row() ). Now, we need to create our app and its callbacks. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ], suppress_callback_exceptions = True ) presPage = html . Div ( prescriberPage ( \"pre78\" ), id = 'pres-content' ) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def display_page ( pathname ): if pathname == \"/\" : return generalPage elif pathname == \"/pre\" : return presPage return dbc . Jumbotron ( [ html . H1 ( \"404: Not found\" , className = \"text-danger\" ), html . Hr (), html . P ( \"Uh oh! Unfortunately, the pathname {} was unable to be recognised...\" . format ( pathname )), ] ) @app . callback ( dash . dependencies . Output ( 'pres-content' , 'children' ), [ dash . dependencies . Input ( 'pres-dropdown' , 'value' )]) def update_pres ( value ): if value is not None : return prescriberPage ( value ) return prescriberPage ( \"pre78\" ) # Our default value app . run_server ( mode = 'external' ) Several changes from before, so let's take a closer look! First, we create a new variable to hold the contents of our prescriber page. Named presPage , this element contains a unique id and is set to store the default prescriber page value using Prescriber #78 . Next, we leave our app.layout() and first callback untouched. These allow for navigation. In order to utilize the value of the dropdown, we write a new callback . This time, it's input is the pres-dropdown component. This callback function simply returns the Prescriber Page with the given prescriber . Note that we've had to add suppress_callback_exceptions=True in order to prevent warning pop-ups. This is because when we are on the general page, the dropdown element has not been loaded yet. Although this is not an issue, Dash registers this as a warning! NOTE: Dashboards can have as many callbacks as desired. Although each callback can take unlimited inputs, each output can only be utilized once in a callback . For example, one cannot have two callbacks that both output page-content . This will return an error when loading the Dash app. This is why dash.dependencies.Output() is simply one element, while dash.dependencies.Input() is within a list. And with that, we have the first verison of our dynamic dashboard! NOTE: All code segments from this chapter can be found in this Colab Notebook .","title":"Multi-Page Layout, Callbacks"},{"location":"quick/04_notes/#multi-page-layout-callbacks","text":"","title":"Multi-Page Layout, Callbacks"},{"location":"quick/04_notes/#ch-07-multi-page-layout","text":"A Simple Multi-Page App","title":"Ch 07 - Multi-Page Layout"},{"location":"quick/04_notes/#a-simple-multi-page-app","text":"The first step in creating multiple pages for our Dash app is to separate our content into multiple distinct variables or elements . For example, if we wish to create three pages, we can perform this by create three content variables : page1_content = html . Div ( html . H1 ( \"This is Pg. 1!\" )) page2_content = html . Div ( html . H1 ( html . B ( \"This is Pg. 2!\" ))) page3_content = html . Div ( html . H1 ( html . I ( \"This is Pg. 3!\" ))) Next, we must change our app layout to reflect this: app = JupyterDash ( __name__ ) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def display_page ( pathname ): if pathname == \"/\" : return page1_content elif pathname == \"/page2\" : return page2_content elif pathname == \"/page3\" : return page3_content app . run_server ( mode = 'external' ) And now, running the app will only show us the first page! However, entering the proper link will take us to pages 2 and 3. How are we doing this? Well, using a simple callback... As defined below the app layout, the input is simply the pathname of the current page . The output is the page-content, an html.Div element that we've defined in our app layout. This is where the importance of element id's comes into play! For any element that will be updated via a callback, an id is needed. @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) Breaking down the function display_page() , we simply compare the pathname to several predefined, valid pages. Then, the respective content is returned. This content is stored and displayed in html.Div(id='page-content') . NOTE: We will cover callbacks in the next chapter! This is merely an intro used to navigate through pages . Yet entering any other link will lead to a blank page... uh oh! We need to make sure that the user doesn't accidentally access any unauthorized or unbuilt pages . They should only be able to access the extension links that we've provided. In order to secure this, we can use Dash Bootstrap...","title":"A Simple Multi-Page App"},{"location":"quick/04_notes/#dash-jumbotron","text":"The Dash Jumbotron is a Bootstrap component that is used to showcase important messages . In this case, we'll use it to display a \"404 error message\" whenever the user reaches an unauthorized page . Adding this jumbotron is quite simple. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def display_page ( pathname ): if pathname == \"/\" : return page1_content elif pathname == \"/page2\" : return page2_content elif pathname == \"/page3\" : return page3_content return dbc . Jumbotron ( [ html . H1 ( \"404: Not found\" , className = \"text-danger\" ), html . Hr (), html . P ( \"Uh oh! Unfortunately, the pathname {} was unable to be recognised...\" . format ( pathname )), ] ) app . run_server ( mode = 'external' ) And just like that, we've put together a simple multi-page app! In order to modify each page, we can simply change the html.Div() element to contain our page's components. To add pages, we can extend our if/else. Yet as of now, users can only navigate by entering each page's link. Comprehensive Multi-Page App","title":"Dash Jumbotron"},{"location":"quick/04_notes/#comprehensive-multi-page-app","text":"Let's use our Healthcare Dashboard and partition it into two pages . General Page - Contains our title , listgroups , pie , and scatter plot Prescriber Page - contains our table , bar chart , and network graph","title":"Comprehensive Multi-Page App"},{"location":"quick/04_notes/#global-styles-and-variables","text":"In order to create a better multi-page app, we must first determine what content is shared across our multiple pages . We can declare these as global variables and have them unchanged upon navigating across pages. This way, our dashboard is more responsive as there is less to recompute upon each refresh . NOTE: At the moment, we don't have any shared content . However, this will change in future chapters!","title":"Global Styles and Variables"},{"location":"quick/04_notes/#the-two-pages","text":"Now, we can create content variables for each of the two pages, stored below: generalPage = html . Div ([ dbc . Row ( titleCard , justify = \"center\" ), dbc . Row ( statsListGroup , justify = \"center\" ), html . Br (), dbc . Row ([ pieChartCard , scatterChartCard , ], justify = \"center\" ), ]) prescriberPage = html . Div ([ dbc . Row ([ dbc . Col ( tableCard ), dbc . Col ([ barCard , networkCard ], ) ], justify = 'center' ), ]) As seen, we just split the two pages where our original html.Hr() used to be! Now, we can add in the simple callback to load the correct page. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def display_page ( pathname ): if pathname == \"/\" : return generalPage elif pathname == \"/pre\" : return prescriberPage return dbc . Jumbotron ( [ html . H1 ( \"404: Not found\" , className = \"text-danger\" ), html . Hr (), html . P ( \"Uh oh! Unfortunately, the pathname {} was unable to be recognised...\" . format ( pathname )), ] ) app . run_server ( mode = 'external' ) And here's our dashboard, now with multiple pages!","title":"The Two Pages"},{"location":"quick/04_notes/#dash-links","text":"However, having to manually enter the url for each specific page is not a good practice . Luckily, Dash provides several methods for navigating through pages. One of the most common components used for navigation is the Dash Link , which allows users to select which page they wish to reach. Let's take a look! We simply modify our app.layout to include two dcc.Link() 's. These are essentially Dash's equivalent of hyperlinks . No additional callbacks needed, these links function perfectly by themselves! app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), dbc . Row ([ dbc . Col ( dcc . Link ( \"Go to Home\" , href = '/' ), width = 1 ), dbc . Col ( dcc . Link ( 'Go to Prescribers' , href = '/pre' ), width = 2 ), ], justify = \"start\" , ), html . Div ( id = 'page-content' ) ]) By including the dbc.Row() with our two links outside of html.Div(id='page-content') , it remains static and present in the same location on all pages . However, this may not always be needed. For example, we don't need to the \"Go to Prescribers\" hyperlink when we are already on that page. To overcome this, we turn to our layout variables . By adding one dcc.Link in each of our pages, we can remove any unnecessary overlap . generalPage = html . Center ( html . Div ([ dbc . Col ( dcc . Link ( \"Go to Prescribers\" , href = '/pre' ), width = 2 ), dbc . Row ( titleCard , justify = \"center\" ), dbc . Row ( statsListGroup , justify = \"center\" ), html . Br (), dbc . Row ([ pieChartCard , scatterChartCard , ], justify = \"center\" ), ])) prescriberPage = html . Center ( html . Div ([ dbc . Col ( dcc . Link ( \"Go to Home\" , href = '/' ), width = 1 ), prescriberTitleCard , dbc . Row ([ dbc . Col ( tableCard ), dbc . Col ([ barCard , networkCard ], ) ], justify = 'center' ), ])) Once again, no callbacks needed! This functions perfectly using the app.layout from before. NOTE: All code segments from this chapter can be found in this Colab Notebook .","title":"Dash Links"},{"location":"quick/04_notes/#ch-08-callbacks","text":"A Simple Callback","title":"Ch 08 - Callbacks"},{"location":"quick/04_notes/#a-simple-callback","text":"Callbacks are functions that are called automatically by Dash everytime a component's property changes . They allow for dynamic pages. We had taken a look at a simple callback in the last chapter, but let's flesh it out further . For reference, here's the code segment from before. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def display_page ( pathname ): if pathname == \"/\" : return generalPage elif pathname == \"/pre\" : return prescriberPage return dbc . Jumbotron ( [ html . H1 ( \"404: Not found\" , className = \"text-danger\" ), html . Hr (), html . P ( \"Uh oh! Unfortunately, the pathname {} was unable to be recognised...\" . format ( pathname )), ] ) app . run_server ( mode = 'external' ) As seen, our callback is introduced with the @ symbol It can take a list of Output elements as well as a list of Input elements In our example, it takes in the input with the ID 'url' . This component is dcc.Location(id=url, refresh=False) , which is a Dash element that simply keeps track of the url of the current page . In our example, the output element is html.Div(id='page-content') , which is just an empty placeholder . It's contents are currently empty, but replaced by the callback upon each url change That wasn't too bad to explain! As seen above, callbacks consist of: Header - specified by @app.callback() , followed immediately by a... Function - can be titled anything , takes in the callback input as a parameter . Let's take a look at a more complicated input!","title":"A Simple Callback"},{"location":"quick/04_notes/#introducing-dbcbutton","text":"Instead of just the url, what if we wanted to add more aesthetic functionality directly onto our dash page. One way to do this is with dbc.Button() element, which allows for cleaner clickability . This bootstrap component is quite easy to set up. generalPage = html . Center ( html . Div ([ dbc . Col ( dbc . Button ( \"Switch Pages\" , id = \"switch-button\" , className = \"mr-2\" , n_clicks = 0 , color = \"info\" , href = \"/pre\" ), width = 2 ), dbc . Row ( titleCard , justify = \"center\" ), dbc . Row ( statsListGroup , justify = \"center\" ), html . Br (), dbc . Row ([ pieChartCard , scatterChartCard , ], justify = \"center\" ), ])) prescriberPage = html . Center ( html . Div ([ dbc . Col ( dbc . Button ( \"Switch Pages\" , id = \"switch-button\" , className = \"mr-2\" , n_clicks = 0 , color = \"info\" , href = \"/\" ), width = 2 ), prescriberTitleCard , dbc . Row ([ dbc . Col ( tableCard ), dbc . Col ([ barCard , networkCard ], ) ], justify = 'center' ), ])) And that's it. No callbacks needed, at least for now . However, the button does have several other functionalities beyond serving as a glorified hyperlink. It can keep track of the number of clicks , serve as a method to download files , and be customized to change on click . NOTE: For more information on Buttons, feel free to check out the following resources: dbc.Button()","title":"Introducing dbc.Button()"},{"location":"quick/04_notes/#introducing-dccinput","text":"For more intricate input, we turn to dcc.Input() . This Dash Core Component supports several types of text entry , including: \"text\" - regular text, any character goes! \"number\" - numbers and hyphens (for negative) signs only \"password\" - each entered character will be shown as a black dot \"email\" - will ensure that entered text is a valid email format \"tel\" - will ensure that entered text is a valid telephone format This element is quite powerful, and can easily be incorporated as shown in this example: app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ([ dcc . Input ( id = \"example-input\" , type = \"number\" , placeholder = \"Please enter a number.\" ), html . H1 ( \"Your number squared is:\" ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'example-input' , 'value' )]) def display_page ( value ): if value is None : return html . H3 ( \"N/A\" ) return html . H3 ( value * value ) app . run_server ( mode = 'external' ) Taking a closer look, we see that the id of the dcc.Input() is used in our callback. It's value attribute is passed in as the sole parameter of our callback function . Additionally, the input type has been specified to be a number. Additionally, it's good practice to ensure that regardless of the input, the callback returns some acceptable value ! Even if it's an empty html.Div() element, it's good practice to make sure that there are no edge cases. NOTE: Fore more information on input, feel free to check out the following resources: dcc.Input Comprehensive Callback Currently, the Prescribers page is static, fixed with the value \"pre-78\" . Let's change this so that users may able to search for any valid prescriber within the Graph . First, we need a list of all valid options...","title":"Introducing dcc.Input()"},{"location":"quick/04_notes/#acceptible-prescribers-query","text":"Using our knowledge from the TigerGraph Tundra , we can write a query that returns all Prescriber IDs. AllPrescribers = '''USE GRAPH MyGraph CREATE QUERY AllPrescribers() FOR GRAPH MyGraph { ListAccum<Vertex<Prescriber>> @@allPrescribers; start = {Prescriber.*}; allPres = SELECT p FROM start:p ACCUM @@allPrescribers += p; PRINT @@allPrescribers as allPrescribers; } INSTALL QUERY AllPrescribers''' print ( conn . gsql ( AllPrescribers , options = [])) Running this query gives us the following output, Now, we can package it into the appropriate format as follows. def getPresList (): pres = conn . runInstalledQuery ( \"AllPrescribers\" )[ 0 ][ 'allPrescribers' ] return [{ 'label' : x , 'value' : x } for x in pres ] Awesome! The question remains, how do we incorporate this list into our search? Although dcc.Input() can support this sort of wordbank in searches, for a simpler implementation we will utilize its close relative, dcc.Dropdown() . Let's take a closer look...","title":"Acceptible Prescribers (Query)"},{"location":"quick/04_notes/#using-dccdropdown","text":"Dash's Dropdown allows users to select values from a given list of possible options . This component is very powerful, allowing for multi-value selection , the ability to disable certain options , the ability to clear certain options , and the real-time updating of options based on the user's search terms. For this example, we will be using a basic implementation. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) presList = getPresList () app . layout = html . Div ([ dbc . Col ( dcc . Dropdown ( id = \"example-input\" , placeholder = \"Enter a prescriber...\" , options = presList ), width = 3 ), html . H1 ( \"Your chosen prescriber:\" ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'example-input' , 'value' )]) def display_page ( value ): if value is None : return html . H3 ( \"N/A\" ) return html . H3 ( value + \" is valid!\" ) app . run_server ( mode = 'external' ) Breaking it down, we specify the id , placeholder text , and list of options for our Dropdown element. Then, within our callback, we simply display the chosen value as well as some accompanying text. Here's the result. See, that wasn't so bad! Simple, yet quite powerful. NOTE: For more information on Dropdown, feel free to check out the following resources: dcc.Dropdown()","title":"Using dcc.Dropdown()"},{"location":"quick/04_notes/#putting-it-together","text":"Let's incorporate this search into our Prescribers Page. dropdown = dbc . Col ( dcc . Dropdown ( id = \"pres-dropdown\" , placeholder = \"Enter a prescriber...\" , options = getPresList () ), width = 3 ) def prescriberPage ( pres ): prescriberTitleCard , tableCard , barCard , networkCard = getPrescriberInfo ( pres ) page = html . Center ( html . Div ([ dbc . Row ([ dropdown , dbc . Col ( dbc . Button ( \"Switch Pages\" , id = \"switch-button\" , className = \"mr-2\" , n_clicks = 0 , color = \"info\" , href = \"/\" ), width = 2 ), ], justify = 'center' ), prescriberTitleCard , dbc . Row ([ dbc . Col ( tableCard ), dbc . Col ([ barCard , networkCard ], ) ], justify = 'center' ), ])) return page First, we create our dropdown component. Next, we create a parameterized function that returns the prescriber page for a given prescriber . Within this function, we incorporate the dropdown component (in the first dbc.Row() ). Now, we need to create our app and its callbacks. app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ], suppress_callback_exceptions = True ) presPage = html . Div ( prescriberPage ( \"pre78\" ), id = 'pres-content' ) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), html . Div ( id = 'page-content' ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def display_page ( pathname ): if pathname == \"/\" : return generalPage elif pathname == \"/pre\" : return presPage return dbc . Jumbotron ( [ html . H1 ( \"404: Not found\" , className = \"text-danger\" ), html . Hr (), html . P ( \"Uh oh! Unfortunately, the pathname {} was unable to be recognised...\" . format ( pathname )), ] ) @app . callback ( dash . dependencies . Output ( 'pres-content' , 'children' ), [ dash . dependencies . Input ( 'pres-dropdown' , 'value' )]) def update_pres ( value ): if value is not None : return prescriberPage ( value ) return prescriberPage ( \"pre78\" ) # Our default value app . run_server ( mode = 'external' ) Several changes from before, so let's take a closer look! First, we create a new variable to hold the contents of our prescriber page. Named presPage , this element contains a unique id and is set to store the default prescriber page value using Prescriber #78 . Next, we leave our app.layout() and first callback untouched. These allow for navigation. In order to utilize the value of the dropdown, we write a new callback . This time, it's input is the pres-dropdown component. This callback function simply returns the Prescriber Page with the given prescriber . Note that we've had to add suppress_callback_exceptions=True in order to prevent warning pop-ups. This is because when we are on the general page, the dropdown element has not been loaded yet. Although this is not an issue, Dash registers this as a warning! NOTE: Dashboards can have as many callbacks as desired. Although each callback can take unlimited inputs, each output can only be utilized once in a callback . For example, one cannot have two callbacks that both output page-content . This will return an error when loading the Dash app. This is why dash.dependencies.Output() is simply one element, while dash.dependencies.Input() is within a list. And with that, we have the first verison of our dynamic dashboard! NOTE: All code segments from this chapter can be found in this Colab Notebook .","title":"Putting it Together"},{"location":"quick/05_notes/","text":"Navbars, Sidebars \u00b6 Ch 09 - Navbars \u00b6 Creating Navbar Layout In the last two chapters, we learned how to navigate across the multiple pages of our dashboard. However, our current system is a little bit clunky. One possible way to fix this is by utilizing a nabvar... Creating Navbar Layout \u00b6 Adding a navbar to our dashboard allows for easier navigation, providing a fixed, non-changing area of our app which can be used to access other pages. In the previous chapter, we implemented a dropdown to navigate across pages. A navbar is as simple as wrapping this dropdown element into a dbc.Navbar() component ! Let's start with a simple example using dbc.Navbarsimple() : navbar = dbc . NavbarSimple ([ dbc . NavItem ( dbc . NavLink ( \"General\" , href = \"/\" )), dbc . DropdownMenu ( children = [ dbc . DropdownMenuItem ( \"More pages\" , header = True ), dbc . DropdownMenuItem ( \"Prescribers\" , href = \"/pre\" ), dbc . DropdownMenuItem ( \"TigerGraph Cloud\" , href = \"https://tgcloud.io/\" ), ], nav = True , in_navbar = True , label = \"More\" , ), ], brand = \"Example Navbar\" , brand_href = \"/\" , color = \"info\" , dark = True , ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ], suppress_callback_exceptions = True ) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), navbar , html . Center ( html . H1 ( \"Wow, look at this amazing navbar!\" )) ]) app . run_server ( mode = 'external' ) Let's break it down! First, we add a dbc.NavItem() which contains a link to the homepage . As a result, the href tag is simply a / . After this, we add our dbc.DropdownMenu() , very similar to dbc.Dropdown() from earlier. This dropdown contains a header, titled \"More Pages\" . Next, it contains a link to our Prescribers page as well as a link to the TigerGraph Cloud Portal . These links are added via dbc.DropdownMenuItem() . With the brand attribute, we can title our navbar and change its home link. Finally, we can modify the colors and styling of the navbar. Although we haven't included the pages themselves in this example, clicking the menu items will update the url. Let's try another example using navbars! Adding Navbar Elements Adding Navbar Elements \u00b6 Let's add our dropdown to our navbar, and our navbar to our Prescriber Page. dropdown = dbc . Row ( dbc . Col ( dcc . Dropdown ( id = \"pres-dropdown\" , placeholder = \"Enter a prescriber...\" , options = getPresList (), style = { 'width' : '400px' } ), width = 12 , align = \"end\" ), style = { \"margin-left\" : \"600px\" }) navbar = dbc . Navbar ( [ html . A ( # Use row and col to control vertical alignment of logo / brand dbc . Row ( [ dbc . Col ( dbc . NavbarBrand ( \"Healthcare Dashboard - TigerGraph's Dash Class Example\" , className = \"ml-2\" )), ], align = \"center\" , no_gutters = True , ), href = \"/\" , ), dropdown , ], color = \"dark\" , dark = True , ) def prescriberPage ( pres ): prescriberTitleCard , tableCard , barCard , networkCard = getPrescriberInfo ( pres ) page = html . Center ( html . Div ([ navbar , prescriberTitleCard , dbc . Row ([ dbc . Col ( tableCard ), dbc . Col ([ barCard , networkCard ], ) ], justify = 'center' ), ])) return page As seen, the navbar simply contains a hyperlinked header (that takes one back the main page) and a dropdown to enter prescriber information . No additional changes need to be made to the callback function. Here's the result! That helps make the Prescriber Page look a lot better! There's a few other options for Navbars as well, although we won't implement them for now: NavbarSimple - according to Dash, \"simpler, but less flexible\" Navbar - more customizability , but more intricate to set up NavbarBrand - contains a brand name (meant essentially for text) NavbarToggler - essentially a button (tracks clicks, times) NOTE: For more information on navbars, feel free to check out the following resources: dbc.Navbar() NOTE: All code segments from this chapter can be found in this Colab Notebook . Ch 10 - Sidebars \u00b6 Creating Sidebar Layout Creating Sidebar Layout \u00b6 Just like navbars, sidebars allow for easier navigation across dashboards , especially ones with multiple pages. While the navbar sits on top of the app and is horizontal, the sidebar can usually be found vertically on the left-side . First, we must specify the styling of the sidebar, namely width, padding, and background color . SIDEBAR_STYLE = { \"position\" : \"fixed\" , \"top\" : 0 , \"left\" : 0 , \"bottom\" : 0 , \"width\" : \"16rem\" , \"padding\" : \"2rem 1rem\" , \"background-color\" : \"#f8f9fa\" , } Using this style dictionary , we can create our sidebar layout. sidebar = html . Div ( [ html . H2 ( \"Sidebar\" , className = \"display-4\" ), html . Hr (), html . P ( \"This is an example for TigerGraph's Dash Class\" , className = \"lead\" ), dbc . Nav ( [ dbc . NavLink ( \"Home\" , href = \"/\" , active = \"exact\" ), dbc . NavLink ( \"Prescribers\" , href = \"/pre\" , active = \"exact\" ), dbc . NavLink ( \"TG Cloud \ud83d\udc2f\" , href = \"https://tgcloud.io\" , active = \"exact\" ), ], vertical = True , pills = True , ), ], style = SIDEBAR_STYLE , ) Breaking it down, we have: A header with our sidebar title ( html.H2() ) A paragraph with a short description ( html.P() ) Three nav links : one to home, one to prescribers, and one to TG Cloud Now, we need to incorporate this sidebar into an example app. CONTENT_STYLE = { \"margin-left\" : \"18rem\" , \"margin-right\" : \"2rem\" , \"padding\" : \"2rem 1rem\" , } content = html . Div ( id = \"page-content\" , style = CONTENT_STYLE ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ], suppress_callback_exceptions = True ) app . layout = html . Div ([ dcc . Location ( id = \"url\" ), sidebar , content ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def render_page_content ( pathname ): if pathname == \"/\" : return html . P ( \"Congrats! You've found the home page!\" ) elif pathname == \"/pre\" : return html . P ( \"Woah, you've discovered the Prescribers Page!\" ) return dbc . Jumbotron ( [ html . H1 ( \"404: Not found\" , className = \"text-danger\" ), html . Hr (), html . P ( \"Uh oh! Unfortunately, the pathname {} was unable to be recognised...\" . format ( pathname )), ] ) app . run_server ( mode = 'external' ) First and foremost, we must create a new CONTENT_STYLE dictionary. Note that the margin-left is 18rem, accounting for both the sidebar's width and its padding (16rem and 2rem respectively). Additionally, having a margin-right of 2rem allows for a flush appearance on both sides. We must set the style of our content html.Div() element to match this! Next, within our app.layout() , we must include both the sidebar and content . The rest of the app remains the same, with the callback to navigate across both pages not requiring any changes. And here's the simple sidebar app, Let's customize this for our Healthcare Starter Kit Dashboard! Adding Sidebar Elements Adding Sidebar Elements \u00b6 Let's add some more elements to our dashboard's sidebar. First, we declare our global variables . SIDEBAR_STYLE = { \"position\" : \"fixed\" , \"top\" : 0 , \"left\" : 0 , \"bottom\" : 0 , \"width\" : \"16rem\" , \"padding\" : \"2rem 1rem\" , \"background-color\" : \"#424242\" , } WHITE = \"#fffff8\" TG_LOGO = \"https://i.ibb.co/gMMXcQB/Untitled-design-9.png\" PLOTLY_LOGO = \"https://dash.plotly.com/docs../assets/images/light_plotly_dash_logo.png\" In addition to the style, we need to store shared colors as well as images we will be referencing as global variables for our dashboard. This allows for easier readability and easier modification of shared content. Next, we can define the sidebar layout. sidebar = html . Div ( [ html . Center ( html . P ( \"A Plotly dashboard for TigerGraph's Healthcare Referrals Starter kit\" , className = \"lead\" , style = { 'color' : \"#ffcf9e\" } )), html . Hr ( style = { 'borderColor' : WHITE }), html . Center ( html . P ( \"Use the following to navigate this dashboard\" , className = \"lead\" , style = { 'color' : WHITE } )), dbc . Nav ( [ dbc . NavLink ( \"Home\" , href = \"/\" , active = \"exact\" , style = { 'color' : WHITE }), dbc . NavLink ( \"Prescribers\" , href = \"/pre\" , active = \"exact\" , style = { 'color' : WHITE }), dbc . NavLink ( \"TG Cloud \ud83d\udc2f\" , href = \"https://tgcloud.io\" , active = \"exact\" , style = { 'color' : WHITE }), ], vertical = True , pills = True , ), html . Hr ( style = { 'borderColor' : WHITE }), html . Center ( html . P ( \"To learn more, feel free to check out the following:\" , className = \"lead\" , style = { 'color' : WHITE } )), html . Li ( html . A ( \"Inroduction to Graphs\" , href = 'https://www.tigergraph.com/blog/what-is-a-graph-database-and-why-should-you-care/' , target = \"_blank\" , style = { 'color' : WHITE }), style = { 'color' : WHITE }), html . Li ( html . A ( \"Introduction to Dash\" , href = 'https://www.youtube.com/watch?v=e4ti2fCpXMI' , target = \"_blank\" , style = { 'color' : WHITE }), style = { 'color' : WHITE }), html . Br (), html . Hr ( style = { 'borderColor' : WHITE }), html . Br (), html . Center ( dbc . Row ( dbc . Col ( html . Img ( src = TG_LOGO , width = \"175px\" , style = { \"margin-bottom\" : \"15px\" , \"margin-top\" : \"50px\" })))), html . Br (), html . Center ( dbc . Row ( dbc . Col ( html . Img ( src = PLOTLY_LOGO , width = \"225px\" , style = { \"margin-bottom\" : \"15px\" })))), ], style = SIDEBAR_STYLE , ) Let's dissect this new sidebar, First, we have our centered title , in a different color than before. This is because the background color of our sidebar is now a darker shade of grey, meaning all text should be lighter colors . Next, we have a standard horizontal rule , however colored white instead of the usual grey. Following this is another short description , in the color white to allow for easier readability. This next section hasn't changed, it simply contains our dbc.Nav() After another white horizontal rule, we have a shot description for further resources Using the html.Li() component, we can include hyperlinks to external webpages . Although this can be achieved using dcc.Link() (as we covered in a previous chapter), it never hurts to learn multiple ways for accomplishing a given task! Both provide similar functionality. Finally, we have two centered images . Our TigerGraph and Plotly Dash logos. With html.Img() , we can specify width, height, and margins . These are stored in dbc.Row() and dbc.Col() to provide consistent borders. Now, it's time to incorporate this sidebar into our app. First, we need to reformat our figures and page layouts to account for the change in width. Reformatted Pie, Scatter pieChart = getClaimsPieChart () scatterChart = getScatterChart () pieChartCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"All Submitted Claims\" , className = 'card-title' ), html . P ( \"Which categories of claims are most frequent? \\n Which areas should prescribers focus on?\" , className = 'card-body' ), dcc . Graph ( id = 'Pie Chart' , figure = pieChart ) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"49rem\" , \"margin-right\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) scatterChartCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Prescriber Communities\" , className = 'card-title' ), html . P ( \"Do communities lead to more business? How do the number of referrals compare to community size?\" , className = 'card-body' ), dcc . Graph ( id = 'Scatter Chart' , figure = scatterChart ) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"50rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) Reformatted getPrescriberInfo() def getPrescriberInfo ( person_num ): network = getNetwork ( person_num ) number , table , bar , max_title = getClaims ( person_num ) prescriberTitleCard = dbc . Card ([ dbc . CardBody ([ html . Center ( dbc . Badge ([ html . H1 ( \" Prescriber \" + person_num + \"'s Claims \" , className = 'card-title' )], color = \"light\" )), html . Center ( html . P ( \"This individual has a total of \" + repr ( number ) + \" claims. Their most referred to specialization is: \" + max_title , className = 'card-body' )), ]) ], outline = True , color = 'info' , style = { \"width\" : \"95rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" , \"margin-right\" : \"1rem\" } ) tableCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Claims by Prescriber\" , className = 'card-title' ), html . P ( \"A detailed description of each claim...\" , className = 'card-body' ), table ]) ], outline = True , color = 'info' , style = { \"width\" : \"48rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) barCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Claims by Category\" , className = 'card-title' ), html . P ( \"Which claims are being prescribed most?\" , className = 'card-body' ), dcc . Graph ( id = 'Bar Chart' , figure = bar ) ]) ], outline = True , color = 'info' , style = { \"width\" : \"48rem\" , \"margin-left\" : \"0rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) networkCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Prescriber Network\" , className = 'card-title' ), html . P ( \"Who's part of this prescriber's community?\" , className = 'card-body' ), network ]) ], outline = True , color = 'info' , style = { \"width\" : \"48rem\" , \"margin-left\" : \"0rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) return prescriberTitleCard , tableCard , barCard , networkCard Reformatted Pages generalPage = html . Center ( html . Div ([ dbc . Col ( dbc . Button ( \"Switch Pages\" , id = \"switch-button\" , className = \"mr-2\" , n_clicks = 0 , color = \"info\" , href = \"/pre\" ), width = 2 ), dbc . Row ( titleCard , justify = \"center\" ), dbc . Row ( statsListGroup , justify = \"center\" ), html . Br (), dbc . Row ([ pieChartCard , scatterChartCard , ], justify = \"center\" ), ], style = { \"width\" : \"100rem\" })) dropdown = dbc . Row ( dbc . Col ( dcc . Dropdown ( id = \"pres-dropdown\" , placeholder = \"Enter a prescriber...\" , options = getPresList (), style = { 'width' : '400px' } ), width = 12 , align = \"end\" ), style = { \"margin-left\" : \"35rem\" }) navbar = dbc . Navbar ( [ html . A ( # Use row and col to control vertical alignment of logo / brand dbc . Row ( [ dbc . Col ( dbc . NavbarBrand ( \"Healthcare Dashboard - TigerGraph's Dash Class Example\" , className = \"ml-2\" )), ], align = \"center\" , no_gutters = True , ), href = \"/\" , ), dropdown , ], color = \"dark\" , dark = True , ) def prescriberPage ( pres ): prescriberTitleCard , tableCard , barCard , networkCard = getPrescriberInfo ( pres ) page = html . Center ( html . Div ([ navbar , prescriberTitleCard , dbc . Row ([ dbc . Col ( tableCard ), dbc . Col ([ barCard , networkCard ], ) ], justify = 'center' ), ], style = { \"width\" : \"100rem\" })) return page Now, we can incorporate our sidebar into the app.layout . It's important to note that only page-content contains CONTENT_STYLE . Our pres-content page doesn't require this styling as it is not part of our app.layout directly. Instead, it is returned to substitute page-content . CONTENT_STYLE = { \"margin-left\" : \"18rem\" , \"margin-right\" : \"2rem\" , \"padding\" : \"2rem 1rem\" , } app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ], suppress_callback_exceptions = True ) presPage = html . Div ( prescriberPage ( \"pre78\" ), id = 'pres-content' ) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), sidebar , html . Div ( id = 'page-content' , style = CONTENT_STYLE ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def display_page ( pathname ): if pathname == \"/\" : return generalPage elif pathname == \"/pre\" : return presPage return dbc . Jumbotron ( [ html . H1 ( \"404: Not found\" , className = \"text-danger\" ), html . Hr (), html . P ( \"Uh oh! Unfortunately, the pathname {} was unable to be recognised...\" . format ( pathname )), ] ) @app . callback ( dash . dependencies . Output ( 'pres-content' , 'children' ), [ dash . dependencies . Input ( 'pres-dropdown' , 'value' )]) def update_pres ( value ): if value is not None : return prescriberPage ( value ) return prescriberPage ( \"pre78\" ) # Our default value app . run_server ( mode = 'external' ) And here's our output, both pages complete with the sidebar! Awesome! And that's how to incorporate a sidebar into one's dashboard :) NOTE: For more information on sidebars, feel free to check out the following resources: Dash Sidebar Video NOTE: All code segments from this chapter can be found in this Colab Notebook .","title":"Navigation - Navbars, Sidebars"},{"location":"quick/05_notes/#navbars-sidebars","text":"","title":"Navbars, Sidebars"},{"location":"quick/05_notes/#ch-09-navbars","text":"Creating Navbar Layout In the last two chapters, we learned how to navigate across the multiple pages of our dashboard. However, our current system is a little bit clunky. One possible way to fix this is by utilizing a nabvar...","title":"Ch 09 - Navbars"},{"location":"quick/05_notes/#creating-navbar-layout","text":"Adding a navbar to our dashboard allows for easier navigation, providing a fixed, non-changing area of our app which can be used to access other pages. In the previous chapter, we implemented a dropdown to navigate across pages. A navbar is as simple as wrapping this dropdown element into a dbc.Navbar() component ! Let's start with a simple example using dbc.Navbarsimple() : navbar = dbc . NavbarSimple ([ dbc . NavItem ( dbc . NavLink ( \"General\" , href = \"/\" )), dbc . DropdownMenu ( children = [ dbc . DropdownMenuItem ( \"More pages\" , header = True ), dbc . DropdownMenuItem ( \"Prescribers\" , href = \"/pre\" ), dbc . DropdownMenuItem ( \"TigerGraph Cloud\" , href = \"https://tgcloud.io/\" ), ], nav = True , in_navbar = True , label = \"More\" , ), ], brand = \"Example Navbar\" , brand_href = \"/\" , color = \"info\" , dark = True , ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ], suppress_callback_exceptions = True ) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), navbar , html . Center ( html . H1 ( \"Wow, look at this amazing navbar!\" )) ]) app . run_server ( mode = 'external' ) Let's break it down! First, we add a dbc.NavItem() which contains a link to the homepage . As a result, the href tag is simply a / . After this, we add our dbc.DropdownMenu() , very similar to dbc.Dropdown() from earlier. This dropdown contains a header, titled \"More Pages\" . Next, it contains a link to our Prescribers page as well as a link to the TigerGraph Cloud Portal . These links are added via dbc.DropdownMenuItem() . With the brand attribute, we can title our navbar and change its home link. Finally, we can modify the colors and styling of the navbar. Although we haven't included the pages themselves in this example, clicking the menu items will update the url. Let's try another example using navbars! Adding Navbar Elements","title":"Creating Navbar Layout"},{"location":"quick/05_notes/#adding-navbar-elements","text":"Let's add our dropdown to our navbar, and our navbar to our Prescriber Page. dropdown = dbc . Row ( dbc . Col ( dcc . Dropdown ( id = \"pres-dropdown\" , placeholder = \"Enter a prescriber...\" , options = getPresList (), style = { 'width' : '400px' } ), width = 12 , align = \"end\" ), style = { \"margin-left\" : \"600px\" }) navbar = dbc . Navbar ( [ html . A ( # Use row and col to control vertical alignment of logo / brand dbc . Row ( [ dbc . Col ( dbc . NavbarBrand ( \"Healthcare Dashboard - TigerGraph's Dash Class Example\" , className = \"ml-2\" )), ], align = \"center\" , no_gutters = True , ), href = \"/\" , ), dropdown , ], color = \"dark\" , dark = True , ) def prescriberPage ( pres ): prescriberTitleCard , tableCard , barCard , networkCard = getPrescriberInfo ( pres ) page = html . Center ( html . Div ([ navbar , prescriberTitleCard , dbc . Row ([ dbc . Col ( tableCard ), dbc . Col ([ barCard , networkCard ], ) ], justify = 'center' ), ])) return page As seen, the navbar simply contains a hyperlinked header (that takes one back the main page) and a dropdown to enter prescriber information . No additional changes need to be made to the callback function. Here's the result! That helps make the Prescriber Page look a lot better! There's a few other options for Navbars as well, although we won't implement them for now: NavbarSimple - according to Dash, \"simpler, but less flexible\" Navbar - more customizability , but more intricate to set up NavbarBrand - contains a brand name (meant essentially for text) NavbarToggler - essentially a button (tracks clicks, times) NOTE: For more information on navbars, feel free to check out the following resources: dbc.Navbar() NOTE: All code segments from this chapter can be found in this Colab Notebook .","title":"Adding Navbar Elements"},{"location":"quick/05_notes/#ch-10-sidebars","text":"Creating Sidebar Layout","title":"Ch 10 - Sidebars"},{"location":"quick/05_notes/#creating-sidebar-layout","text":"Just like navbars, sidebars allow for easier navigation across dashboards , especially ones with multiple pages. While the navbar sits on top of the app and is horizontal, the sidebar can usually be found vertically on the left-side . First, we must specify the styling of the sidebar, namely width, padding, and background color . SIDEBAR_STYLE = { \"position\" : \"fixed\" , \"top\" : 0 , \"left\" : 0 , \"bottom\" : 0 , \"width\" : \"16rem\" , \"padding\" : \"2rem 1rem\" , \"background-color\" : \"#f8f9fa\" , } Using this style dictionary , we can create our sidebar layout. sidebar = html . Div ( [ html . H2 ( \"Sidebar\" , className = \"display-4\" ), html . Hr (), html . P ( \"This is an example for TigerGraph's Dash Class\" , className = \"lead\" ), dbc . Nav ( [ dbc . NavLink ( \"Home\" , href = \"/\" , active = \"exact\" ), dbc . NavLink ( \"Prescribers\" , href = \"/pre\" , active = \"exact\" ), dbc . NavLink ( \"TG Cloud \ud83d\udc2f\" , href = \"https://tgcloud.io\" , active = \"exact\" ), ], vertical = True , pills = True , ), ], style = SIDEBAR_STYLE , ) Breaking it down, we have: A header with our sidebar title ( html.H2() ) A paragraph with a short description ( html.P() ) Three nav links : one to home, one to prescribers, and one to TG Cloud Now, we need to incorporate this sidebar into an example app. CONTENT_STYLE = { \"margin-left\" : \"18rem\" , \"margin-right\" : \"2rem\" , \"padding\" : \"2rem 1rem\" , } content = html . Div ( id = \"page-content\" , style = CONTENT_STYLE ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ], suppress_callback_exceptions = True ) app . layout = html . Div ([ dcc . Location ( id = \"url\" ), sidebar , content ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def render_page_content ( pathname ): if pathname == \"/\" : return html . P ( \"Congrats! You've found the home page!\" ) elif pathname == \"/pre\" : return html . P ( \"Woah, you've discovered the Prescribers Page!\" ) return dbc . Jumbotron ( [ html . H1 ( \"404: Not found\" , className = \"text-danger\" ), html . Hr (), html . P ( \"Uh oh! Unfortunately, the pathname {} was unable to be recognised...\" . format ( pathname )), ] ) app . run_server ( mode = 'external' ) First and foremost, we must create a new CONTENT_STYLE dictionary. Note that the margin-left is 18rem, accounting for both the sidebar's width and its padding (16rem and 2rem respectively). Additionally, having a margin-right of 2rem allows for a flush appearance on both sides. We must set the style of our content html.Div() element to match this! Next, within our app.layout() , we must include both the sidebar and content . The rest of the app remains the same, with the callback to navigate across both pages not requiring any changes. And here's the simple sidebar app, Let's customize this for our Healthcare Starter Kit Dashboard! Adding Sidebar Elements","title":"Creating Sidebar Layout"},{"location":"quick/05_notes/#adding-sidebar-elements","text":"Let's add some more elements to our dashboard's sidebar. First, we declare our global variables . SIDEBAR_STYLE = { \"position\" : \"fixed\" , \"top\" : 0 , \"left\" : 0 , \"bottom\" : 0 , \"width\" : \"16rem\" , \"padding\" : \"2rem 1rem\" , \"background-color\" : \"#424242\" , } WHITE = \"#fffff8\" TG_LOGO = \"https://i.ibb.co/gMMXcQB/Untitled-design-9.png\" PLOTLY_LOGO = \"https://dash.plotly.com/docs../assets/images/light_plotly_dash_logo.png\" In addition to the style, we need to store shared colors as well as images we will be referencing as global variables for our dashboard. This allows for easier readability and easier modification of shared content. Next, we can define the sidebar layout. sidebar = html . Div ( [ html . Center ( html . P ( \"A Plotly dashboard for TigerGraph's Healthcare Referrals Starter kit\" , className = \"lead\" , style = { 'color' : \"#ffcf9e\" } )), html . Hr ( style = { 'borderColor' : WHITE }), html . Center ( html . P ( \"Use the following to navigate this dashboard\" , className = \"lead\" , style = { 'color' : WHITE } )), dbc . Nav ( [ dbc . NavLink ( \"Home\" , href = \"/\" , active = \"exact\" , style = { 'color' : WHITE }), dbc . NavLink ( \"Prescribers\" , href = \"/pre\" , active = \"exact\" , style = { 'color' : WHITE }), dbc . NavLink ( \"TG Cloud \ud83d\udc2f\" , href = \"https://tgcloud.io\" , active = \"exact\" , style = { 'color' : WHITE }), ], vertical = True , pills = True , ), html . Hr ( style = { 'borderColor' : WHITE }), html . Center ( html . P ( \"To learn more, feel free to check out the following:\" , className = \"lead\" , style = { 'color' : WHITE } )), html . Li ( html . A ( \"Inroduction to Graphs\" , href = 'https://www.tigergraph.com/blog/what-is-a-graph-database-and-why-should-you-care/' , target = \"_blank\" , style = { 'color' : WHITE }), style = { 'color' : WHITE }), html . Li ( html . A ( \"Introduction to Dash\" , href = 'https://www.youtube.com/watch?v=e4ti2fCpXMI' , target = \"_blank\" , style = { 'color' : WHITE }), style = { 'color' : WHITE }), html . Br (), html . Hr ( style = { 'borderColor' : WHITE }), html . Br (), html . Center ( dbc . Row ( dbc . Col ( html . Img ( src = TG_LOGO , width = \"175px\" , style = { \"margin-bottom\" : \"15px\" , \"margin-top\" : \"50px\" })))), html . Br (), html . Center ( dbc . Row ( dbc . Col ( html . Img ( src = PLOTLY_LOGO , width = \"225px\" , style = { \"margin-bottom\" : \"15px\" })))), ], style = SIDEBAR_STYLE , ) Let's dissect this new sidebar, First, we have our centered title , in a different color than before. This is because the background color of our sidebar is now a darker shade of grey, meaning all text should be lighter colors . Next, we have a standard horizontal rule , however colored white instead of the usual grey. Following this is another short description , in the color white to allow for easier readability. This next section hasn't changed, it simply contains our dbc.Nav() After another white horizontal rule, we have a shot description for further resources Using the html.Li() component, we can include hyperlinks to external webpages . Although this can be achieved using dcc.Link() (as we covered in a previous chapter), it never hurts to learn multiple ways for accomplishing a given task! Both provide similar functionality. Finally, we have two centered images . Our TigerGraph and Plotly Dash logos. With html.Img() , we can specify width, height, and margins . These are stored in dbc.Row() and dbc.Col() to provide consistent borders. Now, it's time to incorporate this sidebar into our app. First, we need to reformat our figures and page layouts to account for the change in width. Reformatted Pie, Scatter pieChart = getClaimsPieChart () scatterChart = getScatterChart () pieChartCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"All Submitted Claims\" , className = 'card-title' ), html . P ( \"Which categories of claims are most frequent? \\n Which areas should prescribers focus on?\" , className = 'card-body' ), dcc . Graph ( id = 'Pie Chart' , figure = pieChart ) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"49rem\" , \"margin-right\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) scatterChartCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Prescriber Communities\" , className = 'card-title' ), html . P ( \"Do communities lead to more business? How do the number of referrals compare to community size?\" , className = 'card-body' ), dcc . Graph ( id = 'Scatter Chart' , figure = scatterChart ) ]) ], outline = True , color = 'info' , # Options include: primary, secondary, info, success, warning, danger, light, dark style = { \"width\" : \"50rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" } ) Reformatted getPrescriberInfo() def getPrescriberInfo ( person_num ): network = getNetwork ( person_num ) number , table , bar , max_title = getClaims ( person_num ) prescriberTitleCard = dbc . Card ([ dbc . CardBody ([ html . Center ( dbc . Badge ([ html . H1 ( \" Prescriber \" + person_num + \"'s Claims \" , className = 'card-title' )], color = \"light\" )), html . Center ( html . P ( \"This individual has a total of \" + repr ( number ) + \" claims. Their most referred to specialization is: \" + max_title , className = 'card-body' )), ]) ], outline = True , color = 'info' , style = { \"width\" : \"95rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" , \"margin-right\" : \"1rem\" } ) tableCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Claims by Prescriber\" , className = 'card-title' ), html . P ( \"A detailed description of each claim...\" , className = 'card-body' ), table ]) ], outline = True , color = 'info' , style = { \"width\" : \"48rem\" , \"margin-left\" : \"1rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) barCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Claims by Category\" , className = 'card-title' ), html . P ( \"Which claims are being prescribed most?\" , className = 'card-body' ), dcc . Graph ( id = 'Bar Chart' , figure = bar ) ]) ], outline = True , color = 'info' , style = { \"width\" : \"48rem\" , \"margin-left\" : \"0rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) networkCard = dbc . Card ([ dbc . CardBody ([ html . H1 ( \"Prescriber Network\" , className = 'card-title' ), html . P ( \"Who's part of this prescriber's community?\" , className = 'card-body' ), network ]) ], outline = True , color = 'info' , style = { \"width\" : \"48rem\" , \"margin-left\" : \"0rem\" , \"margin-bottom\" : \"1rem\" , \"margin-top\" : \"1rem\" } ) return prescriberTitleCard , tableCard , barCard , networkCard Reformatted Pages generalPage = html . Center ( html . Div ([ dbc . Col ( dbc . Button ( \"Switch Pages\" , id = \"switch-button\" , className = \"mr-2\" , n_clicks = 0 , color = \"info\" , href = \"/pre\" ), width = 2 ), dbc . Row ( titleCard , justify = \"center\" ), dbc . Row ( statsListGroup , justify = \"center\" ), html . Br (), dbc . Row ([ pieChartCard , scatterChartCard , ], justify = \"center\" ), ], style = { \"width\" : \"100rem\" })) dropdown = dbc . Row ( dbc . Col ( dcc . Dropdown ( id = \"pres-dropdown\" , placeholder = \"Enter a prescriber...\" , options = getPresList (), style = { 'width' : '400px' } ), width = 12 , align = \"end\" ), style = { \"margin-left\" : \"35rem\" }) navbar = dbc . Navbar ( [ html . A ( # Use row and col to control vertical alignment of logo / brand dbc . Row ( [ dbc . Col ( dbc . NavbarBrand ( \"Healthcare Dashboard - TigerGraph's Dash Class Example\" , className = \"ml-2\" )), ], align = \"center\" , no_gutters = True , ), href = \"/\" , ), dropdown , ], color = \"dark\" , dark = True , ) def prescriberPage ( pres ): prescriberTitleCard , tableCard , barCard , networkCard = getPrescriberInfo ( pres ) page = html . Center ( html . Div ([ navbar , prescriberTitleCard , dbc . Row ([ dbc . Col ( tableCard ), dbc . Col ([ barCard , networkCard ], ) ], justify = 'center' ), ], style = { \"width\" : \"100rem\" })) return page Now, we can incorporate our sidebar into the app.layout . It's important to note that only page-content contains CONTENT_STYLE . Our pres-content page doesn't require this styling as it is not part of our app.layout directly. Instead, it is returned to substitute page-content . CONTENT_STYLE = { \"margin-left\" : \"18rem\" , \"margin-right\" : \"2rem\" , \"padding\" : \"2rem 1rem\" , } app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ], suppress_callback_exceptions = True ) presPage = html . Div ( prescriberPage ( \"pre78\" ), id = 'pres-content' ) app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), sidebar , html . Div ( id = 'page-content' , style = CONTENT_STYLE ) ]) @app . callback ( dash . dependencies . Output ( 'page-content' , 'children' ), [ dash . dependencies . Input ( 'url' , 'pathname' )]) def display_page ( pathname ): if pathname == \"/\" : return generalPage elif pathname == \"/pre\" : return presPage return dbc . Jumbotron ( [ html . H1 ( \"404: Not found\" , className = \"text-danger\" ), html . Hr (), html . P ( \"Uh oh! Unfortunately, the pathname {} was unable to be recognised...\" . format ( pathname )), ] ) @app . callback ( dash . dependencies . Output ( 'pres-content' , 'children' ), [ dash . dependencies . Input ( 'pres-dropdown' , 'value' )]) def update_pres ( value ): if value is not None : return prescriberPage ( value ) return prescriberPage ( \"pre78\" ) # Our default value app . run_server ( mode = 'external' ) And here's our output, both pages complete with the sidebar! Awesome! And that's how to incorporate a sidebar into one's dashboard :) NOTE: For more information on sidebars, feel free to check out the following resources: Dash Sidebar Video NOTE: All code segments from this chapter can be found in this Colab Notebook .","title":"Adding Sidebar Elements"},{"location":"quick/06_notes/","text":"Misc. Elements, Deployment \u00b6 Ch 11 - Miscellaneous Elements \u00b6 Radar, 3D, Choropleth Plotly Paradise \u00b6 Although we've explored several core Plotly figures that are used extensively across dashboards, there are a myriad of other charts that can be made using Plotly. In this section, we'll explore a few of them. NOTE: Feel free to submit requests for other elements. This chapter may be updated to include them as well! Radar Charts \u00b6 Radar charts are used to visualize different traces across different axes . For example, if one wished to compare restaurants across five different categories , a radar chart would be a perfect visualization. Let's take a look at creating one with Plotly. categories = [ 'Food' , 'Service' , 'Affordable' , 'Location' , 'Ambience' ] res = { \"Pop's Pizzas\" : [ 3 , 3 , 5 , 4 , 3 ], \"Tony's Tacos\" : [ 5 , 2 , 4 , 1 , 2 ], \"Bill's Bread\" : [ 2 , 4 , 1 , 2 , 4 ], } fig = go . Figure () for restaurant in res : fig . add_trace ( go . Scatterpolar ( r = res [ restaurant ], theta = categories , fill = 'toself' , name = restaurant , )) fig . update_layout ( polar = dict ( radialaxis = dict ( visible = True ), ), width = 800 ) fig . show () As seen, we create a go.Figure() and add multiple traces. Each trace represents a distinct data entity, in this case different restaurants. Each restaurant has been scored across different categories, and categories are stored in theta , while each value is stored in r . In fig.update_layout() , the figure is converted into polar form to create our circular radar chart. It's a lot easier to visualize how each restaurant compares! NOTE: This format is similar to polar axes, where each point is determine in r and theta instead of x and y. NOTE: For more resources on Radar Charts, feel free to check out the following resources: Plotly Radar 3-D Figures \u00b6 In order to create 3D plots, we can use the px.scatter_3d() function. This simply requires us to enter a list value for x, y, and z. Dataframes can also be used to create a 3-D figure, formatted the same as with px.scatter() . Here's an example of a 3D parabolic curve: import numpy as np t = np . linspace ( - 10 , 10 , 50 ) x = t y = t ** 2 z = 3 * x - 2 * y fig = px . scatter_3d ( x = x , y = y , z = z ) fig . show () NOTE: np.linspace() simply creates a list from -10 to 10, with 50 data points in between, spaced evenly. NOTE: For more information on Radar Charts, feel free to check out the following resources: Scatter , 3D Charts Choropleth (Maps) \u00b6 Plotly allows for the creation and insertion of geographical maps using geojson data. Choropleth maps allow for the visulization of distinct geographical zones with different colors to indicate different attributes. In order to use the Plotly Choropleth example, we need to install the following. ! pip install - U plotly from urllib.request import urlopen import json import pandas as pd import plotly.express as px NOTE: We need to upgrade our version of Plotly to the latest to ensure that Choropleth works! Now, we can use the Plotly datasets in order to visualize the unemployment in the United States. with urlopen ( 'https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json' ) as response : counties = json . load ( response ) df = pd . read_csv ( \"https://raw.githubusercontent.com/plotly/datasets/master/fips-unemp-16.csv\" , dtype = { \"fips\" : str }) fig = px . choropleth ( df , geojson = counties , locations = 'fips' , color = 'unemp' , color_continuous_scale = \"Viridis\" , range_color = ( 0 , 12 ), scope = \"usa\" , labels = { 'unemp' : 'unemployment rate' } ) fig . update_layout ( margin = { \"r\" : 0 , \"t\" : 0 , \"l\" : 0 , \"b\" : 0 }) fig . show () As seen, it's quite a detailed, interactive map! NOTE: For more information on Maps, feel free to check out the following resources: Choropleth Progress, Spinners, Alerts Bootstrap Bliss \u00b6 As with Plotly, there are dozens of other unique Bootstrap components that can be incorporated into one's dashboard. Although we've covered the core elements, we'll explore three more in this section. NOTE: For a comprehensive list on all bootstrap components, feel free to check out: Dash Bootstrap Progress Bars \u00b6 Progress bars are horizontal, rounded rectangles that are quite flexible when it comes to displaying progress. Here's an example of a progress bar with three distinct sections. progress = dbc . Progress ( [ dbc . Progress ( value = 20 , color = \"success\" , bar = True ), dbc . Progress ( value = 30 , color = \"warning\" , bar = True ), dbc . Progress ( value = 20 , color = \"danger\" , bar = True ), ], multi = True , ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Col ( progress , width = 6 ) ]) app . run_server ( mode = 'external' ) As seen, each bar section has a different color and length ( value ). This bar can also be animated , controlled via a button that toggles the bar on and off. progress = html . Div ( [ dbc . Progress ( value = 80 , id = \"animated-progress\" , animated = False , striped = True ), dbc . Button ( \"Toggle animation\" , id = \"animation-toggle\" , className = \"mt-3\" , n_clicks = 0 , ), ] ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Col ( progress , width = 6 ) ]) @app . callback ( dash . dependencies . Output ( \"animated-progress\" , \"animated\" ), [ dash . dependencies . Input ( \"animation-toggle\" , \"n_clicks\" )], [ dash . dependencies . State ( \"animated-progress\" , \"animated\" )], ) def toggle_animation ( n , animated ): if n : return not animated return animated app . run_server ( mode = 'external' ) Ah-ah, one interesting addition is the variable dash.dependencies.State as part of our app's callback. This simply means that the state of the progress bar (whether it is currently animated or not) is also used to determine the output. This makes sense, since our toggle button inverts whatever the state of the progress bar is. NOTE: For more information on progress bars, feel free to check out the following resources: Progress Spinners \u00b6 Next up, spinners! These components are small circles that move to indicate that a process is occurring. Here are three examples (one small, one big, and one growing). spinners = html . Div ( [ dbc . Row ([ dbc . Col ( dbc . Spinner ( size = \"sm\" , color = \"info\" ), width = 1 ), dbc . Col ( dbc . Spinner ( spinner_style = { \"width\" : \"3rem\" , \"height\" : \"3rem\" }, color = \"success\" ), width = 1 ), dbc . Col ( dbc . Spinner ( color = \"danger\" , type = \"grow\" ), width = 1 ), ]) ] ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Col ( spinners , width = 6 ) ]) app . run_server ( mode = 'external' ) Each can be easily colored, resized, and toggled between traditional mode and growing mode. Spinners can also be used to indicate loading, or to be displayed upon a user action . For example, the following displays a spinner based on the number of times the button is pressed. After the time has elapsed, the spinner is replaced with the output. import time loading_spinner = html . Div ( [ dbc . Button ( \"Counter\" , id = \"loading-button\" , n_clicks = 0 ), dbc . Spinner ( html . Div ( id = \"loading-output\" )), ] ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Col ( loading_spinner , width = 3 ) ]) @app . callback ( dash . dependencies . Output ( \"loading-output\" , \"children\" ), [ dash . dependencies . Input ( \"loading-button\" , \"n_clicks\" )] ) def load_output ( n ): if n : time . sleep ( 1 ) return f \"You have clicked { n } times\" return \"No clicks as of yet ;(\" app . run_server ( mode = 'external' ) NOTE: For more information on spinners, feel free to check out the following resources: Dash Spinners Alerts \u00b6 Next up, Dash Alerts! These components are used to display important information, such as messages, information the user should know before proceeding , or any other form of alerts. Like all bootstrap, they are quite flexible. Here's an example with two alerts, one of them dismissible (able to be closed) and the other permanent . alerts = html . Div ([ dbc . Alert ( \"This is a success alert! Luckily, I won't leave!\" , color = \"success\" ), dbc . Alert ( \"This is a warning alert, but you can close me!\" , color = \"warning\" , dismissable = True ), ]) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Col ( alerts , width = 6 ) ]) app . run_server ( mode = 'external' ) These alarms can be easily customized in terms of color and content. Additionally, they can be set to automatically disappear after a certain amount of time . This is done via the keyword duration , which takes in milliseconds. Here's an example with a disappearing alert, accompanied by a button that toggles the state of the alert. alert = html . Div ( [ dbc . Button ( \"Switch States\" , id = \"alert-toggle-auto\" , className = \"mr-1\" , n_clicks = 0 ), html . Hr (), dbc . Alert ( \"I will disappear in 3 seconds...\" , id = \"alert-auto\" , color = \"danger\" , is_open = True , duration = 3000 , # In milliseconds ), ] ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Col ( alert , width = 6 ) ]) @app . callback ( dash . dependencies . Output ( \"alert-auto\" , \"is_open\" ), [ dash . dependencies . Input ( \"alert-toggle-auto\" , \"n_clicks\" )], [ dash . dependencies . State ( \"alert-auto\" , \"is_open\" )], ) def toggle_alert ( n , is_open ): if n : return not is_open return is_open app . run_server ( mode = 'external' ) Quite handy, especially to help users navigate a dashboard for the first time! NOTE: For more information on alerts, feel free to check out the following resources: Dash Alerts Everything We've Covered Dash Dreamland \u00b6 There are hundreds of more Dash elements, including Dash Core Components, Dash Bootstrap Components, Plotly, Ploly Express, HTML , and more . Diving into these elements is beyond the scope of this introductory journey! However, here's a quick summary of everything we've learned along the way, a sort of cheat-sheet... Plotly Charts Dash/Tigergraph HTML Dash Core Bootstrap Bar Charts Layout Functions Div Graphs Cards Line Charts Styling App Headers Markdown Row/Col Pie Charts Multi-Paged Paragraph Location Badges Scatter Plots Callbacks Bold/Italic Links ListGroup Cytoscape Navbars Center Input Jumbotron Radar Charts Sidebars Link Dropdown Button 3-D Figures Create Solution Hr. Rule Table Choropleth Connect w/ pyTG Line Break Progress Install Queries Image Spinner Run Queries Alert Feel free to utilize the \"Search\" box at the top right of this webpage to quickly reference each. We've learned quite a lot within the span of less than a dozen chapters \ud83d\ude04. NOTE: All code segments from this chapter can be found in this Ch 12 - Dash Deployment \u00b6 Deploying Dash App Heroku, Dash Enterprise \u00b6 According to the Plotly Website, \"Heroku is one of the easiest platforms for deploying and managing public Flask applications.\" Plotly Dash documents the step-by-step procedure needed to deploy one's app on Heroku . Additional Resource: Medium Guide 1 Additional Resource: Medium Guide 2 Another option is via the paid Dash Enterprise platform. Both options are doucmented by Plotly below. window.getElementById('heroku').scrollTo(2000, 2000); Congratulations! The Fantastic Finale \u00b6 Congratulations! You've put together (and maybe even deployed) your dashboard with TigerGraph + Plotly . It's time to celebrate now! \ud83e\udd73\ud83e\udd73\ud83e\udd73 Feel free to continue adding, maybe with a few queries and some of the elements from \"Elysium of Elements\" . Additionally, there are quite a few examples of other Starter Kits under the \"Examples\" tab!. Finally, make sure to connect with the TigerGraph + Plotly community (found under the \"Community\" tab). Best of luck, and remember to share your cool work with others in the developer world! Congratulations, you've completed TigerGraph's Dash Adventure!","title":"Misc. Elements, Deployment"},{"location":"quick/06_notes/#misc-elements-deployment","text":"","title":"Misc. Elements, Deployment"},{"location":"quick/06_notes/#ch-11-miscellaneous-elements","text":"Radar, 3D, Choropleth","title":"Ch 11 - Miscellaneous Elements"},{"location":"quick/06_notes/#plotly-paradise","text":"Although we've explored several core Plotly figures that are used extensively across dashboards, there are a myriad of other charts that can be made using Plotly. In this section, we'll explore a few of them. NOTE: Feel free to submit requests for other elements. This chapter may be updated to include them as well!","title":"Plotly Paradise"},{"location":"quick/06_notes/#radar-charts","text":"Radar charts are used to visualize different traces across different axes . For example, if one wished to compare restaurants across five different categories , a radar chart would be a perfect visualization. Let's take a look at creating one with Plotly. categories = [ 'Food' , 'Service' , 'Affordable' , 'Location' , 'Ambience' ] res = { \"Pop's Pizzas\" : [ 3 , 3 , 5 , 4 , 3 ], \"Tony's Tacos\" : [ 5 , 2 , 4 , 1 , 2 ], \"Bill's Bread\" : [ 2 , 4 , 1 , 2 , 4 ], } fig = go . Figure () for restaurant in res : fig . add_trace ( go . Scatterpolar ( r = res [ restaurant ], theta = categories , fill = 'toself' , name = restaurant , )) fig . update_layout ( polar = dict ( radialaxis = dict ( visible = True ), ), width = 800 ) fig . show () As seen, we create a go.Figure() and add multiple traces. Each trace represents a distinct data entity, in this case different restaurants. Each restaurant has been scored across different categories, and categories are stored in theta , while each value is stored in r . In fig.update_layout() , the figure is converted into polar form to create our circular radar chart. It's a lot easier to visualize how each restaurant compares! NOTE: This format is similar to polar axes, where each point is determine in r and theta instead of x and y. NOTE: For more resources on Radar Charts, feel free to check out the following resources: Plotly Radar","title":"Radar Charts"},{"location":"quick/06_notes/#3-d-figures","text":"In order to create 3D plots, we can use the px.scatter_3d() function. This simply requires us to enter a list value for x, y, and z. Dataframes can also be used to create a 3-D figure, formatted the same as with px.scatter() . Here's an example of a 3D parabolic curve: import numpy as np t = np . linspace ( - 10 , 10 , 50 ) x = t y = t ** 2 z = 3 * x - 2 * y fig = px . scatter_3d ( x = x , y = y , z = z ) fig . show () NOTE: np.linspace() simply creates a list from -10 to 10, with 50 data points in between, spaced evenly. NOTE: For more information on Radar Charts, feel free to check out the following resources: Scatter , 3D Charts","title":"3-D Figures"},{"location":"quick/06_notes/#choropleth-maps","text":"Plotly allows for the creation and insertion of geographical maps using geojson data. Choropleth maps allow for the visulization of distinct geographical zones with different colors to indicate different attributes. In order to use the Plotly Choropleth example, we need to install the following. ! pip install - U plotly from urllib.request import urlopen import json import pandas as pd import plotly.express as px NOTE: We need to upgrade our version of Plotly to the latest to ensure that Choropleth works! Now, we can use the Plotly datasets in order to visualize the unemployment in the United States. with urlopen ( 'https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json' ) as response : counties = json . load ( response ) df = pd . read_csv ( \"https://raw.githubusercontent.com/plotly/datasets/master/fips-unemp-16.csv\" , dtype = { \"fips\" : str }) fig = px . choropleth ( df , geojson = counties , locations = 'fips' , color = 'unemp' , color_continuous_scale = \"Viridis\" , range_color = ( 0 , 12 ), scope = \"usa\" , labels = { 'unemp' : 'unemployment rate' } ) fig . update_layout ( margin = { \"r\" : 0 , \"t\" : 0 , \"l\" : 0 , \"b\" : 0 }) fig . show () As seen, it's quite a detailed, interactive map! NOTE: For more information on Maps, feel free to check out the following resources: Choropleth Progress, Spinners, Alerts","title":"Choropleth (Maps)"},{"location":"quick/06_notes/#bootstrap-bliss","text":"As with Plotly, there are dozens of other unique Bootstrap components that can be incorporated into one's dashboard. Although we've covered the core elements, we'll explore three more in this section. NOTE: For a comprehensive list on all bootstrap components, feel free to check out: Dash Bootstrap","title":"Bootstrap Bliss"},{"location":"quick/06_notes/#progress-bars","text":"Progress bars are horizontal, rounded rectangles that are quite flexible when it comes to displaying progress. Here's an example of a progress bar with three distinct sections. progress = dbc . Progress ( [ dbc . Progress ( value = 20 , color = \"success\" , bar = True ), dbc . Progress ( value = 30 , color = \"warning\" , bar = True ), dbc . Progress ( value = 20 , color = \"danger\" , bar = True ), ], multi = True , ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Col ( progress , width = 6 ) ]) app . run_server ( mode = 'external' ) As seen, each bar section has a different color and length ( value ). This bar can also be animated , controlled via a button that toggles the bar on and off. progress = html . Div ( [ dbc . Progress ( value = 80 , id = \"animated-progress\" , animated = False , striped = True ), dbc . Button ( \"Toggle animation\" , id = \"animation-toggle\" , className = \"mt-3\" , n_clicks = 0 , ), ] ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Col ( progress , width = 6 ) ]) @app . callback ( dash . dependencies . Output ( \"animated-progress\" , \"animated\" ), [ dash . dependencies . Input ( \"animation-toggle\" , \"n_clicks\" )], [ dash . dependencies . State ( \"animated-progress\" , \"animated\" )], ) def toggle_animation ( n , animated ): if n : return not animated return animated app . run_server ( mode = 'external' ) Ah-ah, one interesting addition is the variable dash.dependencies.State as part of our app's callback. This simply means that the state of the progress bar (whether it is currently animated or not) is also used to determine the output. This makes sense, since our toggle button inverts whatever the state of the progress bar is. NOTE: For more information on progress bars, feel free to check out the following resources: Progress","title":"Progress Bars"},{"location":"quick/06_notes/#spinners","text":"Next up, spinners! These components are small circles that move to indicate that a process is occurring. Here are three examples (one small, one big, and one growing). spinners = html . Div ( [ dbc . Row ([ dbc . Col ( dbc . Spinner ( size = \"sm\" , color = \"info\" ), width = 1 ), dbc . Col ( dbc . Spinner ( spinner_style = { \"width\" : \"3rem\" , \"height\" : \"3rem\" }, color = \"success\" ), width = 1 ), dbc . Col ( dbc . Spinner ( color = \"danger\" , type = \"grow\" ), width = 1 ), ]) ] ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Col ( spinners , width = 6 ) ]) app . run_server ( mode = 'external' ) Each can be easily colored, resized, and toggled between traditional mode and growing mode. Spinners can also be used to indicate loading, or to be displayed upon a user action . For example, the following displays a spinner based on the number of times the button is pressed. After the time has elapsed, the spinner is replaced with the output. import time loading_spinner = html . Div ( [ dbc . Button ( \"Counter\" , id = \"loading-button\" , n_clicks = 0 ), dbc . Spinner ( html . Div ( id = \"loading-output\" )), ] ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Col ( loading_spinner , width = 3 ) ]) @app . callback ( dash . dependencies . Output ( \"loading-output\" , \"children\" ), [ dash . dependencies . Input ( \"loading-button\" , \"n_clicks\" )] ) def load_output ( n ): if n : time . sleep ( 1 ) return f \"You have clicked { n } times\" return \"No clicks as of yet ;(\" app . run_server ( mode = 'external' ) NOTE: For more information on spinners, feel free to check out the following resources: Dash Spinners","title":"Spinners"},{"location":"quick/06_notes/#alerts","text":"Next up, Dash Alerts! These components are used to display important information, such as messages, information the user should know before proceeding , or any other form of alerts. Like all bootstrap, they are quite flexible. Here's an example with two alerts, one of them dismissible (able to be closed) and the other permanent . alerts = html . Div ([ dbc . Alert ( \"This is a success alert! Luckily, I won't leave!\" , color = \"success\" ), dbc . Alert ( \"This is a warning alert, but you can close me!\" , color = \"warning\" , dismissable = True ), ]) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Col ( alerts , width = 6 ) ]) app . run_server ( mode = 'external' ) These alarms can be easily customized in terms of color and content. Additionally, they can be set to automatically disappear after a certain amount of time . This is done via the keyword duration , which takes in milliseconds. Here's an example with a disappearing alert, accompanied by a button that toggles the state of the alert. alert = html . Div ( [ dbc . Button ( \"Switch States\" , id = \"alert-toggle-auto\" , className = \"mr-1\" , n_clicks = 0 ), html . Hr (), dbc . Alert ( \"I will disappear in 3 seconds...\" , id = \"alert-auto\" , color = \"danger\" , is_open = True , duration = 3000 , # In milliseconds ), ] ) app = JupyterDash ( __name__ , external_stylesheets = [ dbc . themes . BOOTSTRAP ]) app . layout = html . Div ( children = [ dbc . Col ( alert , width = 6 ) ]) @app . callback ( dash . dependencies . Output ( \"alert-auto\" , \"is_open\" ), [ dash . dependencies . Input ( \"alert-toggle-auto\" , \"n_clicks\" )], [ dash . dependencies . State ( \"alert-auto\" , \"is_open\" )], ) def toggle_alert ( n , is_open ): if n : return not is_open return is_open app . run_server ( mode = 'external' ) Quite handy, especially to help users navigate a dashboard for the first time! NOTE: For more information on alerts, feel free to check out the following resources: Dash Alerts Everything We've Covered","title":"Alerts"},{"location":"quick/06_notes/#dash-dreamland","text":"There are hundreds of more Dash elements, including Dash Core Components, Dash Bootstrap Components, Plotly, Ploly Express, HTML , and more . Diving into these elements is beyond the scope of this introductory journey! However, here's a quick summary of everything we've learned along the way, a sort of cheat-sheet... Plotly Charts Dash/Tigergraph HTML Dash Core Bootstrap Bar Charts Layout Functions Div Graphs Cards Line Charts Styling App Headers Markdown Row/Col Pie Charts Multi-Paged Paragraph Location Badges Scatter Plots Callbacks Bold/Italic Links ListGroup Cytoscape Navbars Center Input Jumbotron Radar Charts Sidebars Link Dropdown Button 3-D Figures Create Solution Hr. Rule Table Choropleth Connect w/ pyTG Line Break Progress Install Queries Image Spinner Run Queries Alert Feel free to utilize the \"Search\" box at the top right of this webpage to quickly reference each. We've learned quite a lot within the span of less than a dozen chapters \ud83d\ude04. NOTE: All code segments from this chapter can be found in this","title":"Dash Dreamland"},{"location":"quick/06_notes/#ch-12-dash-deployment","text":"Deploying Dash App","title":"Ch 12 - Dash Deployment"},{"location":"quick/06_notes/#heroku-dash-enterprise","text":"According to the Plotly Website, \"Heroku is one of the easiest platforms for deploying and managing public Flask applications.\" Plotly Dash documents the step-by-step procedure needed to deploy one's app on Heroku . Additional Resource: Medium Guide 1 Additional Resource: Medium Guide 2 Another option is via the paid Dash Enterprise platform. Both options are doucmented by Plotly below. window.getElementById('heroku').scrollTo(2000, 2000); Congratulations!","title":"Heroku, Dash Enterprise"},{"location":"quick/06_notes/#the-fantastic-finale","text":"Congratulations! You've put together (and maybe even deployed) your dashboard with TigerGraph + Plotly . It's time to celebrate now! \ud83e\udd73\ud83e\udd73\ud83e\udd73 Feel free to continue adding, maybe with a few queries and some of the elements from \"Elysium of Elements\" . Additionally, there are quite a few examples of other Starter Kits under the \"Examples\" tab!. Finally, make sure to connect with the TigerGraph + Plotly community (found under the \"Community\" tab). Best of luck, and remember to share your cool work with others in the developer world! Congratulations, you've completed TigerGraph's Dash Adventure!","title":"The Fantastic Finale"}]}